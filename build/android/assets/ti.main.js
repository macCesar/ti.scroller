'use strict';

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          } });

      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * This script is used to load ACA (Axway Crash Analytics).
 * This allows ACA to be the first module to load on startup.
 */
Promise.resolve().then(function () {return /*#__PURE__*/_interopNamespace(require('com.appcelerator.aca'));}).catch(() => {// No need to notify of ACA load failure.
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* eslint-disable quote-props */

/* globals OS_ANDROID, OS_IOS */
// Add global constants.

Object.defineProperties(commonjsGlobal, {
  'OS_ANDROID': {
    value: true,
    writable: false },

  'OS_IOS': {
    value: false,
    writable: false },

  OS_VERSION_MAJOR: {
    value: Ti.Platform.versionMajor,
    writable: false },

  OS_VERSION_MINOR: {
    value: Ti.Platform.versionMinor,
    writable: false },

  OS_VERSION_PATCH: {
    value: Ti.Platform.versionPatch,
    writable: false } });



// Copyright Node.js contributors. All rights reserved.
const kNodeModulesRE = /^(.*)[\\/]node_modules[\\/]/;
const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');
const isBuffer = Symbol.for('titanium.buffer.isBuffer');
const colorRegExp = /\u001b\[\d\d?m/g; // eslint-disable-line no-control-regex

function removeColors(str) {
  return str.replace(colorRegExp, '');
}
function isError(e) {
  // An error could be an instance of Error while not being a native error
  // or could be from a different realm and not be instance of Error but still
  // be a native error.
  return isNativeError(e) || e instanceof Error;
}
let getStructuredStack;

class StackTraceError extends Error {}

StackTraceError.prepareStackTrace = (err, trace) => trace;

StackTraceError.stackTraceLimit = Infinity;
function isInsideNodeModules() {
  if (getStructuredStack === undefined) {
    getStructuredStack = () => new StackTraceError().stack;
  }

  let stack = getStructuredStack(); // stack is only an array on v8, try to convert manually if string

  if (typeof stack === 'string') {
    const stackFrames = [];
    const lines = stack.split(/\n/);

    for (const line of lines) {
      const lineInfo = line.match(/(.*)@(.*):(\d+):(\d+)/);

      if (lineInfo) {
        const filename = lineInfo[2].replace('file://', '');
        stackFrames.push({
          getFileName: () => filename });

      }
    }

    stack = stackFrames;
  } // Iterate over all stack frames and look for the first one not coming
  // from inside Node.js itself:


  if (Array.isArray(stack)) {
    for (const frame of stack) {
      const filename = frame.getFileName(); // If a filename does not start with / or contain \,
      // it's likely from Node.js core.

      if (!/^\/|\\/.test(filename)) {
        continue;
      }

      return kNodeModulesRE.test(filename);
    }
  }

  return false;
}
function join$1(output, separator) {
  let str = '';

  if (output.length !== 0) {
    const lastIndex = output.length - 1;

    for (let i = 0; i < lastIndex; i++) {
      // It is faster not to use a template string here
      str += output[i];
      str += separator;
    }

    str += output[lastIndex];
  }

  return str;
}
function uncurryThis(f) {
  return function () {
    return f.call.apply(f, arguments);
  };
}
const ALL_PROPERTIES$2 = 0;
const ONLY_ENUMERABLE$2 = 2;
const propertyFilter = {
  ALL_PROPERTIES: ALL_PROPERTIES$2,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$2 };

function getOwnNonIndexProperties(obj, filter) {
  const props = [];
  const keys = filter === ONLY_ENUMERABLE$2 ? Object.keys(obj) : Object.getOwnPropertyNames(obj);

  for (var i = 0; i < keys.length; ++i) {
    const key = keys[i];

    if (!isAllDigits(key)) {
      props.push(key);
    }
  }

  return props;
}

function isAllDigits(s) {
  if (s.length === 0) {
    return false;
  }

  for (var i = 0; i < s.length; ++i) {
    const code = s.charCodeAt(i);

    if (code < 48 || code > 57) {
      return false;
    }
  }

  return true;
}

// Copyright Node.js contributors. All rights reserved.
const TypedArrayPrototype$1 = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_toStringTag = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype$1, Symbol.toStringTag).get);

function isObject(value) {
  return typeof value === 'object';
}

function isFunction(value) {
  return typeof value === 'function';
}

function checkPrototype(value, name) {
  return Object.prototype.toString.call(value) === `[object ${name}]`;
}

function isAnyArrayBuffer(value) {
  if (isArrayBuffer(value)) {
    return true;
  }

  return isSharedArrayBuffer(value);
}
function isArgumentsObject(value) {
  return isObject(value) && checkPrototype(value, 'Arguments');
}
function isArrayBuffer(value) {
  return isObject(value) && checkPrototype(value, 'ArrayBuffer');
} // Cached to make sure no userland code can tamper with it.

const isArrayBufferView = ArrayBuffer.isView;
function isAsyncFunction(value) {
  return isFunction(value) && checkPrototype(value, 'AsyncFunction');
}
function isBigInt64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigInt64Array';
}
function isBigUint64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigUint64Array';
}
function isBooleanObject(value) {
  return isObject(value) && checkPrototype(value, 'Boolean');
}
function isBoxedPrimitive(value) {
  if (!isObject(value)) {
    return false;
  }

  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) // || isBigIntObject(value)
  || isSymbolObject(value);
}
function isDataView(value) {
  return isObject(value) && checkPrototype(value, 'DataView');
}
function isDate(value) {
  return isObject(value) && checkPrototype(value, 'Date');
} // @todo isExternal

function isFloat32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float32Array';
}
function isFloat64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float64Array';
}
function isGeneratorFunction(value) {
  return isFunction(value) && checkPrototype(value, 'GeneratorFunction');
}
function isGeneratorObject(value) {
  return isObject(value) && checkPrototype(value, 'Generator');
}
function isInt8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int8Array';
}
function isInt16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int16Array';
}
function isInt32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int32Array';
}
function isMap(value) {
  return isObject(value) && checkPrototype(value, 'Map');
}
function isMapIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Map Iterator';
} // @todo isModuleNamespaceObject

function isNativeError(value) {
  // if not an instance of an Error, definitely not a native error
  if (!(value instanceof Error)) {
    return false;
  }

  if (!value || !value.constructor) {
    return false;
  }

  return ['Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'].includes(value.constructor.name);
}
function isNumberObject(value) {
  return isObject(value) && checkPrototype(value, 'Number');
}
function isPromise(value) {
  return isObject(value) && checkPrototype(value, 'Promise');
} // @todo isProxy

function isRegExp(value) {
  return isObject(value) && checkPrototype(value, 'RegExp');
}
function isSet(value) {
  return isObject(value) && checkPrototype(value, 'Set');
}
function isSetIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Set Iterator';
}
function isSharedArrayBuffer(value) {
  if (!global.SharedArrayBuffer) {
    return false;
  }

  return isObject(value) && checkPrototype(value, 'SharedArrayBuffer');
}
function isStringObject(value) {
  return isObject(value) && checkPrototype(value, 'String');
}
function isSymbolObject(value) {
  return isObject(value) && checkPrototype(value, 'Symbol');
}
function isTypedArray(value) {
  const isBuiltInTypedArray = TypedArrayProto_toStringTag(value) !== undefined;

  if (isBuiltInTypedArray) {
    return true;
  }

  return value[isBuffer] === true;
}
function isUint8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8Array';
}
function isUint8ClampedArray(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';
}
function isUint16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint16Array';
}
function isUint32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint32Array';
}
function isWeakMap(value) {
  return isObject(value) && checkPrototype(value, 'WeakMap');
}
function isWeakSet(value) {
  return isObject(value) && checkPrototype(value, 'WeakSet');
} // @todo isWebAssemblyCompiledModule

var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isAnyArrayBuffer: isAnyArrayBuffer,
  isArgumentsObject: isArgumentsObject,
  isArrayBuffer: isArrayBuffer,
  isArrayBufferView: isArrayBufferView,
  isAsyncFunction: isAsyncFunction,
  isBigInt64Array: isBigInt64Array,
  isBigUint64Array: isBigUint64Array,
  isBooleanObject: isBooleanObject,
  isBoxedPrimitive: isBoxedPrimitive,
  isDataView: isDataView,
  isDate: isDate,
  isFloat32Array: isFloat32Array,
  isFloat64Array: isFloat64Array,
  isGeneratorFunction: isGeneratorFunction,
  isGeneratorObject: isGeneratorObject,
  isInt8Array: isInt8Array,
  isInt16Array: isInt16Array,
  isInt32Array: isInt32Array,
  isMap: isMap,
  isMapIterator: isMapIterator,
  isNativeError: isNativeError,
  isNumberObject: isNumberObject,
  isPromise: isPromise,
  isRegExp: isRegExp,
  isSet: isSet,
  isSetIterator: isSetIterator,
  isSharedArrayBuffer: isSharedArrayBuffer,
  isStringObject: isStringObject,
  isSymbolObject: isSymbolObject,
  isTypedArray: isTypedArray,
  isUint8Array: isUint8Array,
  isUint8ClampedArray: isUint8ClampedArray,
  isUint16Array: isUint16Array,
  isUint32Array: isUint32Array,
  isWeakMap: isWeakMap,
  isWeakSet: isWeakSet });


// Copyright Node.js contributors. All rights reserved.
let error;

function lazyError() {
  if (!error) {
    // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
    // error = require('./errors').codes.ERR_INTERNAL_ASSERTION;
    error = codes.ERR_INTERNAL_ASSERTION;
  }

  return error;
}

function assert$1(value, message) {
  if (!value) {
    const ERR_INTERNAL_ASSERTION = lazyError();
    throw new ERR_INTERNAL_ASSERTION(message);
  }
}

function fail(message) {
  const ERR_INTERNAL_ASSERTION = lazyError();
  throw new ERR_INTERNAL_ASSERTION(message);
}

assert$1.fail = fail;

// Copyright Node.js contributors. All rights reserved.
const messages = new Map();
const codes = {}; // @todo implement this once needed

class SystemError extends Error {} // Utility function for registering the error codes.


function E(sym, val, def, ...otherClasses) {
  // Special case for SystemError that formats the error message differently
  // The SystemErrors only have SystemError as their base classes.
  messages.set(sym, val);

  if (def === SystemError) {
    throw new Error('Node compatible SystemError not yet implemented.');
  } else {
    def = makeNodeErrorWithCode(def, sym);
  }

  if (otherClasses.length !== 0) {
    otherClasses.forEach(clazz => {
      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);
    });
  }

  codes[sym] = def;
}

function makeNodeErrorWithCode(Base, key) {
  return class NodeError extends Base {
    constructor(...args) {
      super();
      const message = getMessage(key, args, this);
      Object.defineProperty(this, 'message', {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true });

      addCodeToName(this, super.name, key);
    }

    get code() {
      return key;
    }

    set code(value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true });

    }

    toString() {
      return `${this.name} [${key}]: ${this.message}`;
    }};


}

function getMessage(key, args, self) {
  const msg = messages.get(key);
  /*
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  if (assert === undefined) {
  	assert = require('./internal/assert');
  }
  */

  if (typeof msg === 'function') {
    assert$1(msg.length <= args.length, // Default options do not count.
    `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${msg.length}).`);
    return msg.apply(self, args);
  }

  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
  assert$1(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);

  if (args.length === 0) {
    return msg;
  }

  args.unshift(msg);
  return format$1.apply(null, args); // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  // return lazyInternalUtilInspect().format.apply(null, args);
}

function addCodeToName(err, name, code) {
  // Add the error code to the name to include it in the stack trace.
  err.name = `${name} [${code}]`; // Access the stack to generate the error message including the error code
  // from the name.
  // @fixme: This only works on V8/Android, iOS/JSC has a different Error structure.
  // should we try to make errors behave the same across platforms?
  // eslint-disable-next-line no-unused-expressions

  err.stack; // Reset the name to the actual name.

  if (name === 'SystemError') {
    Object.defineProperty(err, 'name', {
      value: name,
      enumerable: false,
      writable: true,
      configurable: true });

  } else {
    delete err.name;
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS', // Using a default argument here is important so the argument is not counted
// towards `Function#length`.
(name = undefined) => {
  if (name) {
    return `"${name}" is outside of buffer bounds`;
  }

  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INTERNAL_ASSERTION', message => {
  const suffix = 'This is caused by either a bug in Titanium ' + 'or incorrect usage of Titanium internals.\n' + 'Please open an issue with this stack trace at ' + 'https://jira.appcelerator.org\n';
  return message === undefined ? suffix : `${message}\n${suffix}`;
}, Error);
E('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {
  assert$1(typeof name === 'string', '\'name\' must be a string'); // determiner: 'must be' or 'must not be'

  let determiner;

  if (typeof expected === 'string' && expected.startsWith('not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;

  if (name.endsWith(' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = name.includes('.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
let maxStack_ErrorName;
let maxStack_ErrorMessage;
/**
 * Returns true if `err.name` and `err.message` are equal to engine-specific
 * values indicating max call stack size has been exceeded.
 * "Maximum call stack size exceeded" in V8.
 *
 * @param {Error} err The error to check
 * @returns {boolean}
 */

function isStackOverflowError(err) {
  if (maxStack_ErrorMessage === undefined) {
    try {
      function overflowStack() {
        overflowStack();
      }

      overflowStack();
    } catch (e) {
      maxStack_ErrorMessage = e.message;
      maxStack_ErrorName = e.name;
    }
  }

  return err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;
}

function oneOf(expected, thing) {
  assert$1(typeof thing === 'string', '`thing` has to be of type string');

  if (Array.isArray(expected)) {
    const len = expected.length;
    assert$1(len > 0, 'At least one expected value needs to be specified');
    expected = expected.map(i => String(i));

    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

class FastBuffer extends Uint8Array {}
/**
 * loop over input, every 2 characters, parse as an int
 * basically each two characters are a "byte" or an 8-bit uint
 * we append them all together to form a single buffer holding all the values
 * @param {string} value string we're encoding in hex
 * @returns {integer[]} array of encoded bytes
 */

function stringToHexBytes(value) {
  const length = value.length / 2;
  const byteArray = [];

  for (let i = 0; i < length; i++) {
    const numericValue = parseInt(value.substr(i * 2, 2), 16);

    if (!Number.isNaN(numericValue)) {
      // drop bad hex characters
      byteArray.push(numericValue);
    }
  }

  return byteArray;
}

const arrayIndexHandler = {
  get(target, propKey, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        return getAdjustedIndex(target, num);
      }
    } else if (propKey === isBuffer) {
      return true;
    }

    return Reflect.get(target, propKey, receiver);
  },

  set(target, propKey, value, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        setAdjustedIndex(target, num, value);
        return true;
      }
    }

    return Reflect.set(target, propKey, value, receiver);
  },

  has(target, key) {
    if (typeof key === 'string') {
      const num = Number(key);

      if (Number.isSafeInteger(num)) {
        // ensure it's a positive "safe" integer within the range of the buffer
        return num >= 0 && num < target._tiBuffer.length;
      }
    }

    return key in target;
  } };

// This is a special Buffer that wraps Ti.Buffer
// as a result it is *much* slower to read/write values
// because we need to go across the JS/Native boundary per-byte!
// We also need to use a Proxy to handle intercepting set/get of indices to redirect to the underlying Ti.Buffer

class SlowBuffer {
  /**
   * Constructs a new buffer.
   *
   * Primarily used internally in this module together with `newBuffer` to
   * create a new Buffer instance wrapping a Ti.Buffer.
   *
   * Also supports the deprecated Buffer() constructors which are safe
   * to use outside of this module.
   *
   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
   * @param {integer} [start=0] start offset of array/buffer
   * @param {integer} [length] length of the underlying array/buffer to wrap
   */
  constructor(tiBuffer, start = 0, length = tiBuffer.length - start) {
    Object.defineProperties(this, {
      byteOffset: {
        value: start },

      length: {
        value: length },

      _tiBuffer: {
        value: tiBuffer } });


  }
  /**
   * Wraps creation of a Buffer instance inside a Proxy so we can handle array index access
   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
   * @param {integer} [start=0] start offset of array/buffer
   * @param {integer} [length] length of the underlying array/buffer to wrap
   * @returns {Buffer} wrapped inside a Proxy
   */


  static fromTiBuffer(tiBuffer, start, length) {
    return new Proxy(new SlowBuffer(tiBuffer, start, length), arrayIndexHandler); // eslint-disable-line security/detect-new-buffer
  }

  static fromString(value, encoding) {
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }

    encoding = encoding.toLowerCase();

    if (encoding === 'base64') {
      const blob = Ti.Utils.base64decode(value);
      const blobStream = Ti.Stream.createStream({
        source: blob,
        mode: Ti.Stream.MODE_READ });

      const buffer = Ti.Stream.readAll(blobStream);
      blobStream.close();
      return SlowBuffer.fromTiBuffer(buffer);
    }

    if (encoding === 'hex') {
      const bytes = stringToHexBytes(value);
      const length = bytes.length;
      const tiBuffer = Ti.createBuffer({
        length });


      for (let i = 0; i < length; i++) {
        tiBuffer[i] = bytes[i] & 0xFF; // mask to one byte
      }

      return SlowBuffer.fromTiBuffer(tiBuffer);
    }

    const tiBuffer = Ti.createBuffer({
      value: value,
      type: getTiCodecCharset(encoding) });

    return SlowBuffer.fromTiBuffer(tiBuffer);
  } // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer


  get buffer() {
    // Get the slice of the array from byteOffset to length
    return Uint8Array.from(this).buffer;
  }

  _slice(offset, length) {
    return SlowBuffer.fromTiBuffer(this._tiBuffer, offset, length);
  }

  _fill(value, offset, end, encoding) {
    const valueType = typeof value;

    if (valueType === 'string') {
      const bufToFillWith = SlowBuffer.fromString(value, encoding);
      const fillBufLength = bufToFillWith.length;

      if (fillBufLength === 0) {
        throw new Error('no valid fill data');
      } // If the buffer length === 1, we can just do this._tiBuffer.fill(value, offset, end);


      if (fillBufLength === 1) {
        this._tiBuffer.fill(bufToFillWith._tiBuffer[0], offset, end);

        return this;
      } // multiple byte fill!


      const length = end - offset;

      for (let i = 0; i < length; i++) {
        // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
        const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
        this._tiBuffer[i + offset] = fillChar;
      }

      return this;
    } // if the value is a number (or a buffer with a single byte) we can use tiBuffer.fill();


    this._tiBuffer.fill(value, offset, end);
  }

  getAdjustedIndex(index) {
    return getAdjustedIndex(this, index);
  }

  setAdjustedIndex(index, value) {
    return setAdjustedIndex(this, index, value);
  } // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer


  set(src, offset = 0) {
    const numBytes = src.length; // check src.length + offset doesn't go beyond our length!
    // FIXME: Re-enable
    // checkOffset(this, offset, numBytes);
    // copy src values into this buffer starting at offset

    for (let i = 0; i < numBytes; i++) {
      setAdjustedIndex(this, i + offset, src[i]);
    }
  }
  /**
   * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
   * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
   */


  toTiBuffer() {
    if (this.length === this._tiBuffer.length && this.byteOffset === 0) {
      return this._tiBuffer;
    }

    return this._tiBuffer.clone(this.byteOffset, this.length);
  }}



function getAdjustedIndex(buf, index) {
  if (index < 0) {
    return undefined;
  } // Wrapping Ti.Buffer?


  if (buf._tiBuffer) {
    if (index >= buf._tiBuffer.length) {
      return undefined;
    }

    return buf._tiBuffer[index + buf.byteOffset];
  } // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?


  return buf[index];
}

function setAdjustedIndex(buf, index, value) {
  if (index < 0) {
    return;
  } // Wrapping Ti.Buffer?


  if (buf._tiBuffer) {
    if (index < buf._tiBuffer.length) {
      buf._tiBuffer[index + buf.byteOffset] = value;
    }

    return;
  } // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?


  buf[index] = value;
} // https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings


const TI_CODEC_MAP = new Map();
TI_CODEC_MAP.set('utf-8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf-16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('utf16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs-2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('latin1', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('binary', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('ascii', Ti.Codec.CHARSET_ASCII);
/**
 * @param {string} encoding desired encoding name
 * @returns {integer} Ti.Codec constant that maps to the encoding
 */

function getTiCodecCharset(encoding) {
  return TI_CODEC_MAP.get(encoding);
}

/**
 * This implementation of Buffer uses a Ti.Buffer internally to back it.
 * This is likley an order of magnitude slower than using a variant that extends Uint8Array!
 * I think if we're not already wrapping a Ti.Buffer, it may be better to have two implementations
 * and, like browserify, just extend Uint8Array for any Buffers we need to read/write a lot
 * and then add a simple conversion method to turn it into a Ti.Buffer when needed.
 *
 * The Ti.Buffer impl has to go through the binding layer for reading/writing every byte.
 * If we anticipate the Buffer staying on the JS side, I'm willing to bet that the Uint8Array
 * the JS engine provides would be *way* faster.
 *
 * Also note that both Ti.Buffer and Node's Buffer were created before the JS engines had typed arrays
 * (and Uint8Array in particular) as a means of encapsulating a byte array. We should consider accepting
 * a Uint8Array in any of our APIs that take a Ti.Buffer and eventually deprecating/removing Ti.Buffer.
 */
const {
  ALL_PROPERTIES: ALL_PROPERTIES$1,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$1 } =
propertyFilter;
const VALID_ENCODINGS = ['hex', 'utf8', 'utf-8', 'ascii', 'latin1', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le']; // Used to cheat for read/writes of doubles

const doubleArray = new Float64Array(1);
const uint8DoubleArray = new Uint8Array(doubleArray.buffer); // Used to cheat to read/write floats

const floatArray = new Float32Array(1);
const uint8FloatArray = new Uint8Array(floatArray.buffer); // Node.js does some very weird stuff here

FastBuffer.prototype.constructor = Buffer$1; // new FastBuffer() calls Buffer function?

Buffer$1.prototype = FastBuffer.prototype; // Then it hijacks Buffer's prototype to point at FastBuffer's?!
// Does this effectively mean Buffer extends Uint8Array, because FastBuffer did? This fails for me
// How the hell can we make it happy? We really want to extend Uint8Array if we can
// addBufferPrototypeMethods(Buffer.prototype); // Here's where it hangs some of the methods

Buffer$1.poolSize = 8192;
/**
 * Constructs a new buffer.
 *
 * Primarily used internally in this module together with `newBuffer` to
 * create a new Buffer instance wrapping a Ti.Buffer.
 *
 * Also supports the deprecated Buffer() constructors which are safe
 * to use outside of this module.
 *
 * @param {integer[]|Buffer|integer|string|Ti.Buffer} arg the underlying data/bytes
 * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
 * @param {integer} length length of the underlying array/buffer to wrap
 * @returns {Buffer}
 */

function Buffer$1(arg, encodingOrOffset, length) {
  if (arg === undefined) {
    return;
  }

  if (typeof arg !== 'object' || arg.apiName !== 'Ti.Buffer') {
    showFlaggedDeprecation();

    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(`The "string" argument must be of type "string". Received type ${typeof arg}`);
      }

      return Buffer$1.alloc(arg);
    }

    return Buffer$1.from(arg, encodingOrOffset, length);
  } // The slow case - we're wrapping a Ti.Buffer


  return SlowBuffer.fromTiBuffer(arg, encodingOrOffset, length);
}
/**
 * @param {integer[]|Buffer|string} value value we're wrapping
 * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
 * @param {integer} length length of the underlying array/buffer to wrap
 * @returns {Buffer}
 */


Buffer$1.from = function (value, encodingOrOffset, length) {
  const valueType = typeof value;

  if (valueType === 'string') {
    return fromString(value, encodingOrOffset);
  } else if (valueType === 'object') {
    if (isAnyArrayBuffer(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }

    if (Array.isArray(value) || value instanceof Uint8Array) {
      return fromArray(value);
    }

    if (Buffer$1.isBuffer(value)) {
      return fromBuffer(value);
    } // We want to limit the use of SlowBuffers to only when we're wrapping a Ti.Buffer, hopefully!


    if (value.apiName && value.apiName === 'Ti.Buffer') {
      return SlowBuffer.fromTiBuffer(value);
    }
  }

  throw new TypeError('The \'value\' argument must be one of type: \'string\', \'Array\', \'Buffer\', \'Ti.Buffer\'');
};
/**
 * @param {ArrayBuffer} obj ArrayBuffer to wrap
 * @param {number} [byteOffset=0] byte offste to begin
 * @param {number} [length] length to wrap
 * @returns {Buffer}
 */


function fromArrayBuffer(obj, byteOffset, length) {
  // Convert byteOffset to integer
  if (byteOffset === undefined) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;

    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }

  const maxLength = obj.byteLength - byteOffset;

  if (maxLength < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('offset');
  }

  if (length === undefined) {
    length = maxLength;
  } else {
    // Convert length to non-negative integer.
    length = +length;

    if (length > 0) {
      if (length > maxLength) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('length');
      }
    } else {
      length = 0;
    }
  }

  return new FastBuffer(obj, byteOffset, length);
}
/**
 * @param {string} value value to wrap
 * @param {string} [encoding='utf8'] character encoding
 * @returns {Buffer}
 */


function fromString(value, encoding = 'utf8') {
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError(`Unknown encoding: ${encoding}`);
  }

  encoding = encoding.toLowerCase();

  if (encoding === 'base64') {
    const blob = Ti.Utils.base64decode(value);
    return new FastBuffer(blob.toArrayBuffer());
  }

  if (encoding === 'hex') {
    return fromArray(stringToHexBytes(value));
  } // Convert the SlowBuffer to a fast buffer by just copying bytes recursively here


  return fromBuffer(SlowBuffer.fromString(value, encoding));
}
/**
 * @param {integer[]|Uint8Array|array} value values to wrap
 * @returns {Buffer}
 */


function fromArray(value) {
  const length = value.length;

  if (length === 0) {
    return new FastBuffer();
  }

  return new FastBuffer(value);
}
/**
 * Ideally this should only be used when we're copying a SlowBuffer into a new FastBuffer
 * @param {Buffer} value buffer to copy
 * @returns {Buffer}
 */


function fromBuffer(value) {
  const length = value.length;

  if (length === 0) {
    return new FastBuffer();
  }

  const buffer = Buffer$1.allocUnsafe(length);
  value.copy(buffer, 0, 0, length);
  return buffer;
}

Object.setPrototypeOf(Buffer$1, Uint8Array); // What is this doing?! Making Buffer.prototype point at Uint8Array now

/**
 * 0 is returned if target is the same as buf
 * 1 is returned if target should come before buf when sorted.
 * -1 is returned if target should come after buf when sorted.
 * @param {Buffer} target Buffer to compare against
 * @param {integer} [targetStart=0] index to start in target
 * @param {integer} [targetEnd=target.length] index to end in target
 * @param {integer} [sourceStart=0] index to start in this Buffer
 * @param {integer} [sourceEnd=this.length] index to end in this Buffer
 * @returns {integer}
 */

Buffer$1.prototype.compare = function (target, targetStart, targetEnd, sourceStart, sourceEnd) {
  if (!Buffer$1.isBuffer(target)) {
    throw new TypeError(`The "target" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  }

  if (targetStart === undefined) {
    targetStart = 0;
  }

  if (sourceStart === undefined) {
    sourceStart = 0;
  }

  if (targetEnd === undefined) {
    targetEnd = target.length;
  }

  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  } // ERR_OUT_OF_RANGE is thrown if targetStart < 0, sourceStart < 0, targetEnd > target.byteLength, or sourceEnd > source.byteLength


  if (targetStart < 0 || sourceStart < 0 || targetEnd > target.length || sourceEnd > this.length) {
    throw new RangeError('Index out of range'); // FIXME: set "code" to ERR_INDEX_OUT_OF_RANGE
  } // Use slices to make the loop easier


  const source = this.slice(sourceStart, sourceEnd);
  const sourceLength = source.length;
  const dest = target.slice(targetStart, targetEnd);
  const destLength = dest.length;
  const length = Math.min(sourceLength, destLength);

  for (let i = 0; i < length; i++) {
    const targetValue = dest.getAdjustedIndex(i);
    const sourceValue = source.getAdjustedIndex(i);

    if (targetValue !== sourceValue) {
      // No match! Return 1 or -1 based on what is greater!
      if (sourceValue < targetValue) {
        return -1;
      }

      return 1;
    }
  } // sort based on length!


  if (sourceLength < destLength) {
    return -1;
  }

  if (sourceLength > destLength) {
    return 1;
  }

  return 0;
};
/**
 * Copies from this to target
 * @param {Buffer} target destination we're copying into
 * @param {integer} [targetStart=0] start index to copy into in destination Buffer
 * @param {integer} [sourceStart=0] start index to copy from within `this`
 * @param {integer} [sourceEnd=this.length] end index to copy from within `this`
 * @returns {integer} number of bytes copied
 */


Buffer$1.prototype.copy = function (target, targetStart, sourceStart, sourceEnd) {
  if (targetStart === undefined) {
    targetStart = 0;
  }

  if (sourceStart === undefined) {
    sourceStart = 0;
  }

  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  }

  if (sourceStart === sourceEnd) {
    return 0;
  }

  if (target.length === 0 || this.length === 0) {
    return 0;
  } // TODO: check for out of bounds?


  let length = sourceEnd - sourceStart; // Cap length to remaining bytes in target!

  const remaining = target.length - targetStart;

  if (length > remaining) {
    sourceEnd = sourceStart + remaining;
    length = remaining;
  } // Determine actual number of bytes we'll copy, constrain by source buffer length as well as target (above)


  let numBytes = length;
  const sourceLen = this.length - sourceStart;

  if (numBytes > sourceLen) {
    numBytes = sourceLen;
  } // TODO: handle overlap when target === this!
  // TODO: Do we need to take target byteOffset into account here?


  let source = this;

  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(this.buffer, this.byteOffset + sourceStart, numBytes);
  }

  target.set(source, targetStart);
  return numBytes;
};
/**
 * Creates and returns an iterator of [index, byte] pairs from the contents of buf.
 * @returns {Iterator}
 */
// TODO: Is this only necessary for SlowBuffer?


Buffer$1.prototype.entries = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const entryIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: [nextIndex, buffer.getAdjustedIndex(nextIndex)],
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return entryIterator;
};

Buffer$1.prototype.equals = function (otherBuffer) {
  if (!Buffer$1.isBuffer(otherBuffer)) {
    throw new TypeError('argument must be a Buffer');
  }

  if (otherBuffer === this) {
    return true;
  }

  return this.compare(otherBuffer) === 0;
};
/**
 * @param {string|Buffer|UInt8Array|integer} value The value with which to fill `buf`.
 * @param {integer} [offset=0] Number of bytes to skip before starting to fill `buf`
 * @param {integer} [end] Where to stop filling buf (not inclusive). `buf.length` by default
 * @param {string} [encoding='utf8'] The encoding for `value` if `value` is a string.
 * @returns {this}
 */


Buffer$1.prototype.fill = function (value, offset, end, encoding) {
  const offsetType = typeof offset;

  if (offsetType === 'undefined') {
    // value supplied
    offset = 0;
    end = this.length;
    encoding = 'utf8';
  } else if (offsetType === 'string') {
    // value, encoding supplied
    encoding = offset;
    offset = 0;
    end = this.length;
  } else if (typeof end === 'string') {
    // value, offset, encoding supplied
    encoding = end;
    end = this.length;
  }

  this._fill(value, offset, end, encoding);

  return this;
};

const TypedArrayPrototype = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_byteLength = Object.getOwnPropertyDescriptor(TypedArrayPrototype, 'byteLength').get;
const TypedArrayFill = TypedArrayPrototype.fill;

Buffer$1.prototype._fill = function (value, offset, end, encoding) {
  if (typeof value === 'number') {
    // OOB check
    const byteLen = TypedArrayProto_byteLength.call(this);
    const fillLength = end - offset;

    if (offset > end || fillLength + offset > byteLen) {
      throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }

    TypedArrayFill.call(this, value, offset, end);
  } else {
    const bufToFillWith = SlowBuffer.fromString(value, encoding);
    const fillBufLength = bufToFillWith.length;

    if (fillBufLength === 0) {
      throw new Error('no valid fill data');
    }

    if (fillBufLength === 1) {
      TypedArrayFill.call(this, bufToFillWith._tiBuffer[0], offset, end);
      return this;
    } // multiple byte fill!


    const length = end - offset;

    for (let i = 0; i < length; i++) {
      // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
      const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
      this.setAdjustedIndex(i + offset, fillChar);
    }
  }
};

Buffer$1.prototype.includes = function (value, byteOffset, encoding) {
  return this.indexOf(value, byteOffset, encoding) !== -1;
};
/**
 * @param {string|Buffer|integer} value What to search for
 * @param {integer} [byteOffset=0] Where to begin searching in buf. If negative, then offset is calculated from the end of buf
 * @param {string} [encoding='utf8'] If value is a string, this is the encoding used to determine the binary representation of the string that will be searched for in buf
 * @returns {integer} The index of the first occurrence of value in buf, or -1 if buf does not contain value.
 */


Buffer$1.prototype.indexOf = function (value, byteOffset, encoding) {
  if (this.length === 0) {
    // empty buffer? can't find anything!
    return -1;
  } // if byteOffset is undefined, make it 0


  if (typeof byteOffset === 'undefined') {
    byteOffset = 0;
  } else if (typeof byteOffset === 'string') {
    // if it's a string, that's actually encoding
    encoding = byteOffset;
    byteOffset = 0;
  } // if we don't have an encoding yet, use utf8


  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  if (byteOffset < 0) {
    // convert negative indices
    byteOffset = this.length + byteOffset;

    if (byteOffset < 0) {
      // still negative? start at 0
      byteOffset = 0;
    }
  } else if (byteOffset >= this.length) {
    return -1; // can't find past end of buffer!
  }

  if (typeof value === 'number') {
    value &= 0xFF; // clamp to 255
    // This is a simpler case, we have a single byte we need to search for
    // so just loop through and try to find it

    return indexOf(this, value, byteOffset);
  } // coerce a string to a Buffer


  if (typeof value === 'string') {
    value = fromString(value, encoding);
  } // value is now a Buffer...


  const matchLength = value.length;

  if (matchLength === 0) {
    return -1; // never find empty value!
  }

  if (matchLength === 1) {
    // simple case, match one byte!
    return indexOf(this, value[0], byteOffset);
  }

  let currentIndex = byteOffset;
  const thisLength = this.length;

  if (matchLength > thisLength) {
    return -1; // can't match if the value is longer than this Buffer!
  } // FIXME: Can we rewrite this in a less funky way?
  // FIXME: Can stop earlier based on matchLength!


  firstMatch: while (currentIndex < thisLength) {
    // eslint-disable-line no-labels
    // match first byte!
    let firstByteMatch = indexOf(this, value[0], currentIndex);

    if (firstByteMatch === -1) {
      // couldn't even match the very first byte, so no match overall!
      return -1;
    } // ok, we found the first byte, now we need to see if the next consecutive bytes match!


    for (let x = 1; x < matchLength; x++) {
      if (firstByteMatch + x >= thisLength) {
        currentIndex = firstByteMatch + 1; // move past our first match

        continue firstMatch; // eslint-disable-line no-labels
      }

      if (this[firstByteMatch + x] !== value[x]) {
        // didn't match!
        currentIndex = firstByteMatch + 1; // move past our first match

        continue firstMatch; // eslint-disable-line no-labels
      }
    }

    return firstByteMatch; // the rest matched, hurray!
  }

  return -1;
};

Buffer$1.prototype.keys = function () {
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: nextIndex,
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return myIterator;
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
 * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
 */


Buffer$1.prototype.readDoubleBE = function (offset = 0) {
  checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder

  uint8DoubleArray[7] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[0] = this[offset++];
  return doubleArray[0];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
 * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
 */


Buffer$1.prototype.readDoubleLE = function (offset = 0) {
  checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder

  uint8DoubleArray[0] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[7] = this[offset++];
  return doubleArray[0];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
 */


Buffer$1.prototype.readFloatBE = function (offset = 0) {
  checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder

  uint8FloatArray[3] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[0] = this[offset++];
  return floatArray[0];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
 */


Buffer$1.prototype.readFloatLE = function (offset = 0) {
  checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder

  uint8FloatArray[0] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[3] = this[offset++];
  return floatArray[0];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */


Buffer$1.prototype.readInt8 = function (offset = 0) {
  const unsignedValue = this.readUInt8(offset);
  return unsignedToSigned(unsignedValue, 1);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.readInt16BE = function (offset) {
  const unsignedValue = this.readUInt16BE(offset);
  return unsignedToSigned(unsignedValue, 2);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.readInt16LE = function (offset = 0) {
  const unsignedValue = this.readUInt16LE(offset);
  return unsignedToSigned(unsignedValue, 2);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.readInt32BE = function (offset = 0) {
  const unsignedValue = this.readUInt32BE(offset);
  return unsignedToSigned(unsignedValue, 4);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.readInt32LE = function (offset = 0) {
  const unsignedValue = this.readUInt32LE(offset);
  return unsignedToSigned(unsignedValue, 4);
};
/**
 * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.readIntBE = function (offset, byteLength) {
  const unsignedValue = this.readUIntBE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};
/**
 * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.readIntLE = function (offset, byteLength) {
  const unsignedValue = this.readUIntLE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt8 = function (offset = 0) {
  checkOffset(this, offset, 1);
  return this[offset];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt16BE = function (offset = 0) {
  checkOffset(this, offset, 2); // first byte shifted and OR'd with second byte

  return this[offset] << 8 | this[offset + 1];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt16LE = function (offset = 0) {
  checkOffset(this, offset, 2); // first byte OR'd with second byte shifted

  return this[offset] | this[offset + 1] << 8;
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt32BE = function (offset = 0) {
  checkOffset(this, offset, 4);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]); // rather than shifting by << 24, multiply the first byte and add it in so we don't retain the "sign bit"
  // (because bit-wise operators assume a 32-bit number)
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt32LE = function (offset = 0) {
  checkOffset(this, offset, 4);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000; // rather than shifting by << 24, multiply the last byte and add it in so we don't retain the "sign bit"
};
/**
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.readUIntBE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte
  // we're doing the same loop as #readUIntLE, just backwards!

  for (let i = byteLength - 1; i >= 0; i--) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};
/**
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.readUIntLE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte

  for (let i = 0; i < byteLength; i++) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};
/**
 * @param {integer} [start=0] Where the new `Buffer` will start.
 * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
 * @returns {Buffer}
 */


Buffer$1.prototype.slice = function (start, end) {
  const thisLength = this.length;

  if (typeof start === 'undefined') {
    start = 0;
  } else if (start < 0) {
    start = thisLength + start;

    if (start < 0) {
      // if this is still negative, use 0 (that matches Node)
      start = 0;
    }
  }

  if (typeof end === 'undefined') {
    end = thisLength;
  } else if (end < 0) {
    end = thisLength + end;
  } // Specifying end greater than buf.length will return the same result as that of end equal to buf.length.


  if (end > thisLength) {
    end = thisLength;
  } // What if end is less than start?


  let length = end - start;

  if (length <= 0) {
    length = 0; // return empty view of Buffer! retain byte offset, set length to 0
  } // Wrap the same ArrayBuffer object but specify the start/end to "crop" with


  return this._slice(this.byteOffset + start, length);
};

Buffer$1.prototype._slice = function (offset, length) {
  return new FastBuffer(this.buffer, offset, length);
};
/**
 * @param {integer} [start=0] Where the new `Buffer` will start.
 * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
 * @returns {Buffer}
 */


Buffer$1.prototype.subarray = function (start, end) {
  return this.slice(start, end);
};
/**
 * Interprets buf as an array of unsigned 16-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 2.
 * @returns {Buffer}
 */


Buffer$1.prototype.swap16 = function () {
  const length = this.length;

  if (length % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (let i = 0; i < length; i += 2) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    this.setAdjustedIndex(i, second);
    this.setAdjustedIndex(i + 1, first);
  }

  return this;
};
/**
 * Interprets buf as an array of unsigned 32-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 4.
 * @returns {Buffer}
 */


Buffer$1.prototype.swap32 = function () {
  const length = this.length;

  if (length % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (let i = 0; i < length; i += 4) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    this.setAdjustedIndex(i, fourth);
    this.setAdjustedIndex(i + 1, third);
    this.setAdjustedIndex(i + 2, second);
    this.setAdjustedIndex(i + 3, first);
  }

  return this;
};
/**
 * Interprets buf as an array of unsigned 64-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 8.
 * @returns {Buffer}
 */


Buffer$1.prototype.swap64 = function () {
  const length = this.length;

  if (length % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (let i = 0; i < length; i += 8) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    const fifth = this.getAdjustedIndex(i + 4);
    const sixth = this.getAdjustedIndex(i + 5);
    const seventh = this.getAdjustedIndex(i + 6);
    const eighth = this.getAdjustedIndex(i + 7);
    this.setAdjustedIndex(i, eighth);
    this.setAdjustedIndex(i + 1, seventh);
    this.setAdjustedIndex(i + 2, sixth);
    this.setAdjustedIndex(i + 3, fifth);
    this.setAdjustedIndex(i + 4, fourth);
    this.setAdjustedIndex(i + 5, third);
    this.setAdjustedIndex(i + 6, second);
    this.setAdjustedIndex(i + 7, first);
  }

  return this;
};
/**
 * @returns {object}
 */


Buffer$1.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    // Take advantage of slice working on "Array-like" objects (just like `arguments`)
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
    data: [].slice.call(this) };

};
/**
 * @param {string} [encoding='utf8'] The character encoding to use
 * @param {integer} [start=0] The byte offset to start decoding at
 * @param {integer} [end] The byte offset to stop decoding at (not inclusive). `buf.length` default
 * @returns {string}
 */


Buffer$1.prototype.toString = function (encoding, start, end) {
  // fast case of no args
  if (arguments.length === 0) {
    return this.toTiBuffer().toString();
  }

  const length = this.length;

  if (start >= length) {
    return ''; // start is past end of buffer, return empty string
  }

  if (start < 0 || typeof start !== 'number') {
    start = 0;
  }

  if (end > length || typeof end !== 'number') {
    // no end specified, or past end of buffer, use length of buffer
    end = length;
  } // else keep end as passed in


  if (end <= start) {
    return ''; // if end is before start return empty string
  } // If start !== 0 and end !== length, maybe we should do a Buffer.subarray/slice over the range and call toString() on that?


  if (start !== 0 || end !== length) {
    return this.slice(start, end).toString(encoding);
  } // base case, start is 0, end is length


  if (encoding === undefined) {
    encoding = 'utf8';
  } else {
    encoding = encoding.toLowerCase(); // Throw if bad encoding!

    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }
  }

  if (encoding === 'utf8' || encoding === 'utf-8') {
    return this.toTiBuffer().toString(); // we return utf-8 by default natively
  }

  if (encoding === 'base64') {
    return Ti.Utils.base64encode(this.toTiBuffer().toBlob()).toString();
  }

  if (encoding === 'hex') {
    return this.hexSlice(0, length);
  }

  if (encoding === 'latin1' || encoding === 'binary') {
    let latin1String = '';

    for (let i = 0; i < length; i++) {
      // each one is a "byte"
      latin1String += String.fromCharCode(this.getAdjustedIndex(i));
    }

    return latin1String;
  }

  if (encoding === 'ascii') {
    let ascii = '';

    for (let i = 0; i < length; i++) {
      // we store bytes (8-bit), but ascii is 7-bit. Node "masks" the last bit off, so let's do the same
      ascii += String.fromCharCode(this.getAdjustedIndex(i) & 0x7F);
    }

    return ascii;
  } // UCS2/UTF16


  return this.ucs2Slice(0, length);
};

Buffer$1.prototype.getAdjustedIndex = function (index) {
  return this[index];
};

Buffer$1.prototype.setAdjustedIndex = function (index, value) {
  return this[index] = value;
};

Buffer$1.prototype.hexSlice = function (start, end) {
  let hexStr = '';

  for (let i = start; i < end; i++) {
    // each one is a "byte"
    let hex = (this.getAdjustedIndex(i) & 0xff).toString(16);
    hex = hex.length === 1 ? '0' + hex : hex;
    hexStr += hex;
  }

  return hexStr;
};

Buffer$1.prototype.ucs2Slice = function (start, end) {
  let out = '';
  let i = start;

  while (i < end) {
    // utf-16/ucs-2 is 2-bytes per character
    const byte1 = this.getAdjustedIndex(i++);
    const byte2 = this.getAdjustedIndex(i++);
    const code_unit = (byte2 << 8) + byte1; // we mash together the two bytes

    out += String.fromCodePoint(code_unit);
  }

  return out;
};
/**
 * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
 * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
 */


Buffer$1.prototype.toTiBuffer = function () {
  const tiBuffer = Ti.createBuffer({
    length: this.length });

  copyBuffer(this, tiBuffer, 0, this.length);
  return tiBuffer;
};
/**
 * @param {Buffer} src source Buffer we're copying from
 * @param {Ti.Buffer} dest destination Ti.Buffer we're copying into
 * @param {integer} offset start offset we're copying to in destination
 * @param {integer} length number of bytes to copy
 * @returns {integer} actual number of bytes copied
 */


function copyBuffer(src, dest, offset, length) {
  const srcLength = src.length;
  const destLength = dest.length;
  let i = 0;

  for (; i < length; i++) {
    const destIndex = i + offset; // are we trying to write past end of destination? Or read past end of source? Stop!

    if (destIndex >= destLength || i >= srcLength) {
      break;
    }

    dest[destIndex] = src[i];
  }

  return i;
}
/**
 * Creates and returns an iterator for buf values (bytes)
 * @returns {Iterator}
 */
// TODO: Move to SlowBuffer?


Buffer$1.prototype.values = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: buffer.getAdjustedIndex(nextIndex),
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return myIterator;
};
/**
 * Called when buffer is used in a for..of loop. Delegates to #values()
 * @returns {Iterator}
 */
// TODO: Move to SlowBuffer?


Buffer$1.prototype[Symbol.iterator] = function () {
  return this.values();
};
/**
 * Writes string to buf at offset according to the character encoding in encoding.
 * The length parameter is the number of bytes to write. If buf did not contain enough space to
 * fit the entire string, only part of string will be written. However, partially encoded
 * characters will not be written.
 * @param {string} string String to write to `buf`.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write string
 * @param {integer} [length=buf.length - offset] Number of bytes to write
 * @param {string} [encoding='utf8'] The character encoding of string
 * @returns {integer}
 */


Buffer$1.prototype.write = function (string, offset, length, encoding) {
  if (typeof offset === 'string') {
    encoding = offset;
    offset = 0;
    length = this.length;
  } else if (typeof length === 'string') {
    encoding = length;
    length = this.length - offset;
  } else {
    // we cap `length` at the length of our buffer
    const remaining = this.length - offset;

    if (length > remaining) {
      length = remaining;
    }
  }

  encoding = encoding || 'utf8'; // so we need to convert `remaining` bytes of our string into a byte array/buffer

  const src = fromString(string, encoding); // FIXME: Can we let it know to only convert `remaining` bytes?
  // then stick that into our buffer starting at `offset`!

  return src.copy(this, offset, 0, length);
};

Buffer$1.prototype.writeDoubleBE = function (value, offset = 0) {
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeDoubleLE = function (value, offset = 0) {
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeFloatBE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  return offset; // at this point, we should have already added 4 to offset
};

Buffer$1.prototype.writeFloatLE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  return offset; // at this point, we should have already added 4 to offset
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt8 = function (value, offset = 0) {
  checkOffset(this, offset, 1);
  checkValue(value, -128, 127);

  if (value >= 0) {
    // just write it normally
    this.setAdjustedIndex(offset, value);
  } else {
    // convert from signed to 2's complement bits
    this.setAdjustedIndex(offset, 0xFF + value + 1); // max value, plus the negative number, add one
  }

  return offset + 1;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt16BE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value >>> 8); // just shift over a byte

  this.setAdjustedIndex(offset + 1, value & 0xFF); // mask to first byte

  return offset + 2;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt16LE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt32BE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xFF);
  return offset + 4;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt32LE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.writeIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);

  if (value < 0) {
    value = minMaxBase * 2 + value;
  }

  let multiplier = 1;

  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0x100;
  }

  return offset + byteLength;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.writeIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);

  if (value < 0) {
    value = minMaxBase * 2 + value;
  }

  let multiplier = 1;

  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt8 = function (value, offset = 0) {
  checkOffset(this, offset, 1);
  checkValue(value, 0, 255);
  this.setAdjustedIndex(offset, value);
  return offset + 1;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt16BE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value >>> 8);
  this.setAdjustedIndex(offset + 1, value & 0xff);
  return offset + 2;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt16LE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt32BE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xff);
  return offset + 4;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt32LE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.writeUIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;

  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.writeUIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;

  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
}; // TODO: Implement remaining instance methods:
// buf.lastIndexOf(value[, byteOffset][, encoding])
// buf.readBigInt64BE([offset])
// buf.readBigInt64LE([offset])
// buf.readBigUInt64BE([offset])
// buf.readBigUInt64LE([offset])
// buf.writeBigInt64BE(value[, offset])
// buf.writeBigInt64LE(value[, offset])
// buf.writeBigUInt64BE(value[, offset])
// buf.writeBigUInt64LE(value[, offset])
// FIXME: We need to minimize using a backing Ti.Buffer whenever possible, because
// going back and forth across the bridge for every byte is *very* expensive
// Ideally we should have a "SlowBuffer" that is used when we explicitly wrap a Ti.Buffer
// So that writes are passed through. Otherwise we should avoid using one at all costs
// i.e. when we do Buffer.concat and are only doing reads - why do we need a Ti.Buffer?
// Can we have Ti.Buffer really just wrap a Uint8Array and add it's own methods?


Buffer$1.allocUnsafe = function (length) {
  return new FastBuffer(length);
};

Buffer$1.allocUnsafeSlow = function (length) {
  return Buffer$1.allocUnsafe(length);
};

Buffer$1.alloc = function (length, fill = 0, encoding = 'utf8') {
  const buf = Buffer$1.allocUnsafe(length);

  if (fill !== 0) {
    buf.fill(fill, encoding);
  }

  return buf;
};
/**
 * @param {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} string original string
 * @param {string} [encoding='utf8'] encoding whose byte length we need to grab
 * @returns {integer}
 */


Buffer$1.byteLength = function (string, encoding = 'utf8') {
  if (typeof string !== 'string') {
    if (Buffer$1.isBuffer(string)) {
      return string.length; // return Buffer's length
    }

    return string.byteLength; // TypedArray, ArrayBuffer, SharedArrayBuffer, DataView
  }

  let length = string.length;

  switch (encoding.toLowerCase()) {
    case 'utf8':
    case 'utf-8':
      return utf8ByteLength(string);

    case 'latin1':
    case 'binary':
    case 'ascii':
      return length;

    case 'ucs-2':
    case 'ucs2':
    case 'utf16le':
    case 'utf16-le':
      return 2 * length;

    case 'hex':
      return length / 2;

    case 'base64':
      // Subtract up to two padding chars from end of string!
      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }

      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }

      return Math.floor(length * 3 / 4);
    // drop fractional value
  }

  return utf8ByteLength(string);
};

Buffer$1.compare = function (buf1, buf2) {
  if (!Buffer$1.isBuffer(buf1)) {
    throw new TypeError(`The "buf1" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  } // TODO: Wrap UInt8Array args in buffers?


  return buf1.compare(buf2);
};
/**
 * @param {Buffer[]|UInt8Array[]} list list of Buffers to concatenate
 * @param {integer} [totalLength] Total length of the Buffer instances in list when concatenated.
 * @returns {Buffer}
 */


Buffer$1.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new TypeError('list argument must be an Array');
  }

  if (list.length === 0) {
    return new FastBuffer(); // one empty Buffer!
  } // allocate one Buffer of `totalLength`? Cap at totalLength?


  if (totalLength === undefined) {
    totalLength = 0; // generate the total length from each buffer's length?

    for (let i = 0; i < list.length; i++) {
      totalLength += list[i].length;
    }
  }

  const result = Buffer$1.allocUnsafe(totalLength);
  let position = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(result, position);
    position += buf.length;

    if (position >= totalLength) {
      break;
    }
  }

  return result;
};
/**
 * @param {string} encoding possible encoding name
 * @returns {boolean}
 */


Buffer$1.isEncoding = function (encoding) {
  if (typeof encoding !== 'string') {
    return false;
  }

  return VALID_ENCODINGS.includes(encoding.toLowerCase());
};
/**
 * @param {*} obj possible Buffer instance
 * @returns {boolean}
 */


Buffer$1.isBuffer = function (obj) {
  return obj !== null && obj !== undefined && (obj instanceof Buffer$1 || obj[isBuffer] === true);
};

let INSPECT_MAX_BYTES = 50; // Override how buffers are presented by util.inspect().

Buffer$1.prototype[customInspectSymbol] = function (recurseTimes, ctx) {
  const max = INSPECT_MAX_BYTES;
  const actualMax = Math.min(max, this.length);
  const remaining = this.length - max;
  let str = this.slice(0, actualMax).toString('hex').replace(/(.{2})/g, '$1 ').trim();

  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  } // Inspect special properties as well, if possible.


  if (ctx) {
    let extras = false;
    const filter = ctx.showHidden ? ALL_PROPERTIES$1 : ONLY_ENUMERABLE$1;
    const obj = getOwnNonIndexProperties(this, filter).reduce((obj, key) => {
      extras = true;
      obj[key] = this[key];
      return obj;
    }, Object.create(null));

    if (extras) {
      if (this.length !== 0) {
        str += ', ';
      } // '[Object: null prototype] {'.length === 26
      // This is guarded with a test.


      str += inspect(obj, { ...ctx,
        breakLength: Infinity,
        compact: true }).
      slice(27, -2);
    }
  }

  return `<${this.constructor.name} ${str}>`;
};

Buffer$1.prototype.inspect = Buffer$1.prototype[customInspectSymbol]; // HACK: ArrayBuffer.isView returns true for Node Buffer, but false for us. Until we can extend Uint8Array, we need to hack this sniffing method

const ArrayBufferIsView = ArrayBuffer.isView;

ArrayBuffer.isView = function (thing) {
  return ArrayBufferIsView(thing) || thing instanceof Buffer$1;
};

Object.setPrototypeOf(SlowBuffer.prototype, Buffer$1.prototype);
Object.setPrototypeOf(SlowBuffer, Buffer$1);
var BufferModule = {
  Buffer: Buffer$1,
  // TODO: Implement transcode()!
  transcode: (_source, _fromEncoding, _toEncoding) => {},
  INSPECT_MAX_BYTES: 50,
  kMaxLength: 2147483647,
  kStringMaxLength: 1073741799,
  constants: {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 1073741799 } };


/**
 * Searches a Buffer for the index of a single byte.
 * @param {Buffer} buffer buffer to search
 * @param {integer} singleByte byte we're looking for
 * @param {integer} offset start offset we search at
 * @returns {integer}
 */

function indexOf(buffer, singleByte, offset) {
  const length = buffer.length;

  for (let i = offset; i < length; i++) {
    if (buffer.getAdjustedIndex(i) === singleByte) {
      return i;
    }
  }

  return -1;
}
/**
 * This function explicitly avoids bitwise operations because JS assumes 32-bit sequences for those.
 * It's possible we may be able to use them when byteLength < 4 if that's faster.
 *
 * @param {integer} unsignedValue value before converting back to signed
 * @param {integer} byteLength number of bytes
 * @returns {integer} the signed value that is represented by the unsigned value's bytes
 */


function unsignedToSigned(unsignedValue, byteLength) {
  const bitLength = byteLength * 8;
  const maxPositiveValue = Math.pow(2, bitLength - 1);

  if (unsignedValue < maxPositiveValue) {
    return unsignedValue;
  }

  const maxUnsignedValue = Math.pow(2, bitLength);
  unsignedValue -= maxUnsignedValue;
  return unsignedValue;
}
/**
 * @param {string} string utf-8 string
 * @returns {integer}
 */


function utf8ByteLength(string) {
  // Just convert to a Ti.Buffer and let it tell us the length
  const buf = Ti.createBuffer({
    value: string,
    type: Ti.Codec.CHARSET_UTF8 });

  const length = buf.length;
  buf.release(); // release the buffer since we just needed the length

  return length;
}
/**
 * Throws a RangeError if offset is out of bounds
 * @param {Buffer} buffer buffer we're operating on
 * @param {integer} offset user supplied offset
 * @param {integer} byteLength number of bytes needed in range
 * @throws {RangeError}
 */


function checkOffset(buffer, offset, byteLength) {
  const endOffset = buffer.length - byteLength;

  if (offset < 0 || offset > endOffset) {
    throw new RangeError(`The value of "offset" is out of range. It must be >= 0 and <= ${endOffset}. Received ${offset}`);
  }
}
/**
 * @param {integer} value user-supplied value
 * @param {integer} min minimum valid value
 * @param {integer} max maximum valid value
 * @throws {RangeError}
 */


function checkValue(value, min, max) {
  if (value < min || value > max) {
    throw new RangeError(`The value of "value" is out of range. It must be >= ${min} and <= ${max}. Received ${value}`);
  }
}

let bufferWarningAlreadyEmitted = false;
let nodeModulesCheckCounter = 0;
const bufferWarning = 'Buffer() is deprecated due to security and usability ' + 'issues. Please use the Buffer.alloc(), ' + 'Buffer.allocUnsafe(), or Buffer.from() methods instead.';

function showFlaggedDeprecation() {
  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 10000 || isInsideNodeModules()) {
    // We don't emit a warning, because we either:
    // - Already did so, or
    // - Already checked too many times whether a call is coming
    //   from node_modules and want to stop slowing down things, or
    // - The code is inside `node_modules`.
    return;
  }

  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');
  bufferWarningAlreadyEmitted = true;
}

// Copyright Node.js contributors. All rights reserved.
const {
  ALL_PROPERTIES,
  ONLY_ENUMERABLE } =
propertyFilter;
const BooleanPrototype = Boolean.prototype;
const DatePrototype = Date.prototype;
const ErrorPrototype = Error.prototype;
const NumberPrototype = Number.prototype;
const MapPrototype = Map.prototype;
const RegExpPrototype = RegExp.prototype;
const StringPrototype = String.prototype;
const SetPrototype = Set.prototype;
const SymbolPrototype = Symbol.prototype;
const isIos = ['ipad', 'iphone'].includes("android");
const {
  ERR_INVALID_ARG_TYPE } =
codes;
const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
let hexSlice = uncurryThis(BufferModule.Buffer.prototype.hexSlice);
const builtInObjects = new Set(Object.getOwnPropertyNames(global).filter(e => /^([A-Z][a-z]+)+$/.test(e)));
const inspectDefaultOptions = Object.seal({
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false });

const kObjectType = 0;
const kArrayType = 1;
const kArrayExtrasType = 2;
/* eslint-disable no-control-regex */

const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c]/g;
/* eslint-enable no-control-regex */

const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const kMinLineLength = 16; // Constants to map the iterator state.

const kWeak = 0;
const kIterator = 1;
const kMapEntries = 2; // Escaped special characters. Use empty strings to fill up unused entries.

/* eslint-disable quotes */

const meta = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000b', '\\f', '\\r', '\\u000e', '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d', '\\u001e', '\\u001f', '', '', '', '', '', '', '', "\\'", '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\'];
/* eslint-enable quotes */

function getUserOptions(ctx) {
  const obj = {
    stylize: ctx.stylize };


  for (const key of Object.keys(inspectDefaultOptions)) {
    obj[key] = ctx[key];
  }

  if (ctx.userOptions === undefined) {
    return obj;
  }

  return { ...obj,
    ...ctx.userOptions };

}
/**
 * Echos the value of any input. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {any} value The value to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @return {string} The string representation of `value`
 */


function inspect(value, opts) {
  // Default options
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters };


  if (arguments.length > 1) {
    // Legacy...
    if (arguments.length > 2) {
      if (arguments[2] !== undefined) {
        ctx.depth = arguments[2];
      }

      if (arguments.length > 3 && arguments[3] !== undefined) {
        ctx.colors = arguments[3];
      }
    } // Set user-specified options


    if (typeof opts === 'boolean') {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);

      for (const key of optKeys) {
        // TODO(BridgeAR): Find a solution what to do about stylize. Either make
        // this function public or add a new API with a similar or better
        // functionality.
        if (hasOwnProperty(inspectDefaultOptions, key) || key === 'stylize') {
          ctx[key] = opts[key];
        } else if (ctx.userOptions === undefined) {
          // This is required to pass through the actual user input.
          ctx.userOptions = opts;
        }
      }
    }
  }

  if (ctx.colors) {
    ctx.stylize = stylizeWithColor;
  }

  if (ctx.maxArrayLength === null) {
    ctx.maxArrayLength = Infinity;
  }

  return formatValue(ctx, value, 0);
}
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, 'defaultOptions', {
  get() {
    return inspectDefaultOptions;
  },

  set(options) {
    if (options === null || typeof options !== 'object') {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    Object.assign(inspectDefaultOptions, options);
  } });

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = Object.assign(Object.create(null), {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39] });
// Don't use 'blue' not visible on cmd.exe

inspect.styles = Object.assign(Object.create(null), {
  special: 'cyan',
  number: 'yellow',
  bigint: 'yellow',
  boolean: 'yellow',
  undefined: 'grey',
  null: 'bold',
  string: 'green',
  symbol: 'green',
  date: 'magenta',
  // "name": intentionally not styling
  regexp: 'red',
  module: 'underline' });


function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }

  if (quotes === -2) {
    return `\`${str}\``;
  }

  return `'${str}'`;
}

const escapeFn = str => meta[str.charCodeAt(0)]; // Escape control characters, single quotes and the backslash.
// This is similar to JSON stringify escaping.


function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39; // Check for double quotes. If not present, do not escape single quotes and
  // instead wrap the text in double quotes. If double quotes exist, check for
  // backticks. If they do not exist, use those as fallback instead of the
  // double quotes.
  // eslint-disable-next-line quotes

  if (str.includes("'")) {
    // This invalidates the charCode and therefore can not be matched for
    // anymore.
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes('`') && !str.includes('${')) {
      singleQuote = -2;
    }

    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  } // Some magic numbers that worked out fine while benchmarking with v8 6.0


  if (str.length < 5000 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }

  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }

  let result = '';
  let last = 0;
  const lastIndex = str.length;

  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);

    if (point === singleQuote || point === 92 || point < 32) {
      if (last === i) {
        result += meta[point];
      } else {
        result += `${str.slice(last, i)}${meta[point]}`;
      }

      last = i + 1;
    }
  }

  if (last !== lastIndex) {
    result += str.slice(last);
  }

  return addQuotes(result, singleQuote);
}

function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];

  if (style !== undefined) {
    const color = inspect.colors[style];
    return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
  }

  return str;
}

function stylizeNoColor(str) {
  return str;
} // Return a new empty array to push in the results of the default formatter.


function getEmptyFormatArray() {
  return [];
}

function getConstructorName(obj, _ctx) {
  let firstProto; // const tmp = obj;

  while (obj) {
    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');

    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
      return descriptor.value.name;
    }

    obj = Object.getPrototypeOf(obj);

    if (firstProto === undefined) {
      firstProto = obj;
    }
  }

  if (firstProto === null) {
    return null;
  }
  /*
   @todo this calls into native, can we replace this somehow?
  return `${internalGetConstructorName(tmp)} <${inspect(firstProto, {
  	...ctx,
  	customInspect: false
  })}>`;
  */


  return null;
}

function getPrefix(constructor, tag, fallback) {
  if (constructor === null) {
    if (tag !== '') {
      return `[${fallback}: null prototype] [${tag}] `;
    }

    return `[${fallback}: null prototype] `;
  }

  if (tag !== '' && constructor !== tag) {
    return `${constructor} [${tag}] `;
  }

  return `${constructor} `;
} // Look up the keys of the object.


function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);

  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);

    if (symbols.length !== 0) {
      keys.push(...symbols);
    }
  } else {
    // This might throw if `value` is a Module Namespace Object from an
    // unevaluated module, but we don't want to perform the actual type
    // check because it's expensive.
    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209
    // and modify this logic as needed.
    try {
      keys = Object.keys(value);
    } catch (err) {
      // @fixme how to du isModuleNamespaceObject?

      /*
      assert(isNativeError(err) && err.name === 'ReferenceError' &&
      			 isModuleNamespaceObject(value));
      */
      keys = Object.getOwnPropertyNames(value);
    }

    if (symbols.length !== 0) {
      keys.push(...symbols.filter(key => propertyIsEnumerable(value, key)));
    }
  }

  return keys;
}

function getCtxStyle(value, constructor, tag) {
  let fallback = '';

  if (constructor === null) {
    fallback = 'Object';
  }

  return getPrefix(constructor, tag, fallback);
}

function findTypedConstructor(value) {
  for (const [check, clazz] of [[isUint8Array, Uint8Array], [isUint8ClampedArray, Uint8ClampedArray], [isUint16Array, Uint16Array], [isUint32Array, Uint32Array], [isInt8Array, Int8Array], [isInt16Array, Int16Array], [isInt32Array, Int32Array], [isFloat32Array, Float32Array], [isFloat64Array, Float64Array]]) {
    if (check(value)) {
      return clazz;
    }
  }
}

let lazyNullPrototypeCache; // Creates a subclass and name
// the constructor as `${clazz} : null prototype`

function clazzWithNullPrototype(clazz, name) {
  if (lazyNullPrototypeCache === undefined) {
    lazyNullPrototypeCache = new Map();
  } else {
    const cachedClass = lazyNullPrototypeCache.get(clazz);

    if (cachedClass !== undefined) {
      return cachedClass;
    }
  }

  class NullPrototype extends clazz {
    get [Symbol.toStringTag]() {
      return '';
    }}



  Object.defineProperty(NullPrototype.prototype.constructor, 'name', {
    value: `[${name}: null prototype]` });

  lazyNullPrototypeCache.set(clazz, NullPrototype);
  return NullPrototype;
}

function noPrototypeIterator(ctx, value, recurseTimes) {
  let newVal;

  if (isSet(value)) {
    const clazz = clazzWithNullPrototype(Set, 'Set');
    newVal = new clazz(SetPrototype.values(value));
  } else if (isMap(value)) {
    const clazz = clazzWithNullPrototype(Map, 'Map');
    newVal = new clazz(MapPrototype.entries(value));
  } else if (Array.isArray(value)) {
    const clazz = clazzWithNullPrototype(Array, 'Array');
    newVal = new clazz(value.length);
  } else if (isTypedArray(value)) {
    const constructor = findTypedConstructor(value);
    const clazz = clazzWithNullPrototype(constructor, constructor.name);
    newVal = new clazz(value);
  }

  if (newVal !== undefined) {
    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));
    return formatRaw(ctx, newVal, recurseTimes);
  }
}

function formatValue(ctx, value, recurseTimes, typedArray) {
  // Primitive types cannot have properties.
  if (typeof value !== 'object' && typeof value !== 'function') {
    return formatPrimitive(ctx.stylize, value, ctx);
  }

  if (value === null) {
    return ctx.stylize('null', 'null');
  } // Memorize the context for custom inspection on proxies.


  const context = value;
  /*
  @fixme check for proxies
  // Always check for proxies to prevent side effects and to prevent triggering
  // any proxy handlers.
  const proxy = getProxyDetails(value);
  if (proxy !== undefined) {
  	if (ctx.showProxy) {
  		return formatProxy(ctx, proxy, recurseTimes);
  	}
  	value = proxy[0];
  }
  */
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it.

  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol];

    if (typeof maybeCustom === 'function' // Filter out the util module, its inspect function is special.
    && maybeCustom !== inspect // Also filter out any prototype objects using the circular check.
    && !(value.constructor && value.constructor.prototype === value)) {
      // This makes sure the recurseTimes are reported as before while using
      // a counter internally.
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const ret = maybeCustom.call(context, depth, getUserOptions(ctx)); // If the custom inspection method returned `this`, don't go into
      // infinite recursion.

      if (ret !== context) {
        if (typeof ret !== 'string') {
          return formatValue(ctx, ret, recurseTimes);
        }

        return ret.replace(/\n/g, `\n${' '.repeat(ctx.indentationLvl)}`);
      }
    }
  } // Using an array here is actually better for the average case than using
  // a Set. `seen` will only check for the depth and will never grow too large.


  if (ctx.seen.includes(value)) {
    let index = 1;

    if (ctx.circular === undefined) {
      ctx.circular = new Map([[value, index]]);
    } else {
      index = ctx.circular.get(value);

      if (index === undefined) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }

    return ctx.stylize(`[Circular *${index}]`, 'special');
  }

  return formatRaw(ctx, value, recurseTimes, typedArray);
}

function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  const constructor = getConstructorName(value);
  let tag = value[Symbol.toStringTag]; // Only list the tag in case it's non-enumerable / not an own property.
  // Otherwise we'd print this twice.

  if (typeof tag !== 'string' || tag !== '' && (ctx.showHidden ? hasOwnProperty : propertyIsEnumerable)(value, Symbol.toStringTag)) {
    tag = '';
  }

  let base = '';
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;
  let extrasType = kObjectType; // Iterators and the rest are split to reduce checks.

  if (value[Symbol.iterator]) {
    noIterator = false;

    if (Array.isArray(value)) {
      keys = getOwnNonIndexProperties(value, filter); // Only set the constructor for non ordinary ("Array [...]") arrays.

      const prefix = getPrefix(constructor, tag, 'Array');
      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];

      if (value.length === 0 && keys.length === 0) {
        return `${braces[0]}]`;
      }

      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Set');

      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }

      braces = [`${prefix}{`, '}'];
      formatter = formatSet;
    } else if (isMap(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Map');

      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }

      braces = [`${prefix}{`, '}'];
      formatter = formatMap;
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const prefix = constructor !== null ? getPrefix(constructor, tag) : getPrefix(constructor, tag, findTypedConstructor(value).name);
      braces = [`${prefix}[`, ']'];

      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }

      formatter = formatTypedArray;
      extrasType = kArrayExtrasType;
    } else if (isMapIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Map', tag);
      formatter = formatIterator;
    } else if (isSetIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Set', tag);
      formatter = formatIterator;
    } else {
      noIterator = true;
    }
  }

  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ['{', '}'];

    if (constructor === 'Object') {
      if (isArgumentsObject(value)) {
        braces[0] = '[Arguments] {';
      } else if (tag !== '') {
        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;
      }

      if (keys.length === 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === 'function') {
      base = getFunctionBase(value, constructor, tag);

      if (keys.length === 0) {
        return ctx.stylize(base, 'special');
      }
    } else if (isRegExp(value)) {
      // Make RegExps say that they are RegExps
      // eslint-disable-next-line security/detect-non-literal-regexp
      const regExp = constructor !== null ? value : new RegExp(value);
      base = RegExpPrototype.toString.call(regExp);
      const prefix = getPrefix(constructor, tag, 'RegExp');

      if (prefix !== 'RegExp ') {
        base = `${prefix}${base}`;
      }

      if (keys.length === 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base, 'regexp');
      }
    } else if (isDate(value)) {
      // Make dates with properties first say the date
      base = Number.isNaN(DatePrototype.getTime.call(value)) ? DatePrototype.toString.call(value) : DatePrototype.toISOString.call(value);
      const prefix = getPrefix(constructor, tag, 'Date');

      if (prefix !== 'Date ') {
        base = `${prefix}${base}`;
      }

      if (keys.length === 0) {
        return ctx.stylize(base, 'date');
      }
    } else if (isError(value)) {
      base = formatError(value, constructor, tag, ctx);

      if (keys.length === 0) {
        return base;
      } else if (isIos) {
        const nativeErrorProps = ['line', 'column', 'sourceURL'];

        if (keys.every(key => nativeErrorProps.includes(key))) {
          return base;
        }
      }
    } else if (isAnyArrayBuffer(value)) {
      // Fast path for ArrayBuffer and SharedArrayBuffer.
      // Can't do the same for DataView because it has a non-primitive
      // .buffer property that we need to recurse for.
      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' : 'SharedArrayBuffer';
      const prefix = getPrefix(constructor, tag, arrayType);

      if (typedArray === undefined) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0) {
        return `${prefix}{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }

      braces[0] = `${prefix}{`;
      keys.unshift('byteLength');
    } else if (isDataView(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`; // .buffer goes last, it's not a primitive like the others.

      keys.unshift('byteLength', 'byteOffset', 'buffer');
    } else if (isPromise(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;
      formatter = formatPromise;
    } else if (isWeakSet(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
      /*
       * @fixme how to do isModuleNamespaceObject?
      } else if (isModuleNamespaceObject(value)) {
      	braces[0] = `[${tag}] {`;
      	formatter = formatNamespaceObject;
      */
    } else if (isBoxedPrimitive(value)) {
      base = getBoxedBase(value, ctx, keys, constructor, tag);

      if (keys.length === 0) {
        return base;
      }
    } else {
      // The input prototype got manipulated. Special handle these. We have to
      // rebuild the information so we are able to display everything.
      if (constructor === null) {
        const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);

        if (specialIterator) {
          return specialIterator;
        }
      }

      if (isMapIterator(value)) {
        braces = getIteratorBraces('Map', tag);
        formatter = formatIterator;
      } else if (isSetIterator(value)) {
        braces = getIteratorBraces('Set', tag);
        formatter = formatIterator; // Handle other regular objects again.
      } else {
        if (keys.length === 0) {
          return `${getCtxStyle(value, constructor, tag)}{}`;
        }

        braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
      }
    }
  }

  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);

    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }

    return ctx.stylize(constructorName, 'special');
  }

  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;

  try {
    output = formatter(ctx, value, recurseTimes, keys, braces);

    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
  } catch (err) {
    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
  }

  if (ctx.circular !== undefined) {
    const index = ctx.circular.get(value);

    if (index !== undefined) {
      const reference = ctx.stylize(`<ref *${index}>`, 'special'); // Add reference always to the very beginning of the output.

      if (ctx.compact !== true) {
        base = base === '' ? reference : `${reference} ${base}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }

  ctx.seen.pop();

  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? undefined : ctx.sorted;

    if (extrasType === kObjectType) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }

  const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength; // If any indentationLvl exceeds this limit, limit further inspecting to the
  // minimum. Otherwise the recursive algorithm might continue inspecting the
  // object even though the maximum string size (~2 ** 28 on 32 bit systems and
  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at
  // exactly 2 ** 27 but a bit higher. This depends on the object shape.
  // This limit also makes sure that huge objects don't block the event loop
  // significantly.

  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }

  return res;
}

function getIteratorBraces(type, tag) {
  if (tag !== `${type} Iterator`) {
    if (tag !== '') {
      tag += '] [';
    }

    tag += `${type} Iterator`;
  }

  return [`[${tag}] {`, '}'];
}

function getBoxedBase(value, ctx, keys, constructor, tag) {
  let fn;
  let type;

  if (isNumberObject(value)) {
    fn = NumberPrototype;
    type = 'Number';
  } else if (isStringObject(value)) {
    fn = StringPrototype;
    type = 'String'; // For boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    // Make boxed primitive Strings look like such

    keys.splice(0, value.length);
  } else if (isBooleanObject(value)) {
    fn = BooleanPrototype;
    type = 'Boolean';
  } else {
    fn = SymbolPrototype;
    type = 'Symbol';
  }

  let base = `[${type}`;

  if (type !== constructor) {
    if (constructor === null) {
      base += ' (null prototype)';
    } else {
      base += ` (${constructor})`;
    }
  }

  base += `: ${formatPrimitive(stylizeNoColor, fn.valueOf(value), ctx)}]`;

  if (tag !== '' && tag !== constructor) {
    base += ` [${tag}]`;
  }

  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base;
  }

  return ctx.stylize(base, type.toLowerCase());
}

function getFunctionBase(value, constructor, tag) {
  let type = 'Function';

  if (isGeneratorFunction(value)) {
    type = `Generator${type}`;
  }

  if (isAsyncFunction(value)) {
    type = `Async${type}`;
  }

  let base = `[${type}`;

  if (constructor === null) {
    base += ' (null prototype)';
  }

  if (value.name === '') {
    base += ' (anonymous)';
  } else {
    base += `: ${value.name}`;
  }

  base += ']';

  if (constructor !== type && constructor !== null) {
    base += ` ${constructor}`;
  }

  if (tag !== '' && constructor !== tag) {
    base += ` [${tag}]`;
  }

  return base;
}

function formatError(err, constructor, tag, ctx) {
  let stack = err.stack || ErrorPrototype.toString.call(err); // try to normalize JavaScriptCore stack to match v8

  if (isIos) {
    const lines = stack.split('\n');
    stack = `${err.name}: ${err.message}`;

    if (lines.length > 0) {
      stack += lines.map(stackLine => {
        const atSymbolIndex = stackLine.indexOf('@');
        const source = stackLine.slice(atSymbolIndex + 1);
        const sourcePattern = /(.*):(\d+):(\d+)/;
        let symbolName = 'unknown';

        if (atSymbolIndex !== -1) {
          symbolName = stackLine.slice(0, atSymbolIndex);
        }

        const sourceMatch = source.match(sourcePattern);

        if (sourceMatch) {
          let filePath = sourceMatch[1];
          const lineNumber = sourceMatch[2];
          const column = sourceMatch[3];

          if (filePath.startsWith('file:')) {
            filePath = filePath.replace(`file://${Ti.Filesystem.resourcesDirectory}`, '');
          }

          return `\n    at ${symbolName} (${filePath}:${lineNumber}:${column})`;
        } else {
          return `\n    at ${symbolName} (${source})`;
        }
      }).join('');
    }
  } // A stack trace may contain arbitrary data. Only manipulate the output
  // for "regular errors" (errors that "look normal") for now.


  const name = err.name || 'Error';
  let len = name.length;

  if (constructor === null || name.endsWith('Error') && stack.startsWith(name) && (stack.length === len || stack[len] === ':' || stack[len] === '\n')) {
    let fallback = 'Error';

    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || '';
      len = fallback.length;
      fallback = fallback || 'Error';
    }

    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);

    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  } // Ignore the error message if it's contained in the stack.


  let pos = err.message && stack.indexOf(err.message) || -1;

  if (pos !== -1) {
    pos += err.message.length;
  } // Wrap the error in brackets in case it has no stack trace.


  let stackStart = stack.indexOf('\n    at', pos);

  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    // Highlight userland code and node modules.
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split('\n');

    for (const line of lines) {
      // This adds underscores to all node_modules to quickly identify them.
      let nodeModule;
      newStack += '\n';
      let pos = 0;

      while (nodeModule = nodeModulesRegExp.exec(line)) {
        // '/node_modules/'.length === 14
        newStack += line.slice(pos, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], 'module');
        pos = nodeModule.index + nodeModule[0].length;
      }

      newStack += pos === 0 ? line : line.slice(pos);
    }

    stack = newStack;
  } // The message and the stack have to be indented as well!


  if (ctx.indentationLvl !== 0) {
    const indentation = ' '.repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `\n${indentation}`);
  }

  return stack;
}

function formatPromise(ctx, _value, _recurseTimes) {
  // Node calls into native to get promise details which we can't do
  return [ctx.stylize('<unknown>', 'special')];
}

function formatProperty(ctx, value, recurseTimes, key, type) {
  let name, str;
  let extra = ' ';
  const desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key],
    enumerable: true };


  if (desc.value !== undefined) {
    const diff = type !== kObjectType || ctx.compact !== true ? 2 : 3;
    ctx.indentationLvl += diff;
    str = formatValue(ctx, desc.value, recurseTimes);

    if (diff === 3) {
      const len = ctx.colors ? removeColors(str).length : str.length;

      if (ctx.breakLength < len) {
        extra = `\n${' '.repeat(ctx.indentationLvl)}`;
      }
    }

    ctx.indentationLvl -= diff;
  } else if (desc.get !== undefined) {
    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';
    const s = ctx.stylize;
    const sp = 'special';

    if (ctx.getters && (ctx.getters === true || ctx.getters === 'get' && desc.set === undefined || ctx.getters === 'set' && desc.set !== undefined)) {
      try {
        const tmp = value[key];
        ctx.indentationLvl += 2;

        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;
        } else if (typeof tmp === 'object') {
          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;
        }

        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== undefined) {
    str = ctx.stylize('[Setter]', 'special');
  } else {
    str = ctx.stylize('undefined', 'undefined');
  }

  if (type === kArrayType) {
    return str;
  }

  if (typeof key === 'symbol') {
    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp, 'symbol')}]`;
  } else if (desc.enumerable === false) {
    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;
  } else if (keyStrRegExp.test(key)) {
    name = ctx.stylize(key, 'name');
  } else {
    name = ctx.stylize(strEscape(key), 'string');
  }

  return `${name}:${extra}${str}`;
}

function groupArrayElements(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;

  if (ctx.maxArrayLength < output.length) {
    // This makes sure the "... n more items" part is not taken into account.
    outputLength--;
  }

  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.

  const dataLen = new Array(outputLength); // Calculate the total length of all output entries and the individual max
  // entries length of all output entries. We have to remove colors first,
  // otherwise the length would not be calculated properly.

  for (; i < outputLength; i++) {
    const len = ctx.colors ? removeColors(output[i]).length : output[i].length;
    dataLen[i] = len;
    totalLength += len + separatorSpace;

    if (maxLength < len) {
      maxLength = len;
    }
  } // Add two to `maxLength` as we add a single whitespace character plus a comma
  // in-between two entries.


  const actualMax = maxLength + separatorSpace; // Check if at least three entries fit next to each other and prevent grouping
  // of arrays that contains entries of very different length (i.e., if a single
  // entry is longer than 1/5 of all other entries combined). Otherwise the
  // space in-between small entries would be enormous.

  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1); // Dynamically check how many columns seem possible.

    const columns = Math.min( // Ideally a square should be drawn. We expect a character to be about 2.5
    // times as high as wide. This is the area formula to calculate a square
    // which contains n rectangles of size `actualMax * approxCharHeights`.
    // Divide that by `actualMax` to receive the correct number of columns.
    // The added bias increases the columns for short entries.
    Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), // Do not exceed the breakLength.
    Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), // Limit array grouping for small `compact` modes as the user requested
    // minimal grouping.
    ctx.compact * 4, // Limit the columns to a maximum of fifteen.
    15); // Return with the original output if no grouping should happen.

    if (columns <= 1) {
      return output;
    }

    const tmp = [];
    const maxLineLength = [];

    for (let i = 0; i < columns; i++) {
      let lineMaxLength = 0;

      for (let j = i; j < output.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }

      lineMaxLength += separatorSpace;
      maxLineLength[i] = lineMaxLength;
    }

    let order = 'padStart';

    if (value !== undefined) {
      for (let i = 0; i < output.length; i++) {
        if (typeof value[i] !== 'number') {
          order = 'padEnd';
          break;
        }
      }
    } // Each iteration creates a single line of grouped entries.


    for (let i = 0; i < outputLength; i += columns) {
      // The last lines may contain less entries than columns.
      const max = Math.min(i + columns, outputLength);
      let str = '';
      let j = i;

      for (; j < max - 1; j++) {
        // Calculate extra color padding in case it's active. This has to be
        // done line by line as some lines might contain more colors than
        // others.
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];
        str += `${output[j]}, `[order](padding, ' ');
      }

      if (order === 'padStart') {
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j] - separatorSpace;
        str += output[j].padStart(padding, ' ');
      } else {
        str += output[j];
      }

      tmp.push(str);
    }

    if (ctx.maxArrayLength < output.length) {
      tmp.push(output[outputLength]);
    }

    output = tmp;
  }

  return output;
}

function handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {
  if (isStackOverflowError(err)) {
    ctx.seen.pop();
    ctx.indentationLvl = indentationLvl;
    return ctx.stylize(`[${constructorName}: Inspection interrupted 'prematurely. Maximum call stack size exceeded.]`, 'special');
  }

  throw err;
}

function formatNumber(fn, value) {
  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.
  return fn(Object.is(value, -0) ? '-0' : `${value}`, 'number');
}

function formatBigInt(fn, value) {
  return fn(`${value}n`, 'bigint');
}

function formatPrimitive(fn, value, ctx) {
  if (typeof value === 'string') {
    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/\n/).map(line => fn(strEscape(line), 'string')).join(` +\n${' '.repeat(ctx.indentationLvl + 2)}`);
    }

    return fn(strEscape(value), 'string');
  }

  if (typeof value === 'number') {
    return formatNumber(fn, value);
  }
  /*
  if (typeof value === 'bigint') {
  	return formatBigInt(fn, value);
  }
  */


  if (typeof value === 'boolean') {
    return fn(`${value}`, 'boolean');
  }

  if (typeof value === 'undefined') {
    return fn('undefined', 'undefined');
  } // es6 symbol primitive


  return fn(SymbolPrototype.toString.call(value), 'symbol');
} // The array is sparse and/or has extra keys


function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;

  for (; i < keys.length && output.length < maxLength; i++) {
    const key = keys[i];
    const tmp = +key; // Arrays can only have up to 2^32 - 1 entries

    if (tmp > 2 ** 32 - 2) {
      break;
    }

    if (`${index}` !== key) {
      if (!numberRegExp.test(key)) {
        break;
      }

      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? 's' : '';
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
      index = tmp;

      if (output.length === maxLength) {
        break;
      }
    }

    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));
    index++;
  }

  const remaining = value.length - index;

  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? 's' : '';
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatArrayBuffer(ctx, value) {
  const buffer = new Uint8Array(value);
  /*
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  if (hexSlice === undefined) {
  	hexSlice = uncurryThis(require('../../buffer').default.Buffer.prototype.hexSlice);
  }
  */

  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, '$1 ').trim();
  const remaining = buffer.length - ctx.maxArrayLength;

  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  }

  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];
}

function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];

  for (var i = 0; i < len; i++) {
    // Special handle sparse arrays.
    if (!hasOwnProperty(value, i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }

    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
  }

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatTypedArray(ctx, value, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ? formatNumber : formatBigInt;

  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }

  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;
  }

  if (ctx.showHidden) {
    // .buffer goes last, it's not a primitive like the others.
    ctx.indentationLvl += 2;

    for (const key of ['BYTES_PER_ELEMENT', 'length', 'byteLength', 'byteOffset', 'buffer']) {
      const str = formatValue(ctx, value[key], recurseTimes, true);
      output.push(`[${key}]: ${str}`);
    }

    ctx.indentationLvl -= 2;
  }

  return output;
}

function formatSet(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;

  for (const v of value) {
    output.push(formatValue(ctx, v, recurseTimes));
  }

  ctx.indentationLvl -= 2; // With `showHidden`, `length` will display as a hidden property for
  // arrays. For consistency's sake, do the same for `size`, even though this
  // property isn't selected by Object.getOwnPropertyNames().

  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }

  return output;
}

function formatMap(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;

  for (const [k, v] of value) {
    output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
  }

  ctx.indentationLvl -= 2; // See comment in formatSet

  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }

  return output;
}

function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  let output = new Array(maxLength);
  ctx.indentationLvl += 2;

  for (var i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }

  ctx.indentationLvl -= 2;

  if (state === kWeak && !ctx.sorted) {
    // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.
    output = output.sort();
  }

  const remaining = entries.length - maxLength;

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0); // Entries exist as [key1, val1, key2, val2, ...]

  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;

  if (state === kWeak) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)}` + ` => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    } // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.


    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [formatValue(ctx, entries[pos], recurseTimes), formatValue(ctx, entries[pos + 1], recurseTimes)];
      output[i] = reduceToSingleString(ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);
    }
  }

  ctx.indentationLvl -= 2;

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatWeakCollection(ctx) {
  return [ctx.stylize('<items unknown>', 'special')];
}

function formatWeakSet(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}

function formatWeakMap(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}

function formatIterator(ctx, value, recurseTimes, _keys, braces) {
  const entries = [];
  let isKeyValue = false;
  let result = value.next();

  while (!result.done) {
    const currentEntry = result.value;
    entries.push(currentEntry);

    if (currentEntry[0] !== currentEntry[1]) {
      isKeyValue = true;
    }

    result = value.next();
  }

  if (isKeyValue) {
    // Mark entry iterators as such.
    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }

  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}

function isBelowBreakLength(ctx, output, start, base) {
  // Each entry is separated by at least a comma. Thus, we start with a total
  // length of at least `output.length`. In addition, some cases have a
  // whitespace in-between each other that is added to the total as well.
  let totalLength = output.length + start;

  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }

  for (var i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }

    if (totalLength > ctx.breakLength) {
      return false;
    }
  } // Do not line up properties on the same line if `base` contains line breaks.


  return base === '' || !base.includes('\n');
}

function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {
      // Memorize the original output length. In case the the output is grouped,
      // prevent lining up the entries on a single line.
      const entries = output.length; // Group array elements together if the array contains at least six
      // separate entries.

      if (extrasType === kArrayExtrasType && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      } // `ctx.currentDepth` is set to the most inner depth of the currently
      // inspected object part while `recurseTimes` is the actual current depth
      // that is inspected.
      //
      // Example:
      //
      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }
      //
      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max
      // depth of 1.
      //
      // Consolidate all entries of the local most inner depth up to
      // `ctx.compact`, as long as the properties are smaller than
      // `ctx.breakLength`.


      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        // Line up all entries on a single line in case the entries do not
        // exceed `breakLength`. Add 10 as constant to start next to all other
        // factors that may reduce `breakLength`.
        const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;

        if (isBelowBreakLength(ctx, output, start, base)) {
          return `${base ? `${base} ` : ''}${braces[0]} ${join$1(output, ', ')} ${braces[1]}`;
        }
      }
    } // Line up each entry on an individual line.


    const indentation = `\n${' '.repeat(ctx.indentationLvl)}`;
    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` + `${join$1(output, `,${indentation}  `)}${indentation}${braces[1]}`;
  } // Line up all entries on a single line in case the entries do not exceed
  // `breakLength`.


  if (isBelowBreakLength(ctx, output, 0, base)) {
    return `${braces[0]}${base ? ` ${base}` : ''} ${join$1(output, ', ')} ` + braces[1];
  }

  const indentation = ' '.repeat(ctx.indentationLvl); // If the opening "brace" is too large, like in the case of "Set {",
  // we need to force the first item to be on the next line or the
  // items will not line up correctly.

  const ln = base === '' && braces[0].length === 1 ? ' ' : `${base ? ` ${base}` : ''}\n${indentation}  `; // Line up each entry on an individual line.

  return `${braces[0]}${ln}${join$1(output, `,\n${indentation}  `)} ${braces[1]}`;
}

function format$1(...args) {
  return formatWithOptions(undefined, ...args);
}

const firstErrorLine = error => error.message.split('\n')[0];

let CIRCULAR_ERROR_MESSAGE;

function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (e) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(e);
      }
    }

    if (err.name === 'TypeError' && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }

    throw err;
  }
}
/* eslint-disable max-depth */


function formatWithOptions(inspectOptions, ...args) {
  const first = args[0];
  let a = 0;
  let str = '';
  let join = '';

  if (typeof first === 'string') {
    if (args.length === 1) {
      return first;
    }

    let tempStr;
    let lastPos = 0;

    for (var i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        // '%'
        const nextChar = first.charCodeAt(++i);

        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              // 's'
              const tempArg = args[++a];

              if (typeof tempArg === 'number') {
                tempStr = formatNumber(stylizeNoColor, tempArg);
                /*
                } else if (typeof tempArg === 'bigint') {
                	tempStr = `${tempArg}n`;
                */
              } else {
                let constr;

                if (typeof tempArg !== 'object' || tempArg === null || typeof tempArg.toString === 'function' && (hasOwnProperty(tempArg, 'toString') // A direct own property on the constructor prototype in
                // case the constructor is not an built-in object.
                || (constr = tempArg.constructor) && !builtInObjects.has(constr.name) && constr.prototype && hasOwnProperty(constr.prototype, 'toString'))) {
                  tempStr = String(tempArg);
                } else {
                  tempStr = inspect(tempArg, { ...inspectOptions,
                    compact: 3,
                    colors: false,
                    depth: 0 });

                }
              }

              break;

            case 106:
              // 'j'
              tempStr = tryStringify(args[++a]);
              break;

            case 100:
              // 'd'
              const tempNum = args[++a];
              /*
              if (typeof tempNum === 'bigint') {
              	tempStr = `${tempNum}n`;
              } else
              */

              if (typeof tempNum === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, Number(tempNum));
              }

              break;

            case 79:
              // 'O'
              tempStr = inspect(args[++a], inspectOptions);
              break;

            case 111:
              // 'o'
              {
                tempStr = inspect(args[++a], { ...inspectOptions,
                  showHidden: true,
                  showProxy: true,
                  depth: 4 });

                break;
              }

            case 105:
              // 'i'
              const tempInteger = args[++a];
              /*
              if (typeof tempInteger === 'bigint') {
              	tempStr = `${tempInteger}n`;
              } else */

              if (typeof tempInteger === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseInt(tempInteger));
              }

              break;

            case 102:
              // 'f'
              const tempFloat = args[++a];

              if (typeof tempFloat === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseFloat(tempFloat));
              }

              break;

            case 37:
              // '%'
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;

            default:
              // Any other character is not a correct placeholder
              continue;}


          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }

          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }

    if (lastPos !== 0) {
      a++;
      join = ' ';

      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }

  while (a < args.length) {
    const value = args[a];
    str += join;
    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;
    join = ' ';
    a++;
  }

  return str;
}
/* eslint-enable max-depth */

function noop$1() {}

function logTime(self, label, logData) {
  label = `${label}`;

  const startTime = self._times.get(label);

  if (!startTime) {
    process.emitWarning(`Label "${label}" does not exist`);
    return true;
  }

  const duration = Date.now() - startTime;

  if (logData) {
    self.log(`${label}: ${duration}ms`, ...logData);
  } else {
    self.log(`${label}: ${duration}ms`);
  }

  return false;
}

const kColorInspectOptions = {
  colors: true };

const kNoColorInspectOptions = {};
let tableWarned; // boolean flag for one-time warning about console.table not being implemented
// Make a function that can serve as the callback passed to `stream.write()`.

function createWriteErrorHandler(stream) {
  return err => {
    // This conditional evaluates to true if and only if there was an error
    // that was not already emitted (which happens when the _write callback
    // is invoked asynchronously).
    if (err !== null && !stream._writableState.errorEmitted) {
      // If there was an error, it will be emitted on `stream` as
      // an `error` event. Adding a `once` listener will keep that error
      // from becoming an uncaught exception, but since the handler is
      // removed after the event, non-console.* writes won't be affected.
      // we are only adding noop if there is no one else listening for 'error'
      if (stream.listenerCount('error') === 0) {
        stream.once('error', noop$1);
      }
    }
  };
}

class Console {
  constructor(options, stderr, ignoreErrors) {
    if (options && options.apiName === 'Ti.API') {
      // Passing in Ti.API module where we retain log levels
      this._apiModule = options;
    } else {
      // Node.JS streams
      if (!options || typeof options.write === 'function') {
        // no args, or first arg is a stream
        options = {
          stdout: options,
          stderr,
          ignoreErrors };

      }

      this._stdout = options.stdout; // TODO: enforce has write function?

      this._stderr = options.stderr || this._stdout;
      this._ignoreErrors = options.ignoreErrors !== false;

      if (this._ignoreErrors) {
        this._stdoutErrorHandler = createWriteErrorHandler(this._stdout);
        this._stderrErrorHandler = createWriteErrorHandler(this._stderr);
      }

      this._colorMode = options.colorMode || 'auto'; // TODO: enforce boolean or 'auto'

      this._inspectOptions = options.inspectOptions; // TODO: enforce undefined or typeof 'object'
    }

    this._times = new Map();
    this._counts = new Map();
    this._groupIndent = '';
  }

  _writeToConsole(level, string) {
    if (this._groupIndent.length !== 0) {
      if (string.includes('\n')) {
        string = string.replace(/\n/g, `\n${this._groupIndent}`);
      }

      string = this._groupIndent + string;
    } // Support wrapping Ti.API (which retains log level)


    if (this._apiModule) {
      this._apiModule[level](string);
    } else {
      // Support Node.JS streams like stdout/stderr which don't have log levels
      const useStdErr = level === 'warn' || level === 'error' || level === 'trace';
      const stream = useStdErr ? this._stderr : this._stdout;

      if (this._ignoreErrors === false) {
        return stream.write(string);
      } // There may be an error occurring synchronously (e.g. for files or TTYs
      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so
      // handle both situations.


      try {
        // Add and later remove a noop error handler to catch synchronous errors.
        if (stream.listenerCount('error') === 0) {
          stream.once('error', noop$1);
        }

        const errorHandler = useStdErr ? this._stderrErrorHandler : this._stdoutErrorHandler;
        stream.write(string, errorHandler);
      } catch (e) {
        // Console is a debugging utility, so it swallowing errors is not desirable
        // even in edge cases such as low stack space.
        if (isStackOverflowError(e)) {
          throw e;
        } // Sorry, there's no proper way to pass along the error here.

      } finally {
        stream.removeListener && stream.removeListener('error', noop$1);
      }
    }
  }

  info(...args) {
    this._writeToConsole('info', formatWithOptions(kColorInspectOptions, ...args));
  }

  warn(...args) {
    this._writeToConsole('warn', formatWithOptions(kNoColorInspectOptions, ...args));
  }

  error(...args) {
    this._writeToConsole('error', formatWithOptions(kNoColorInspectOptions, ...args));
  }

  debug(...args) {
    this._writeToConsole('debug', formatWithOptions(kColorInspectOptions, ...args));
  }

  trace(...args) {
    this._writeToConsole('trace', formatWithOptions(kColorInspectOptions, ...args));
  }

  clear() {} // no-op


  group(...data) {
    if (data.length > 0) {
      this.log(...data);
    }

    this._groupIndent += '  ';
  }

  groupEnd() {
    this._groupIndent = this._groupIndent.slice(0, this._groupIndent.length - 2);
  }

  dir(obj, options) {
    this._writeToConsole('info', inspect(obj, {
      customInspect: false,
      ...options }));

  }

  assert(value, ...args) {
    if (!value) {
      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;
      this.warn(...args); // The arguments will be formatted in warn() again
    }
  }

  count(label = 'default') {
    // Ensures that label is a string, and only things that can be
    // coerced to strings. e.g. Symbol is not allowed
    label = `${label}`;

    let count = this._counts.get(label);

    if (count === undefined) {
      count = 1;
    } else {
      count++;
    }

    this._counts.set(label, count);

    this.log(`${label}: ${count}`);
  }

  countReset(label = 'default') {
    if (!this._counts.has(label)) {
      process.emitWarning(`Count for '${label}' does not exist`);
      return;
    }

    this._counts.delete(`${label}`);
  }

  time(label = 'default') {
    label = `${label}`;

    if (this._times.has(label)) {
      process.emitWarning(`Label ${label}" already exists`);
      return;
    }

    this._times.set(label, Date.now());
  }

  timeEnd(label = 'default') {
    const warned = logTime(this, label);

    if (!warned) {
      this._times.delete(label);
    }
  }

  timeLog(label = 'default', ...logData) {
    logTime(this, label, logData);
  } // TODO: implement console.table()


  table() {
    if (!tableWarned) {
      tableWarned = true;
      process.emitWarning('"console.table" is not yet implemented in Titanium!');
    }
  }}



Console.prototype.log = Console.prototype.info; // Treat log as alias to info

Console.prototype.dirxml = Console.prototype.log; // Treat dirxml as alias to log

Console.prototype.groupCollapsed = Console.prototype.group;
const globalConsole = new Console(Ti.API);
globalConsole.Console = Console;
global.console = globalConsole;

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  Date.prototype.toLocaleDateString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);

    const oldOptions = properties.options;

    if (!oldOptions || !oldOptions.dateStyle && !oldOptions.month && !oldOptions.day && !oldOptions.year) {
      const defaultOptions = {
        month: 'numeric',
        day: 'numeric',
        year: 'numeric' };

      properties.options = Object.assign(defaultOptions, oldOptions);
    }

    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };

  Date.prototype.toLocaleTimeString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);

    const oldOptions = properties.options;

    if (!oldOptions || !oldOptions.timeStyle && !oldOptions.hour && !oldOptions.minute && !oldOptions.second) {
      const defaultOptions = {
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric' };

      properties.options = Object.assign(defaultOptions, oldOptions);
    }

    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };

  Date.prototype.toLocaleString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);

    const oldOptions = properties.options;
    let hasOption = false;

    if (oldOptions) {
      hasOption = !!oldOptions.dateStyle || !!oldOptions.timeStyle || !!oldOptions.weekday || !!oldOptions.month || !!oldOptions.day || !!oldOptions.year || !!oldOptions.hour || !!oldOptions.minute || !!oldOptions.second;
    }

    if (!hasOption) {
      const defaultOptions = {
        month: 'numeric',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric' };

      properties.options = Object.assign(defaultOptions, oldOptions);
    }

    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
// Add a toJSON() method to all Error objects needed to output non-enumerable properties.
// The JSON.stringify() will automatically call this method if it exists to provide custom output.
// Notes:
// - In V8, all Error properties are not enumerable. We need this or else stringify() will return "{}".
// - In JavaScriptCore, only the "stack" property is not enumerable. We want to reveal this.
if (typeof Error.prototype.toJSON !== 'function') {
  Error.prototype.toJSON = function () {
    var properties = {};
    Object.getOwnPropertyNames(this).forEach(function (name) {
      properties[name] = this[name];
    }, this);
    return properties;
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID */

/**
 * Generates a "creation" properties dictionary for Titanium's Collator, DateTimeFormat, and NumberFormat proxies
 * from the given Intl type's constructor arguments.
 * @param {Object[]} args
 * The arguments array that was passed into Intl Collator, DateTimeFormat, or NumberFormat type's constructor.
 * @param {Function} supportedFormatLocalesFunction Reference to a supportedLocalesOf() function.
 * @return {Object} Returns a properties dictionary to be passed into a Titanium proxy's constructor.
 */

function makeTiFormatCreationPropertiesFrom(args, supportedFormatLocalesFunction) {
  const properties = {};

  if (args.length >= 1) {
    if (typeof args[0] === 'string') {
      properties.locale = args[0];
    } else if (Array.isArray(args[0])) {
      const supportedLocales = supportedFormatLocalesFunction(args[0]);

      if (supportedLocales.length > 0) {
        properties.locale = supportedLocales[0];
      }
    }
  }

  if (args.length >= 2 && typeof args[1] === 'object') {
    properties.options = args[1];
  }

  return properties;
} // Add "Intl" APIs missing on Android.


{
  // Set up an "Intl.Collator" type which wraps our undocumented "Ti.Locale.Collator" proxy.
  function TiCollator() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedCollatorLocales);
    const collator = new Ti.Locale.Collator(properties);
    collator.compare = collator.compare.bind(collator);
    return collator;
  }

  TiCollator.supportedLocalesOf = Ti.Locale.getSupportedCollatorLocales; // Set up an "Intl.DateTimeFormat" type which wraps our undocumented "Ti.Locale.DateTimeFormat" proxy.

  function TiDateTimeFormat() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedDateTimeFormatLocales);
    return new Ti.Locale.DateTimeFormat(properties);
  }

  TiDateTimeFormat._makeTiCreationPropertiesFrom = args => {
    return makeTiFormatCreationPropertiesFrom(args, Ti.Locale.getSupportedDateTimeFormatLocales);
  };

  TiDateTimeFormat.supportedLocalesOf = Ti.Locale.getSupportedDateTimeFormatLocales; // Set up an "Intl.NumberFormat" type which wraps our undocumented "Ti.Locale.NumberFormat" proxy.

  function TiNumberFormat() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedNumberFormatLocales);
    return new Ti.Locale.NumberFormat(properties);
  }

  TiNumberFormat.supportedLocalesOf = Ti.Locale.getSupportedNumberFormatLocales; // Make our custom "Intl" module available globally.

  commonjsGlobal.Intl = {
    Collator: TiCollator,
    DateTimeFormat: TiDateTimeFormat,
    NumberFormat: TiNumberFormat,
    getCanonicalLocales: Ti.Locale.getCanonicalLocales };

}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  Number.prototype.toLocaleString = function () {
    const formatter = new Intl.NumberFormat(...arguments);
    return formatter.format(this.valueOf());
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  String.prototype.localeCompare = function (compareString, locales, options) {
    const collator = new Intl.Collator(locales, options);
    return collator.compare(this, compareString);
  };

  String.prototype.toLocaleLowerCase = function (locale) {
    return Ti.Locale.makeLowerCase(this, locale);
  };

  String.prototype.toLocaleUpperCase = function (locale) {
    return Ti.Locale.makeUpperCase(this, locale);
  };
}

/**
 * This file is used to hijack the standard require to allow for JS
 * implementations of "core" modules.
 *
 * You add a binding from the "core" module id to the under the hood JS
 * implementation. We then intercept require calls to handle requests for these modules
 * and lazily load the file.
 */

/**
 * Used by @function bindObjectToCoreModuleId
 * @type {map<string, object>}
 */
const bindings = new Map();
/**
 * Used by @function redirectCoreModuleIdToPath
 * @type {map<string, string>}
 */

const redirects = new Map();
/**
 * Does the request look like a typical core module? (no '.' or '/' characters)
 * @param {string} path original require path/id
 * @returns {boolean}
 */

function isHijackableModuleId(path) {
  if (!path || path.length < 1) {
    return false;
  }

  const firstChar = path.charAt(0);
  return firstChar !== '.' && firstChar !== '/';
} // Hack require to point to this as a core module "binding"


const originalRequire = global.require; // This works for Windows as-is, and also intercepts the call on Android/iOS for ti.main.js (the first file executed)

global.require = function (moduleId) {
  if (bindings.has(moduleId)) {
    return bindings.get(moduleId);
  }

  if (redirects.has(moduleId)) {
    moduleId = redirects.get(moduleId);
  }

  return originalRequire(moduleId);
}; // ... but we still need to hack it when requiring from other files for Android/iOS (due to module.js impl)


const originalModuleRequire = global.Module.prototype.require;

global.Module.prototype.require = function (path, context) {
  if (bindings.has(path)) {
    return bindings.get(path);
  }

  if (redirects.has(path)) {
    path = redirects.get(path);
  }

  return originalModuleRequire.call(this, path, context);
};
/**
 * Registers a binding from a short module id to an already loaded/constructed object/value to export for that core module id
 *
 * @param {string} moduleId the module id to "hijack"
 * @param {*} binding an already constructured value/object to return
 */


function register(moduleId, binding) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }

  if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    redirects.delete(moduleId);
  } else if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }

  bindings.set(moduleId, binding);
}
/**
 * Registers a binding from a short module id to the full under the hood filepath if given a string.
 * This allows for lazy instantiation of the module on-demand
 *
 * @param {string} moduleId the module id to "hijack"
 * @param {string} filepath the full filepath to require under the hood.
 *                              This should be an already resolved absolute path,
 *                              as otherwise the context of the call could change what gets loaded!
 */

function redirect(moduleId, filepath) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }

  if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    bindings.delete(moduleId);
  } else if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }

  redirects.set(moduleId, filepath);
} // FIXME: There's a collision here with global.binding declared in KrollBridge.m on iOS

if (!global.binding) {
  global.binding = {};
}

global.binding.register = register;
global.binding.redirect = redirect;

// Load all JavaScript extensions/polyfills
register('console', globalConsole);

/* globals OS_ANDROID */
{
  // Avoid circular references in JSON structure
  Object.defineProperty(Titanium.Activity.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'window' || k === 'intent' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

}

/* globals OS_ANDROID */
{
  const Properties = Titanium.App.Properties;

  function nullOrDefaultValue(defaultValue) {
    if (typeof defaultValue === 'undefined') {
      return null;
    }

    return defaultValue;
  }

  function propertyGetter(delegate) {
    return function (key, defaultValue) {
      if (!Properties.hasProperty(key)) {
        return nullOrDefaultValue(defaultValue);
      }

      return delegate.call(Properties, key);
    };
  }

  ['getBool', 'getDouble', 'getInt', 'getString'].forEach(function (getter) {
    Properties[getter] = propertyGetter(Properties[getter]);
  });

  Properties.getList = Properties.getObject = function (key, defaultValue) {
    if (!Properties.hasProperty(key)) {
      return nullOrDefaultValue(defaultValue);
    }

    return JSON.parse(Properties.getString(key));
  };

  Properties.setList = Properties.setObject = function (key, val) {
    Properties.setString(key, JSON.stringify(val));
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2019-Present by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID, OS_IOS, OS_VERSION_MAJOR */
const buffer = Ti.createBuffer({
  value: '' });

const blob = buffer.toBlob();
const BlobPrototype = Object.getPrototypeOf(blob);

{
  // This doesn't "stick" for iOS. It is implemented natively.
  // Web Blob has an arrayBuffer() method that returns a Promise
  // https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer
  Object.defineProperty(BlobPrototype, 'arrayBuffer', {
    value: function () {
      return new Promise((resolve, reject) => {
        let buf;

        try {
          buf = this.toArrayBuffer();
        } catch (err) {
          return reject(err);
        }

        resolve(buf);
      });
    },
    enumerable: true });

}

/* globals OS_ANDROID */

{
  const Locale = Titanium.Locale;
  const wrappedGetString = Locale.getString;

  Locale.getString = function (key, defaultValue) {
    const defaultValueType = typeof defaultValue; // If the hint/default is not a string, ignore it!

    if (defaultValueType !== 'string') {
      return wrappedGetString.call(Locale, key);
    }

    return wrappedGetString.call(Locale, key, defaultValue);
  };

  commonjsGlobal.L = Locale.getString;
}

// Keeps an object alive until dispose() is called.
// This is currently used to keep "top level" objects
// (ex: windows, tab groups) alive until their lifecycle ends.
function PersistentHandle(object) {
  this.cell = PersistentHandle.lastId++;
  PersistentHandle.objects[this.cell] = object;
} // Objects retained by persistent handles.
// Each element in this array acts as a storage "cell"
// keeping the object reachable and alive until it is removed.


PersistentHandle.objects = {};
PersistentHandle.lastId = 0;

PersistentHandle.prototype.dispose = function () {
  if (this.cell === -1) {
    // This handle has already been disposed.
    return;
  }

  delete PersistentHandle.objects[this.cell];
  this.cell = -1;
};

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2013-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

{
  const HTTPClient = Titanium.Network.HTTPClient;
  const _send = HTTPClient.prototype.send;

  HTTPClient.prototype.send = function (options) {
    // Retain the httpclient until the request has been finished.
    const handle = new PersistentHandle(this);
    this.on('disposehandle', function () {
      handle.dispose();

      if (kroll.DBG) {
        kroll.log('HTTPClient', 'The persistent handle is disposed.');
      }
    });

    _send.call(this, options);
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2012-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  function iPhoneConstant(name) {
    Titanium.API.error('!!!');
    Titanium.API.error('!!! WARNING : Use of unsupported constant Ti.UI.iPhone.' + name + ' !!!');
    Titanium.API.error('!!!');
    return 0;
  } // TODO: Remove me. Only for temporary compatibility


  Titanium.UI.iPhone = {
    ActivityIndicatorStyle: {
      get BIG() {
        return iPhoneConstant('ActivityIndicatorStyle.BIG');
      },

      get DARK() {
        return iPhoneConstant('ActivityIndicatorStyle.DARK');
      } },


    AnimationStyle: {
      get FLIP_FROM_LEFT() {
        return iPhoneConstant('AnimationStyle.FLIP_FROM_LEFT');
      } },


    ProgressBarStyle: {
      get SIMPLE() {
        return iPhoneConstant('ProgressBarStyle.SIMPLE');
      } },


    SystemButton: {
      get FLEXIBLE_SPACE() {
        return iPhoneConstant('SystemButton.FLEXIBLE_SPACE');
      },

      get DISCLOSURE() {
        return iPhoneConstant('SystemButton.DISCLOSURE');
      } },


    SystemButtonStyle: {
      get BAR() {
        return iPhoneConstant('SystemButtonStyle.BAR');
      } },


    TableViewCellSelectionStyle: {
      get NONE() {
        return iPhoneConstant('TableViewCellSelectionStyle.NONE');
      } },


    TableViewSeparatorStyle: {
      get NONE() {
        return iPhoneConstant('TableViewSeparatorStyle.NONE');
      } },


    RowAnimationStyle: {
      get NONE() {
        return iPhoneConstant('RowAnimationStyle.NONE');
      } },


    TableViewScrollPosition: {
      get MIDDLE() {
        return iPhoneConstant('TableViewScrollPosition.MIDDLE');
      } },


    TableViewStyle: {
      get GROUPED() {
        return iPhoneConstant('TableViewStyle.GROUPED');
      } } };



}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020-Present by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* global OS_ANDROID */

{
  const ListView = Titanium.UI.ListView;
  const defaultTemplate = {
    properties: {
      height: '45dp' },

    childTemplates: [{
      type: 'Ti.UI.Label',
      bindId: 'title',
      properties: {
        left: '6dp',
        width: '75%' } },

    {
      type: 'Ti.UI.ImageView',
      bindId: 'image',
      properties: {
        right: '25dp',
        width: '15%' } }] };




  function createListView(options) {
    if (!options) {
      options = {};
    }

    options.templates = {
      [Titanium.UI.LIST_ITEM_TEMPLATE_DEFAULT]: defaultTemplate,
      ...options.templates };

    const templates = options.templates;

    for (const binding in templates) {
      const currentTemplate = templates[binding];
      processTemplate(currentTemplate);
      processChildTemplates(currentTemplate);
    }

    return new ListView(options);
  } // Create ListItemProxy, add events, then store it in 'tiProxy' property


  function processTemplate(properties) {
    const cellProxy = Titanium.UI.createListItem();
    const events = properties.events;
    properties.tiProxy = cellProxy;
    addEventListeners(events, cellProxy);
  } // Recursive function that process childTemplates and append corresponding proxies to
  // property 'tiProxy'. I.e: type: "Titanium.UI.Label" -> tiProxy: LabelProxy object


  function processChildTemplates(properties) {
    if (!Object.prototype.hasOwnProperty.call(properties, 'childTemplates')) {
      return;
    }

    const childProperties = properties.childTemplates;

    if (!childProperties) {
      return;
    }

    for (let i = 0; i < childProperties.length; i++) {
      const child = childProperties[i];
      const proxyType = child.type;

      if (proxyType) {
        const creationProperties = child.properties;
        const creationFunction = lookup(proxyType); // Create proxy.

        let childProxy;

        if (creationProperties) {
          childProxy = creationFunction(creationProperties);
        } else {
          childProxy = creationFunction();
        } // Add event listeners.


        const events = child.events;
        addEventListeners(events, childProxy); // Append proxy to tiProxy property.

        child.tiProxy = childProxy;
      }

      processChildTemplates(child);
    }
  } // Add event listeners.


  function addEventListeners(events, proxy) {
    if (events !== undefined) {
      for (const eventName in events) {
        proxy.addEventListener(eventName, events[eventName]);
      }
    }
  }

  function lookupProxyConstructor(namespace) {
    const namespaceIndex = namespace.lastIndexOf('.');
    const proxyName = namespace.slice(namespaceIndex + 1);
    const parentNamespace = namespace.substring(0, namespaceIndex);
    const segments = parentNamespace.split('.');
    let parentProxy = commonjsGlobal;

    for (let i = 0; i < segments.length; i++) {
      parentProxy = parentProxy[segments[i]];
    }

    if (parentProxy) {
      const method = parentProxy[`create${proxyName}`];

      if (method) {
        return method;
      }
    }

    throw new Error(`Could not lookup constructor for namespace: "${namespace}"`);
  } // Convert name of UI elements into a constructor function.
  // i.e: lookup("Titanium.UI.Label") returns Titanium.UI.createLabel function.


  function lookup(namespace) {
    // Handle Titanium widgets.
    if (/^(Ti|Titanium)/.test(namespace)) {
      return lookupProxyConstructor(namespace); // Handle Alloy widgets.
    } else {
      let widget;

      try {
        // Attempt to load alloy widget.
        widget = commonjsGlobal.Module.main.require(`/alloy/widgets/${namespace}/controllers/widget`);
      } catch (e) {
        try {
          // Widget does not exist, attempt to load namespace.
          widget = commonjsGlobal.Module.main.require(namespace);
        } catch (err) {
          // Namespace does not exist, fall back to legacy behaviour.
          return lookupProxyConstructor(namespace);
        }
      }

      if (widget) {
        return function (parameters) {
          const obj = new widget(parameters);
          return obj.getView();
        };
      }
    }
  } // Overwrite list view constructor function with our own.


  Titanium.UI.createListView = createListView;
}

/* globals OS_ANDROID */
{
  // Avoid circular references in JSON structure
  Object.defineProperty(Titanium.UI.NavigationWindow.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'parent' || k === 'window' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

}

/**
 * This script is used at runtime for Ti.UI.fetchSemanticColor - as well as at build time by both iOS/Android.
 * It provides a common interface for handling colors and converting to necessary string forms.
 */

const HEX_3_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F3

const HEX_4_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F38

const HEX_6_REGEX = /^#?([a-f\d]){6}$/i; // i.e. #00FF33

const HEX_8_REGEX = /^#?([a-f\d]){8}$/i; // i.e. #00FF3388

/**
 * @param {number} integer in range of 0-255
 * @returns {string} 2-character hex string value
 */

function paddedHex(integer) {
  const str = integer.toString(16);

  if (str.length === 1) {
    return `0${str}`;
  }

  return str;
}

class Color {
  /**
   * @param {number} r red value in range 0-255
   * @param {number} g green value in range 0-255
   * @param {number} b blue value in range 0-255
   * @param {number} [a=1.0] alpha value in range 0.0-1.0
   */
  constructor(r, g, b, a = 1.0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.alpha = a;
  }
  /**
   * indicates if this is a fully opaque color (alpha is 1.0 or was undefined)
   * @returns {boolean}
   */


  isOpaque() {
    return this.alpha === 1.0;
  }
  /**
   * Converts the alpha value into equivalent hex string value properly.
   * @returns {string}
   */


  alphaHex() {
    // need to round to avoid nonsensical values like '7f.8' for a 0.5 alpha
    return paddedHex(Math.round(this.alpha * 255.0));
  }
  /**
   * Discards any alpha value. To be used internally, not external api. Does not provide leading '#' symbol.
   * @returns {string}
   */


  _toRGBHexString() {
    return `${paddedHex(this.r)}${paddedHex(this.g)}${paddedHex(this.b)}`;
  }
  /**
   * Used by CSS.
   * Converts this color to a hex string with leading '#' symbol and 6- or 8-
   * hexadecimal characters (depending on if alpha is 1.0)
   * @returns {string}
   */


  toRGBAHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }

    return `#${this._toRGBHexString()}${this.alphaHex()}`;
  }
  /**
   * Used by Android/iOS
   * Converts this color to a hex string with leading '#' symbol and 6- or 8-
   * hexadecimal characters (depending on if alpha is 1.0). Alpha is the first entry (if there is alpha.)
   * @returns {string}
   */


  toARGBHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }

    return `#${this.alphaHex()}${this._toRGBHexString()}`;
  }
  /**
   * For commonality with native iOS TiColor proxy. Produces an AARRGGBB (or RRGGBB if full alpha) hex string
   * @returns {string}
   */


  toHex() {
    return this.toARGBHexString();
  }
  /**
   * Converts this color to an rgba expression. This expression is more consistent across platforms.
   * (whereas iOS/Android differ in expectations for hex strings.)
   * @returns {string}
   */


  toRGBAString() {
    return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.alpha.toFixed(3)})`;
  }
  /**
   * @returns {Color}
   */


  static fallback() {
    return new Color(0, 0, 0); // return black to match native impl in iOS
  }
  /**
   * The supplied hex string MUST be in form '#000000' (i.e. leading pound symbol, 6 hex characters after)
   * @param {string} hex hexadecimal color string
   * @param {number} [alpha] alpha value
   * @returns {Color}
   */


  static fromHex6String(hex, alpha) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const r = parseInt(hex.substr(startIndex, 2), 16);
    const g = parseInt(hex.substr(startIndex + 2, 2), 16);
    const b = parseInt(hex.substr(startIndex + 4, 2), 16);
    return new Color(r, g, b, alpha);
  }
  /**
   * The supplied hex string MUST be in form '#00000000' (i.e. leading pound symbol, 8 hex characters after)
   * @param {string} hex hexadecimal color string
   * @returns {Color}
   */


  static fromHex8String(hex) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const alpha = parseInt(hex.substr(startIndex, 2), 16); // alpha is now 0-255

    const r = parseInt(hex.substr(startIndex + 2, 2), 16);
    const g = parseInt(hex.substr(startIndex + 4, 2), 16);
    const b = parseInt(hex.substr(startIndex + 6, 2), 16);
    return new Color(r, g, b, alpha / 255.0); // convert to 0.0-1.0 (percent)
  }
  /**
   * Note that the hex value can contain alpha, but must follow the CSS standard of #RRGGBBAA (NOT the Android standard of #AARRGGBB)
   * @param {string|object} entry possible hex string or an object
   * @param {string|number} [hex.alpha] alpha value in percent (0.0-100.0) when hex is an object
  	 * @param {string} [hex.color] hex string for the base color when hex is an object
   * @returns {Color}
   * @throws if entry has both an explicit alpha value AND a hex string containing an alpha value
   */


  static fromSemanticColorsEntry(entry) {
    let color = entry;
    let alpha = 1.0;
    let hadAlpha = false;

    if (Object.prototype.hasOwnProperty.call(entry, 'alpha')) {
      alpha = parseFloat(entry.alpha) / 100.0; // convert from 0-100 range to 0-1 range

      hadAlpha = true;
      color = entry.color; // if it has an alpha property assume it has a color property too!
    } // expand the shorter hex string forms to 6 or 8 digits


    if (color.length === 3) {
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      color = color.replace(HEX_3_REGEX, (m, r, g, b) => r + r + g + g + b + b);
    } else if (color.length === 4) {
      // Expand shorthand form (e.g. "03F8") to full form (e.g. "0033FF88")
      color = color.replace(HEX_4_REGEX, (m, a, r, g, b) => a + a + r + r + g + g + b + b);
    }

    if (HEX_6_REGEX.exec(color)) {
      return Color.fromHex6String(color, alpha);
    }

    if (HEX_8_REGEX.exec(color)) {
      if (hadAlpha) {
        throw new Error(`Color ${entry} had an explicit alpha value AND a hex value containing alpha. Use one or the other.`);
      }

      return Color.fromHex8String(color);
    } // uh-oh, something is up!


    return Color.fallback();
  }}



var color = Color;

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2019-2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
// Ti.UI within this file, we must call kroll.binding to get the Titanium
// namespace that is passed in with require and that deal with the .UI
// namespace that is on that directly.

const UI = kroll.binding('Titanium').Titanium.UI; // Make our read-only constants
// TODO: Remove in SDK 10, DEPRECATED in 9.1.0

Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_LIGHT', {
  value: 'light',
  writable: false });

Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_DARK', {
  value: 'dark',
  writable: false });

Object.defineProperty(UI, 'semanticColorType', {
  get: () => {
    // TODO: Guard against ios < 13 and Android api < 29?
    // Assume "light" mode unless we explicitly know it's dark
    if (Ti.UI.userInterfaceStyle === Ti.UI.USER_INTERFACE_STYLE_DARK) {
      return UI.SEMANTIC_COLOR_TYPE_DARK;
    }

    return UI.SEMANTIC_COLOR_TYPE_LIGHT;
  } });
// on Android/iOS < 13, we need to roll our own fetchSemanticColor impl
// on iOS 13+, we have a native version

{

  let colorset;

  UI.fetchSemanticColor = function fetchSemanticColor(colorName) {
    // Load all semantic colors from JSON if not done already.
    // Do so via require() in case this file was changed while running LiveView.
    if (!colorset) {
      const colorsetFileName = 'semantic.colors.json';

      try {
        const colorsetFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, colorsetFileName);

        if (colorsetFile.exists()) {
          // eslint-disable-next-line security/detect-non-literal-require
          colorset = require(`/${colorsetFileName}`);
        }
      } catch (error) {
        console.error(`Failed to load colors file '${colorsetFileName}'`);
        return color.fallback().toHex();
      }
    }

    try {
      if (true) {
        // On Android, use custom string references to be handled by "TiColorHelper.java".
        if (colorset[colorName]) {
          // Add all theme colors to a single string.
          // Example: "ti.semantic.color:dark=<ColorString>;light=<ColorString>"
          const colorArray = [];

          for (const colorType in colorset[colorName]) {
            const colorObj = color.fromSemanticColorsEntry(colorset[colorName][colorType]);
            colorArray.push(`${colorType}=${colorObj.toRGBAString()}`);
          }

          return 'ti.semantic.color:' + colorArray.join(';');
        } else if (Ti.Android.R.color[colorName]) {
          // We're referencing a native "res" color entry.
          return `@color/${colorName}`;
        }
      }
    } catch (error) {
      console.error(`Failed to lookup color for ${colorName}`);
    }

    return color.fallback().toHex();
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID, OS_IOS */
{
  const Tab = Titanium.UI.Tab;

  function createTab(options) {
    const tab = new Tab(options);

    if (options) {
      tab._window = options.window;
    }

    return tab;
  }

  Titanium.UI.createTab = createTab;

  Tab.prototype.open = function (window, options) {
    if (!window) {
      return;
    }

    if (!options) {
      options = {};
    } // When we open a window using tab.open(win), we treat it as
    // opening a HW window on top of the tab.


    options.tabOpen = true;
    window.open(options);
  };

  Tab.prototype.close = function (options) {
    const window = this.getWindow();

    if (window) {
      window.close(options);
      this.setWindow(null);
    }
  };

  const _setWindow = Tab.prototype.setWindow;

  Tab.prototype.setWindow = function (window) {
    this._window = window;

    _setWindow.call(this, window);
  }; // TODO: Remove! This is an undocumented accessor method


  Tab.prototype.getWindow = function () {
    return this._window;
  };

  Object.defineProperty(Tab.prototype, 'window', {
    enumerable: true,
    set: Tab.prototype.setWindow,
    get: Tab.prototype.getWindow });

}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2021 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  const TabGroup = Titanium.UI.TabGroup; // Avoid circular loops in toJSON()

  Object.defineProperty(TabGroup.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'activity' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

  Object.defineProperty(Titanium.UI.Tab.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'window' || k === 'tabGroup' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2015-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  const View = Titanium.UI.View;
  const _add = View.prototype.add;

  View.prototype.add = function (child) {
    if (child instanceof Titanium.TiWindow) {
      throw new Error('Cannot add window/tabGroup to a view.');
    }

    this._children = this._children || [];

    _add.call(this, child); // The children have to be retained by the view in the Javascript side
    // in order to let V8 know the relationship between children and the view.
    // Therefore, as long as its window is open, all its children won't be detached
    // or garbage collected and V8 will recoganize the closures and retain all
    // the related proxies.


    this._children.push(child);
  };

  const _remove = View.prototype.remove;

  View.prototype.remove = function (child) {
    _remove.call(this, child); // Remove the child in the Javascript side so it can be detached and garbage collected.


    const children = this._children || [];
    const childIndex = children.indexOf(child);

    if (childIndex !== -1) {
      children.splice(childIndex, 1);
    }
  }; // Do not serialize the parent view. Doing so will result
  // in a circular reference loop.


  Object.defineProperty(Titanium.TiView.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'parent' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

}

/* globals OS_ANDROID */
{
  const createWebView = Titanium.UI.createWebView;

  function createWebViewWrapper(...args) {
    const webView = createWebView.apply(this, args);

    webView.onCreateWindow = function (e) {
      if (!e.isUserGesture) {
        return null;
      }

      const win = Titanium.UI.createWindow({}, {
        fullscreen: false // Force new activity.
      });

      const newWebView = Titanium.UI.createWebView();
      win.add(newWebView);
      win.open();
      return newWebView;
    };

    return webView;
  }

  Titanium.UI.createWebView = createWebViewWrapper;
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

{
  const TAG = 'Window';
  const Script = kroll.binding('evals').Script; // Android-specific way to grab binding, hangs off 'script' on iOS

  const Window = Titanium.UI.Window;
  Window.prototype._cachedActivityProxy = null;

  function createWindow(options) {
    const window = new Window(options);
    window._children = [];
    return window;
  }

  Titanium.UI.createWindow = createWindow; // Activity getter (account for scenario when heavy weight window's activity is not created yet)

  function activityProxyGetter() {
    const activityProxy = this._getWindowActivityProxy();

    if (activityProxy) {
      return activityProxy;
    }

    if (this._cachedActivityProxy == null) {
      // eslint-disable-line
      this._cachedActivityProxy = {};
    }

    return this._cachedActivityProxy;
  }

  Window.prototype.getActivity = activityProxyGetter;
  Object.defineProperty(Window.prototype, 'activity', {
    get: activityProxyGetter });

  const _open = Window.prototype.open;

  Window.prototype.open = function (options) {
    // Retain the window until it has closed.
    const handle = new PersistentHandle(this);
    const self = this;
    this.once('close', function (e) {
      if (e._closeFromActivityForcedToDestroy) {
        if (kroll.DBG) {
          kroll.log(TAG, 'Window is closed because the activity is forced to destroy by Android OS.');
        }

        return;
      } // Dispose the URL context if the window's activity is destroyed.


      if (self._urlContext) {
        Script.disposeContext(self._urlContext);
        self._urlContext = null;
      }

      handle.dispose();

      if (kroll.DBG) {
        kroll.log(TAG, 'Window is closed normally.');
      }
    });
    return _open.call(this, options);
  };

  const _add = Window.prototype.add;

  Window.prototype.add = function (child) {
    if (child instanceof Titanium.TiWindow) {
      throw new Error('Cannot add window/tabGroup to another window/tabGroup.');
    }

    _add.call(this, child); // The children have to be retained by the window in the Javascript side
    // in order to let V8 know the relationship between children and the window.
    // Therefore, as long as the window is open, all its children won't be detached
    // or garbage collected and V8 will recoganize the closures and retain all
    // the related proxies.


    this._children.push(child);
  };

  const _remove = Window.prototype.remove;

  Window.prototype.remove = function (child) {
    _remove.call(this, child); // Remove the child in the Javascript side so it can be detached and garbage collected.


    const children = this._children;

    if (children) {
      const childIndex = children.indexOf(child);

      if (childIndex !== -1) {
        children.splice(childIndex, 1);
      }
    }
  };

  Window.prototype.postWindowCreated = function () {
    if (kroll.DBG) {
      kroll.log(TAG, 'Checkpoint: postWindowCreated()');
    }

    if (this._cachedActivityProxy) {
      this._internalActivity.extend(this._cachedActivityProxy);
    }
  };
}

/**
 * @param {EventEmitter} emitter the EventEmitter instance to use to register for it's events
 * @param {string} eventName the name of the event to register for
 * @param {function} listener the listener callback/function to invoke when the event is emitted
 * @param {boolean} prepend whether to prepend or append the listener
 * @returns {EventEmitter}
 */
function _addListener(emitter, eventName, listener, prepend) {
  if (!emitter._eventsToListeners) {
    // no events/listeners registered
    emitter._eventsToListeners = {}; // initialize it
  } // if there's someone listening to 'newListener' events, emit that **before** we add the listener (to avoid infinite recursion)


  if (emitter._eventsToListeners.newListener) {
    emitter.emit('newListener', eventName, listener);
  }

  const eventListeners = emitter._eventsToListeners[eventName] || [];

  if (prepend) {
    eventListeners.unshift(listener);
  } else {
    eventListeners.push(listener);
  }

  emitter._eventsToListeners[eventName] = eventListeners; // Check max listeners and spit out warning if >

  const max = emitter.getMaxListeners();
  const length = eventListeners.length;

  if (max > 0 && length > max) {
    const w = new Error(`Possible EventEmitter memory leak detected. ${length} ${eventName} listeners added. Use emitter.setMaxListeners() to increase limit`);
    w.name = 'MaxListenersExceededWarning';
    w.emitter = emitter;
    w.type = eventName;
    w.count = length;
    process.emitWarning(w);
  }

  return emitter;
}

function onceWrap(emitter, eventName, listener) {
  function wrapper(...args) {
    this.emitter.removeListener(this.eventName, this.wrappedFunc); // remove ourselves

    this.listener.apply(this.emitter, args); // then forward the event callback
  } // we have to use bind with a custom 'this', because events fire with 'this' pointing at the emitter


  const wrapperThis = {
    emitter,
    eventName,
    listener };

  const bound = wrapper.bind(wrapperThis); // bind to force "this" to refer to our custom object tracking the wrapper/emitter/listener

  bound.listener = listener; // have to add listener property for "unwrapping"

  wrapperThis.wrappedFunc = bound;
  return bound;
} // many consumers make use of this via util.inherits, which does not chain constructor calls!
// so we need to be aware that _eventsToListeners maye be null/undefined on instances, and check in methods before accessing it


class EventEmitter {
  constructor() {
    this._eventsToListeners = {};
    this._maxListeners = undefined;
  }

  addListener(eventName, listener) {
    return _addListener(this, eventName, listener, false);
  }

  on(eventName, listener) {
    return this.addListener(eventName, listener);
  }

  prependListener(eventName, listener) {
    return _addListener(this, eventName, listener, true);
  }

  once(eventName, listener) {
    this.on(eventName, onceWrap(this, eventName, listener));
  }

  prependOnceListener(eventName, listener) {
    this.prependListener(eventName, onceWrap(this, eventName, listener));
  }

  removeListener(eventName, listener) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return this;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];
    const length = eventListeners.length;
    let foundIndex = -1;
    let unwrappedListener; // Need to search LIFO, and need to handle wrapped functions (once wrappers)

    for (let i = length - 1; i >= 0; i--) {
      if (eventListeners[i] === listener || eventListeners[i].listener === listener) {
        foundIndex = i;
        unwrappedListener = eventListeners[i].listener;
        break;
      }
    }

    if (foundIndex !== -1) {
      if (length === 1) {
        // length was 1 and we want to remove last entry, so delete the event type from our listener mapping now!
        delete this._eventsToListeners[eventName];
      } else {
        // we had 2+ listeners, so store array without this given listener
        eventListeners.splice(foundIndex, 1); // modifies in place, no need to assign to this.listeners[eventName]
      } // Don't emit if there's no listeners for 'removeListener' type!


      if (this._eventsToListeners.removeListener) {
        this.emit('removeListener', eventName, unwrappedListener || listener);
      }
    }

    return this;
  }

  off(eventName, listener) {
    return this.removeListener(eventName, listener);
  }

  emit(eventName, ...args) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return false;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];

    for (const listener of eventListeners.slice()) {
      // must operate on copy because listeners ,ay get remove as side-effect of calling
      listener.call(this, ...args);
    }

    return eventListeners.length !== 0;
  }

  listenerCount(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return 0;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];
    return eventListeners.length;
  }

  eventNames() {
    return Object.getOwnPropertyNames(this._eventsToListeners || {});
  }

  listeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    } // Need to "unwrap" once wrappers!


    const raw = this._eventsToListeners[eventName] || [];
    return raw.map(l => l.listener || l); // here we unwrap the once wrapper if there is one or fall back to listener function
  }

  rawListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    }

    return (this._eventsToListeners[eventName] || []).slice(0); // return a copy
  }

  getMaxListeners() {
    return this._maxListeners || EventEmitter.defaultMaxListeners;
  }

  setMaxListeners(n) {
    this._maxListeners = n; // TODO: Type check n, make sure >= 0 (o equals no limit)

    return this;
  }

  removeAllListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      this._eventsToListeners = {}; // initialize it
    }

    if (!this._eventsToListeners.removeListener) {
      // no need to emit! we can just wipe!
      if (eventName === undefined) {
        // remove every type!
        this._eventsToListeners = {};
      } else {
        // remove specific type
        delete this._eventsToListeners[eventName];
      }

      return this;
    } // yuck, we'll have to emit 'removeListener' events as we go


    if (eventName === undefined) {
      // Remove all types (but do 'removeListener' last!)
      const names = Object.keys(this._eventsToListeners).filter(name => name !== 'removeListener');
      names.forEach(name => this.removeAllListeners(name));
      this.removeAllListeners('removeListener');
      this._eventsToListeners = {};
    } else {
      // remove listeners for one type, back to front (Last-in, first-out, except where prepend f-ed it up)
      const listeners = this._eventsToListeners[eventName] || [];

      for (let i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(eventName, listeners[i]);
      }
    }

    return this;
  }}


EventEmitter.defaultMaxListeners = 10;

EventEmitter.listenerCount = function (emitter, eventName) {
  return emitter.listenerCount(eventName);
};

EventEmitter.EventEmitter = EventEmitter;

/**
 * @param  {*} arg passed in argument value
 * @param  {string} name name of the argument
 * @param  {string} typename i.e. 'string', 'Function' (value is compared to typeof after lowercasing)
 * @return {void}
 * @throws {TypeError}
 */
function assertArgumentType(arg, name, typename) {
  const type = typeof arg;

  if (type !== typename.toLowerCase()) {
    throw new TypeError(`The "${name}" argument must be of type ${typename}. Received type ${type}`);
  }
}

const startTime = Date.now();
/**
 * This function 'standardizes' the reported architectures to the equivalents reported by Node.js
 * node values: 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'.
 * iOS values: "arm64", "armv7", "x86_64", "i386", "Unknown"
 * Android values: "armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64", "unknown"
 * Windows values: "x64", "ia64", "ARM", "x86", "unknown"
 * @param {string} original original architecture reported by Ti.Platform
 * @returns {string}
 */

function standardizeArch(original) {
  switch (original) {
    // coerce 'armv7', 'armeabi', 'armeabi-v7a', 'ARM' -> 'arm'
    // 'armeabi' is a dead ABI for Android, removed in NDK r17
    case 'armv7':
    case 'armeabi':
    case 'armeabi-v7a':
    case 'ARM':
      return 'arm';
    // coerce 'arm64-v8a' -> 'arm64'

    case 'arm64-v8a':
      return 'arm64';
    // coerce 'i386', 'x86' -> 'ia32'

    case 'i386':
    case 'x86':
      return 'ia32';
    // coerce 'x86_64', 'ia64', 'x64' -> 'x64'

    case 'x86_64':
    case 'ia64':
      return 'x64';
    // coerce 'mips64' -> 'mips' // 'mips' and 'mips64' are dead ABIs for Android, removed in NDK r17

    case 'mips64':
      return 'mips';
    // coerce 'Unknown' -> 'unknown'

    case 'Unknown':
      return 'unknown';

    default:
      return original;}

}

const process$1 = new EventEmitter();

process$1.abort = () => {}; // TODO: Do we have equivalent of forcibly killing the process? We have restart, but I think we just want a no-op stub here


process$1.arch = standardizeArch(Ti.Platform.architecture);
process$1.argv = []; // TODO: What makes sense here? path to titanium cli for first arg? path to ti.main/app.js for second?

Object.defineProperty(process$1, 'argv0', {
  value: '',
  // TODO: Path to .app on iOS?
  writable: false,
  enumerable: true,
  configurable: false });


process$1.binding = () => {
  throw new Error('process.binding is unsupported and not user-facing API');
};

process$1.channel = undefined;

process$1.chdir = () => {
  throw new Error('process.chdir is unsupported');
};

process$1.config = {};
process$1.connected = false;

process$1.cpuUsage = () => {
  // FIXME: Can we look at OS.cpus to get this data?
  return {
    user: 0,
    system: 0 };

};

process$1.cwd = () => __dirname;

Object.defineProperty(process$1, 'debugPort', {
  get: function () {
    let value = 0; // default to 0

    try {
      if ("android" === 'android') {
        const assets = kroll.binding('assets');
        const json = assets.readAsset('deploy.json');

        if (json) {
          const deployData = JSON.parse(json);

          if (deployData.debuggerPort !== -1) {
            // -1 means not set (not in debug mode)
            value = deployData.debuggerPort;
          }
        }
      }
    } catch (error) {} // ignore
    // overwrite this getter with static value


    Object.defineProperty(this, 'debugPort', {
      value: value,
      writable: true,
      enumerable: true,
      configurable: true });

    return value;
  },
  enumerable: true,
  configurable: true });


process$1.disconnect = () => {}; // no-op


process$1.dlopen = () => {
  throw new Error('process.dlopen is not supported');
};

process$1.emitWarning = function (warning, options, code, ctor) {
  // eslint-disable-line no-unused-vars
  let type;
  let detail;

  if (typeof options === 'string') {
    type = options;
  } else if (typeof options === 'object') {
    type = options.type;
    code = options.code;
    detail = options.detail;
  }

  if (typeof warning === 'string') {
    // TODO: make use of `ctor` arg for limiting stack traces? Can only really be used on V8
    // set stack trace limit to 0, then call Error.captureStackTrace(warning, ctor);
    warning = new Error(warning);
    warning.name = type || 'Warning';

    if (code !== undefined) {
      warning.code = code;
    }

    if (detail !== undefined) {
      warning.detail = detail;
    }
  } // TODO: Throw TypeError if not an instanceof Error at this point!


  const isDeprecation = warning.name === 'DeprecationWarning';

  if (isDeprecation && process$1.noDeprecation) {
    return; // ignore
  }

  if (isDeprecation && process$1.throwDeprecation) {
    throw warning;
  }

  this.emit('warning', warning);
};

function loadEnvJson() {
  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, '_env_.json');

    if (jsonFile.exists()) {
      return JSON.parse(jsonFile.read().text);
    }
  } catch (error) {
    Ti.API.error(`Failed to read "_env_.json". Reason: ${error.message}`);
  }

  return {};
}

Object.defineProperty(process$1, 'env', {
  get: function () {
    delete this.env;
    return this.env = loadEnvJson();
  },
  enumerable: true,
  configurable: true });

process$1.execArgv = [];
process$1.execPath = ''; // FIXME: What makes sense here? Path to titanium CLI here?

process$1.exit = () => {
  throw new Error('process.exit is not supported');
};

process$1.exitCode = undefined;
process$1.noDeprecation = false;
process$1.pid = 0; // FIXME: Should we try and adopt 'ipad'/'iphone' to 'darwin'? or 'ios'?

process$1.platform = "android";
process$1.ppid = 0; // TODO: Add release property (Object)
// TODO: Can we expose stdout/stderr/stdin natively?
// Don't wrap console.log/error because technically global console wraps process.stdout/stderr (or should)

process$1.stderr = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.error(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$1.stdout = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.info(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$1.title = Ti.App.name;
process$1.throwDeprecation = false;
process$1.traceDeprecation = false;

process$1.umask = () => 0; // just always return 0


process$1.uptime = () => {
  const diffMs = Date.now() - startTime;
  return diffMs / 1000.0; // convert to "seconds" with fractions
};

process$1.version = "10.0.0";
process$1.versions = {
  modules: '',
  // TODO: Report module api version (for current platform!)
  v8: '',
  // TODO: report android's v8 version (if on Android!)
  jsc: '' // TODO: report javascriptcore version for iOS/WIndows?
  // TODO: Report ios/Android/Windows platform versions?
};

process$1[Symbol.toStringTag] = 'process';
global.process = process$1; // handle spitting out warnings

const WARNING_PREFIX = `(titanium:${process$1.pid}) `;
process$1.on('warning', warning => {
  const isDeprecation = warning.name === 'DeprecationWarning'; // if we're not doing deprecations, ignore!

  if (isDeprecation && process$1.noDeprecation) {
    return;
  } // TODO: Check process.traceDeprecation and if set, include stack trace in message!


  let msg = WARNING_PREFIX;

  if (warning.code !== undefined) {
    msg += `[${warning.code}] `;
  }

  if (warning.toString) {
    msg += warning.toString();
  }

  if (warning.detail) {
    msg += `\n${warning.detail}`;
  }

  console.error(msg);
});
let uncaughtExceptionCallback = null;

process$1.hasUncaughtExceptionCaptureCallback = () => uncaughtExceptionCallback !== null;

process$1.setUncaughtExceptionCaptureCallback = fn => {
  if (fn === null) {
    uncaughtExceptionCallback = null;
    return;
  }

  assertArgumentType(fn, 'fn', 'function');

  if (uncaughtExceptionCallback !== null) {
    throw new Error('`process.setUncaughtExceptionCaptureCallback()` was called while a capture callback was already active');
  }

  uncaughtExceptionCallback = fn;
};

Ti.App.addEventListener('uncaughtException', function (event) {
  // Create an Error instance that wraps the data from the event
  // ideally we'd just forward along the original Error!
  const error = new Error(event.message);
  error.stack = event.backtrace;
  error.fileName = event.sourceName;
  error.lineNumber = event.line;
  error.columnNumber = event.lineOffset;

  if (process$1.hasUncaughtExceptionCaptureCallback()) {
    return uncaughtExceptionCallback(error);
  } // otherwise forward the event!


  process$1.emit('uncaughtException', error);
});
// JS engine should be able to optimize easier

class CallbackWithArgs {
  constructor(func, args) {
    this.func = func;
    this.args = args;
  }

  run() {
    if (this.args) {
      this.func.apply(null, this.args);
    } else {
      this.fun();
    }
  }}

// nextTick vs setImmediate should be handled in a semi-smart way
// Basically nextTick needs to drain the full queue (and can cause infinite loops if nextTick callback calls nextTick!)
// Then we should go through the "immediate" queue
// http://plafer.github.io/2015/09/08/nextTick-vs-setImmediate/


const tickQueue = [];
const immediateQueue = [];
let drainingTickQueue = false;
let drainQueuesTimeout = null;
/**
 * Iteratively runs all "ticks" until there are no more.
 * This can cause infinite recursion if a tick schedules another forever.
 */

function drainTickQueue() {
  if (drainingTickQueue) {
    return;
  }

  drainingTickQueue = true;

  while (tickQueue.length) {
    const tick = tickQueue.shift();
    tick.run();
  }

  drainingTickQueue = false;
}

function drainQueues() {
  // drain the full tick queue first...
  drainTickQueue(); // tick queue should be empty!

  const immediatesRemaining = processImmediateQueue();

  if (immediatesRemaining !== 0) {
    // re-schedule draining our queues, as we have at least one more "immediate" to handle
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  } else {
    drainQueuesTimeout = null;
  }
}
/**
 * Attempts to process "immediates" (in a much more leisurely way than ticks)
 * We give a 100ms window to run them in before re-scheduling the timeout to process them again.
 * If any ticks are added during invocation of immediate, we drain the tick queue fully before
 * proceeding to next immediate (if we still have time in our window).
 * @returns {number} number of remaining immediates to be processed
 */


function processImmediateQueue() {
  const immediateDeadline = Date.now() + 100; // give us up to 100ms to process immediates

  while (immediateQueue.length && Date.now() < immediateDeadline) {
    const immediate = immediateQueue.shift();
    immediate.run();

    if (tickQueue.length > 0) {
      // they added a tick! drain the tick queue before we do anything else (this *may* eat up our deadline/window to process any more immediates)
      drainTickQueue();
    }
  }

  return immediateQueue.length;
}

process$1.nextTick = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  tickQueue.push(new CallbackWithArgs(callback, args));

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
};

global.setImmediate = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  const immediate = new CallbackWithArgs(callback, args);
  immediateQueue.push(immediate);

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }

  return immediate;
};

global.clearImmediate = function (immediate) {
  const index = immediateQueue.indexOf(immediate);

  if (index !== -1) {
    immediateQueue.splice(index, 1);
  }
};

const FORWARD_SLASH = 47; // '/'

const BACKWARD_SLASH = 92; // '\\'

/**
 * Is this [a-zA-Z]?
 * @param  {number}  charCode value from String.charCodeAt()
 * @return {Boolean}          [description]
 */

function isWindowsDeviceName(charCode) {
  return charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
}
/**
 * [isAbsolute description]
 * @param  {boolean} isPosix whether this impl is for POSIX or not
 * @param  {string} filepath   input file path
 * @return {Boolean}          [description]
 */


function isAbsolute(isPosix, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length; // empty string special case

  if (length === 0) {
    return false;
  }

  const firstChar = filepath.charCodeAt(0);

  if (firstChar === FORWARD_SLASH) {
    return true;
  } // we already did our checks for posix


  if (isPosix) {
    return false;
  } // win32 from here on out


  if (firstChar === BACKWARD_SLASH) {
    return true;
  }

  if (length > 2 && isWindowsDeviceName(firstChar) && filepath.charAt(1) === ':') {
    const thirdChar = filepath.charAt(2);
    return thirdChar === '/' || thirdChar === '\\';
  }

  return false;
}
/**
 * [dirname description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @return {string}            [description]
 */


function dirname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length;

  if (length === 0) {
    return '.';
  } // ignore trailing separator


  let fromIndex = length - 1;
  const hadTrailing = filepath.endsWith(separator);

  if (hadTrailing) {
    fromIndex--;
  }

  const foundIndex = filepath.lastIndexOf(separator, fromIndex); // no separators

  if (foundIndex === -1) {
    // handle special case of root windows paths
    if (length >= 2 && separator === '\\' && filepath.charAt(1) === ':') {
      const firstChar = filepath.charCodeAt(0);

      if (isWindowsDeviceName(firstChar)) {
        return filepath; // it's a root windows path
      }
    }

    return '.';
  } // only found root separator


  if (foundIndex === 0) {
    return separator; // if it was '/', return that
  } // Handle special case of '//something'


  if (foundIndex === 1 && separator === '/' && filepath.charAt(0) === '/') {
    return '//';
  }

  return filepath.slice(0, foundIndex);
}
/**
 * [extname description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @return {string}            [description]
 */


function extname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const index = filepath.lastIndexOf('.');

  if (index === -1 || index === 0) {
    return '';
  } // ignore trailing separator


  let endIndex = filepath.length;

  if (filepath.endsWith(separator)) {
    endIndex--;
  }

  return filepath.slice(index, endIndex);
}

function lastIndexWin32Separator(filepath, index) {
  for (let i = index; i >= 0; i--) {
    const char = filepath.charCodeAt(i);

    if (char === BACKWARD_SLASH || char === FORWARD_SLASH) {
      return i;
    }
  }

  return -1;
}
/**
 * [basename description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @param  {string} [ext]      file extension to drop if it exists
 * @return {string}            [description]
 */


function basename(separator, filepath, ext) {
  assertArgumentType(filepath, 'path', 'string');

  if (ext !== undefined) {
    assertArgumentType(ext, 'ext', 'string');
  }

  const length = filepath.length;

  if (length === 0) {
    return '';
  }

  const isPosix = separator === '/';
  let endIndex = length; // drop trailing separator (if there is one)

  const lastCharCode = filepath.charCodeAt(length - 1);

  if (lastCharCode === FORWARD_SLASH || !isPosix && lastCharCode === BACKWARD_SLASH) {
    endIndex--;
  } // Find last occurence of separator


  let lastIndex = -1;

  if (isPosix) {
    lastIndex = filepath.lastIndexOf(separator, endIndex - 1);
  } else {
    // On win32, handle *either* separator!
    lastIndex = lastIndexWin32Separator(filepath, endIndex - 1); // handle special case of root path like 'C:' or 'C:\\'

    if ((lastIndex === 2 || lastIndex === -1) && filepath.charAt(1) === ':' && isWindowsDeviceName(filepath.charCodeAt(0))) {
      return '';
    }
  } // Take from last occurrence of separator to end of string (or beginning to end if not found)


  const base = filepath.slice(lastIndex + 1, endIndex); // drop trailing extension (if specified)

  if (ext === undefined) {
    return base;
  }

  return base.endsWith(ext) ? base.slice(0, base.length - ext.length) : base;
}
/**
 * The `path.normalize()` method normalizes the given path, resolving '..' and '.' segments.
 *
 * When multiple, sequential path segment separation characters are found (e.g.
 * / on POSIX and either \ or / on Windows), they are replaced by a single
 * instance of the platform-specific path segment separator (/ on POSIX and \
 * on Windows). Trailing separators are preserved.
 *
 * If the path is a zero-length string, '.' is returned, representing the
 * current working directory.
 *
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath  input file path
 * @return {string} [description]
 */


function normalize(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');

  if (filepath.length === 0) {
    return '.';
  } // Windows can handle '/' or '\\' and both should be turned into separator


  const isWindows = separator === '\\';

  if (isWindows) {
    filepath = filepath.replace(/\//g, separator);
  }

  const hadLeading = filepath.startsWith(separator); // On Windows, need to handle UNC paths (\\host-name\\resource\\dir) special to retain leading double backslash

  const isUNC = hadLeading && isWindows && filepath.length > 2 && filepath.charAt(1) === '\\';
  const hadTrailing = filepath.endsWith(separator);
  const parts = filepath.split(separator);
  const result = [];

  for (const segment of parts) {
    if (segment.length !== 0 && segment !== '.') {
      if (segment === '..') {
        result.pop(); // FIXME: What if this goes above root? Should we throw an error?
      } else {
        result.push(segment);
      }
    }
  }

  let normalized = hadLeading ? separator : '';
  normalized += result.join(separator);

  if (hadTrailing) {
    normalized += separator;
  }

  if (isUNC) {
    normalized = '\\' + normalized;
  }

  return normalized;
}
/**
 * [assertSegment description]
 * @param  {*} segment [description]
 * @return {void}         [description]
 */


function assertSegment(segment) {
  if (typeof segment !== 'string') {
    throw new TypeError(`Path must be a string. Received ${segment}`);
  }
}
/**
 * The `path.join()` method joins all given path segments together using the
 * platform-specific separator as a delimiter, then normalizes the resulting path.
 * Zero-length path segments are ignored. If the joined path string is a zero-
 * length string then '.' will be returned, representing the current working directory.
 * @param  {string} separator platform-specific file separator
 * @param  {string[]} paths [description]
 * @return {string}       The joined filepath
 */


function join(separator, paths) {
  const result = []; // naive impl: just join all the paths with separator

  for (const segment of paths) {
    assertSegment(segment);

    if (segment.length !== 0) {
      result.push(segment);
    }
  }

  return normalize(separator, result.join(separator));
}
/**
 * The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {string[]} paths [description]
 * @return {string}       [description]
 */


function resolve(separator, paths) {
  let resolved = '';
  let hitRoot = false;
  const isPosix = separator === '/'; // go from right to left until we hit absolute path/root

  for (let i = paths.length - 1; i >= 0; i--) {
    const segment = paths[i];
    assertSegment(segment);

    if (segment.length === 0) {
      continue; // skip empty
    }

    resolved = segment + separator + resolved; // prepend new segment

    if (isAbsolute(isPosix, segment)) {
      // have we backed into an absolute path?
      hitRoot = true;
      break;
    }
  } // if we didn't hit root, prepend cwd


  if (!hitRoot) {
    resolved = (global.process ? process.cwd() : '/') + separator + resolved;
  }

  const normalized = normalize(separator, resolved);

  if (normalized.charAt(normalized.length - 1) === separator) {
    // FIXME: Handle UNC paths on Windows as well, so we don't trim trailing separator on something like '\\\\host-name\\resource\\'
    // Don't remove trailing separator if this is root path on windows!
    if (!isPosix && normalized.length === 3 && normalized.charAt(1) === ':' && isWindowsDeviceName(normalized.charCodeAt(0))) {
      return normalized;
    } // otherwise trim trailing separator


    return normalized.slice(0, normalized.length - 1);
  }

  return normalized;
}
/**
 * The `path.relative()` method returns the relative path `from` from to `to` based
 * on the current working directory. If from and to each resolve to the same
 * path (after calling `path.resolve()` on each), a zero-length string is returned.
 *
 * If a zero-length string is passed as `from` or `to`, the current working directory
 * will be used instead of the zero-length strings.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {string} from [description]
 * @param  {string} to   [description]
 * @return {string}      [description]
 */


function relative(separator, from, to) {
  assertArgumentType(from, 'from', 'string');
  assertArgumentType(to, 'to', 'string');

  if (from === to) {
    return '';
  }

  from = resolve(separator, [from]);
  to = resolve(separator, [to]);

  if (from === to) {
    return '';
  } // we now have two absolute paths,
  // lets "go up" from `from` until we reach common base dir of `to`
  // const originalFrom = from;


  let upCount = 0;
  let remainingPath = '';

  while (true) {
    if (to.startsWith(from)) {
      // match! record rest...?
      remainingPath = to.slice(from.length);
      break;
    } // FIXME: Break/throw if we hit bad edge case of no common root!


    from = dirname(separator, from);
    upCount++;
  } // remove leading separator from remainingPath if there is any


  if (remainingPath.length > 0) {
    remainingPath = remainingPath.slice(1);
  }

  return ('..' + separator).repeat(upCount) + remainingPath;
}
/**
 * The `path.parse()` method returns an object whose properties represent
 * significant elements of the path. Trailing directory separators are ignored,
 * see `path.sep`.
 *
 * The returned object will have the following properties:
 *
 * - dir <string>
 * - root <string>
 * - base <string>
 * - name <string>
 * - ext <string>
 * @param  {string} separator platform-specific file separator
 * @param  {string} filepath [description]
 * @return {object}
 */


function parse(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const result = {
    root: '',
    dir: '',
    base: '',
    ext: '',
    name: '' };

  const length = filepath.length;

  if (length === 0) {
    return result;
  } // Cheat and just call our other methods for dirname/basename/extname?


  result.base = basename(separator, filepath);
  result.ext = extname(separator, result.base);
  const baseLength = result.base.length;
  result.name = result.base.slice(0, baseLength - result.ext.length);
  const toSubtract = baseLength === 0 ? 0 : baseLength + 1;
  result.dir = filepath.slice(0, filepath.length - toSubtract); // drop trailing separator!

  const firstCharCode = filepath.charCodeAt(0); // both win32 and POSIX return '/' root

  if (firstCharCode === FORWARD_SLASH) {
    result.root = '/';
    return result;
  } // we're done with POSIX...


  if (separator === '/') {
    return result;
  } // for win32...


  if (firstCharCode === BACKWARD_SLASH) {
    // FIXME: Handle UNC paths like '\\\\host-name\\resource\\file_path'
    // need to retain '\\\\host-name\\resource\\' as root in that case!
    result.root = '\\';
    return result;
  } // check for C: style root


  if (length > 1 && isWindowsDeviceName(firstCharCode) && filepath.charAt(1) === ':') {
    if (length > 2) {
      // is it like C:\\?
      const thirdCharCode = filepath.charCodeAt(2);

      if (thirdCharCode === FORWARD_SLASH || thirdCharCode === BACKWARD_SLASH) {
        result.root = filepath.slice(0, 3);
        return result;
      }
    } // nope, just C:, no trailing separator


    result.root = filepath.slice(0, 2);
  }

  return result;
}
/**
 * The `path.format()` method returns a path string from an object. This is the
 * opposite of `path.parse()`.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {object} pathObject object of format returned by `path.parse()`
 * @param  {string} pathObject.dir directory name
 * @param  {string} pathObject.root file root dir, ignored if `pathObject.dir` is provided
 * @param  {string} pathObject.base file basename
 * @param  {string} pathObject.name basename minus extension, ignored if `pathObject.base` exists
 * @param  {string} pathObject.ext file extension, ignored if `pathObject.base` exists
 * @return {string}
 */


function format(separator, pathObject) {
  assertArgumentType(pathObject, 'pathObject', 'object');
  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`; // append base to root if `dir` wasn't specified, or if
  // dir is the root

  if (!pathObject.dir || pathObject.dir === pathObject.root) {
    return `${pathObject.root || ''}${base}`;
  } // combine dir + / + base


  return `${pathObject.dir}${separator}${base}`;
}
/**
 * On Windows systems only, returns an equivalent namespace-prefixed path for
 * the given path. If path is not a string, path will be returned without modifications.
 * See https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces
 * @param  {string} filepath [description]
 * @return {string}          [description]
 */


function toNamespacedPath(filepath) {
  if (typeof filepath !== 'string') {
    return filepath;
  }

  if (filepath.length === 0) {
    return '';
  }

  const resolvedPath = resolve('\\', [filepath]);
  const length = resolvedPath.length;

  if (length < 2) {
    // need '\\\\' or 'C:' minimum
    return filepath;
  }

  const firstCharCode = resolvedPath.charCodeAt(0); // if start with '\\\\', prefix with UNC root, drop the slashes

  if (firstCharCode === BACKWARD_SLASH && resolvedPath.charAt(1) === '\\') {
    // return as-is if it's an aready long path ('\\\\?\\' or '\\\\.\\' prefix)
    if (length >= 3) {
      const thirdChar = resolvedPath.charAt(2);

      if (thirdChar === '?' || thirdChar === '.') {
        return filepath;
      }
    }

    return '\\\\?\\UNC\\' + resolvedPath.slice(2);
  } else if (isWindowsDeviceName(firstCharCode) && resolvedPath.charAt(1) === ':') {
    return '\\\\?\\' + resolvedPath;
  }

  return filepath;
}

const Win32Path = {
  sep: '\\',
  delimiter: ';',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function (...paths) {
    return join(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(false, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format(this.sep, pathObject);
  },
  toNamespacedPath: toNamespacedPath };

const PosixPath = {
  sep: '/',
  delimiter: ':',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function (...paths) {
    return join(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(true, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format(this.sep, pathObject);
  },
  toNamespacedPath: function (filepath) {
    return filepath; // no-op
  } };

const path = PosixPath;
path.win32 = Win32Path;
path.posix = PosixPath;

const PosixConstants = {
  UV_UDP_REUSEADDR: 4,
  dlopen: {},
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18 },

  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12 },

  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20 } };

// default implementations

const OS = {
  EOL: '\n',
  arch: () => process.arch,
  constants: PosixConstants,
  cpus: () => {
    const count = Ti.Platform.processorCount;
    const array = [];

    for (let i = 0; i < count; i++) {
      array.push({
        model: 'unknown',
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0 } });


    }

    return array;
  },
  endianness: () => {
    // TODO: Cache the value!
    const result = Ti.Codec.getNativeByteOrder();

    if (result === Ti.Codec.LITTLE_ENDIAN) {
      return 'LE';
    }

    return 'BE';
  },
  freemem: () => Ti.Platform.availableMemory,
  getPriority: () => 0,
  // fake it
  homedir: () => Ti.Filesystem.applicationDataDirectory,
  // fake it
  hostname: () => Ti.Platform.address,
  // fake it
  loadavg: () => [0, 0, 0],
  // fake it
  networkInterfaces: () => {},
  // FIXME: What do we do here? We might be able to piece some of this together using Ti.Platform.netmask, Ti.Platform.address
  platform: () => process.platform,
  release: () => Ti.Platform.version,
  setPriority: () => {},
  // no-op, fake it

  /**
   * The `os.tmpdir()` method returns a string specifying the operating system's default directory for temporary files.
   * @return {string} [description]
   */
  tmpdir: () => Ti.Filesystem.tempDirectory,

  /**
   * The `os.totalmem()` method returns the total amount of system memory in bytes as an integer.
   * @return {integer} [description]
   */
  totalmem: () => Ti.Platform.totalMemory,
  type: () => 'Unknown',
  // overridden per-platform at bottom

  /**
   * The `os.uptime()` method returns the system uptime in number of seconds.
   * @return {integer} [description]
   */
  uptime: () => Ti.Platform.uptime,
  userInfo: () => {
    // fake it!
    return {
      uid: -1,
      gid: -1,
      username: Ti.Platform.username,
      homedir: Ti.Filesystem.applicationDataDirectory,
      shell: null };

  } };
// On specific platforms, override implementations because we don't have them
// yet and need to fake it, or to hack them
// I'm also doing this in blocks to assign implementations that don't need to consult platform
// type at runtime (hopefully speeding up execution at runtime)

{
  OS.cpus = () => Ti.Platform.cpus();

  OS.type = () => 'Linux';
}

const tty = {
  isatty: () => false,
  ReadStream: () => {
    throw new Error('tty.ReadStream is not implemented');
  },
  WriteStream: () => {
    throw new Error('tty.WriteStream is not implemented');
  } };


const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const util = {
  format: format$1,
  formatWithOptions,
  inspect,
  isArray: Array.isArray,
  isBoolean: value => typeof value === 'boolean',
  isBuffer: BufferModule.Buffer.isBuffer,
  isFunction: value => typeof value === 'function',
  isNull: value => value === null,
  isNullOrUndefined: value => value === undefined || value === null,
  isNumber: value => typeof value === 'number',
  isObject: value => value !== null && typeof value === 'object',
  isPrimitive: value => typeof value !== 'object' && typeof value !== 'function' || value === null,
  isString: value => typeof value === 'string',
  isSymbol: value => typeof value === 'symbol',
  isUndefined: value => value === undefined,
  isRegExp: isRegExp,
  isDate: isDate,
  isError: e => Object.prototype.toString.call(e) === '[object Error]' || e instanceof Error,
  log: string => {
    const date = new Date();
    const time = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`; // Produces output like: "21 Feb 10:04:23 - message"

    console.log(`${date.getDate()} ${MONTHS[date.getMonth()]} ${time} - ${string}`);
  },
  print: (...args) => console.log(args.join('')),
  // FIXME: Shouldn't add trailing newline like console.log does!
  puts: (...args) => console.log(args.join('\n')),
  error: (...args) => console.error(args.join('\n')),
  debug: string => console.error(`DEBUG: ${string}`),
  types };

/**
 * @param {Function} constructor subclass
 * @param {Function} superConstructor base class
 * @returns {void}
 */

util.inherits = function (constructor, superConstructor) {
  assertArgumentType(constructor, 'constructor', 'Function');
  assertArgumentType(superConstructor, 'superConstructor', 'Function');
  assertArgumentType(superConstructor.prototype, 'superConstructor.prototype', 'Object');
  Object.defineProperty(constructor, 'super_', {
    value: superConstructor });

  Object.setPrototypeOf(constructor.prototype, superConstructor.prototype);
};
/**
 * @param {Function} original original function to wrap which is expected to have a final callback argument
 * @returns {Function} function that returns a Promise
 */


util.promisify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped(...args) {
    return new Promise((resolve, reject) => {
      original.call(this, ...args, (err, result) => {
        if (err) {
          return reject(err);
        }

        return resolve(result);
      });
    });
  } // TODO: Copy properties from original to wrapped
  // TODO: hook prototype chain up from wrapped to original
  // TODO: Support custom promisify hooks


  return wrapped;
};
/**
 * @param {Function} original original function to convert from async/Promise return value to a callback style
 * @returns {Function} wrapped function
 */


util.callbackify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped(...args) {
    const callback = args.pop();
    const promise = original.apply(this, args);
    promise.then(result => {
      // eslint-disable-line promise/always-return
      callback(null, result); // eslint-disable-line promise/no-callback-in-promise
    }).catch(err => {
      if (!err) {
        const wrappedError = new Error('Promise was rejected with falsy value');
        wrappedError.reason = err;
        err = wrappedError;
      }

      callback(err); // eslint-disable-line promise/no-callback-in-promise
    });
  }

  return wrapped;
};
/**
 * @param {Function} func function to deprecate/wrap
 * @param {string} string message to give when deprecation warning is emitted
 * @param {string} code deprecation code to use to group warnings
 * @returns {Function} wrapped function
 */


util.deprecate = function (func, string, code) {
  // eslint-disable-line no-unused-vars
  if (process.noDeprecation) {
    return func; // skip the wrapping!
  } // TODO: Support `code` argument by tracking a map of codes we've warned about


  function wrapped(...args) {
    let warned = false;

    if (!warned) {
      process.emitWarning(string, 'DeprecationWarning');
      warned = true;
    }

    return func.apply(this, args);
  }

  return wrapped;
}; // TODO: Support debuglog? What is our equivalent of process.env('NODE_DEBUG')?


const noop = () => {};

util.debuglog = () => {
  return noop;
};

const DEFAULT_MESSAGES = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:' };
// Fake enums to use internally

const COMPARE_TYPE = {
  Object: 0,
  Map: 1,
  Set: 2 };

const STRICTNESS = {
  Strict: 0,
  Loose: 1 };


class AssertionError extends Error {
  constructor(options) {
    let {
      actual,
      expected,
      message,
      operator } =
    options;

    if (!message) {
      // FIXME: Generate the rest of the message with diff of actual/expected!
      message = `${DEFAULT_MESSAGES[operator]}\n\n`;
    }

    super(message);
    this.actual = actual;
    this.expected = expected;
    this.operator = operator;
    this.generatedMessage = !message;
    this.name = 'AssertionError [ERR_ASSERTION]';
    this.code = 'ERR_ASSERTION';
  }}

// TODO: Can we define AssertStrict and AssertLoose as subclasses of a base Assert class
// that class holds impls for shared methods, subclasses override specific
// comparisons used (Object.is vs ===)?


const assert = (value, message) => assert.ok(value, message);

assert.AssertionError = AssertionError;

assert.ok = (...args) => {
  const value = args[0];

  if (value) {
    return;
  }

  let message = args[1];
  let generatedMessage = false; // Check if value (1st arg) was not supplied!
  // Have to use ugly hack on args definition to do so

  if (args.length === 0) {
    message = 'No value argument passed to `assert.ok()`';
    generatedMessage = true;
  } else if (message == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    // TODO: generate rest of the message. Node actually reads the input file! The hacked browserify does not do this
    // It treates ok failing like `value == true` failing
    message = 'The expression evaluated to a falsy value:\n\n';
    generatedMessage = true;
  } else if (message instanceof Error) {
    throw message;
  }

  const err = new AssertionError({
    actual: value,
    expected: true,
    message,
    operator: '==' });

  err.generatedMessage = generatedMessage;
  throw err;
};

function throwError(obj) {
  // If message is an Error object, throw that instead!
  if (obj.message instanceof Error) {
    throw obj.message;
  }

  throw new AssertionError(obj);
}

assert.equal = (actual, expected, message) => {
  if (actual == expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'equal' });

};

assert.strictEqual = (actual, expected, message) => {
  if (Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'strictEqual' });

};

assert.notEqual = (actual, expected, message) => {
  if (actual != expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notEqual' });

};

assert.notStrictEqual = (actual, expected, message) => {
  if (!Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notStrictEqual' });

};

const isPrimitive = value => {
  return typeof value !== 'object' && typeof value !== 'function' || value === null;
};
/**
 * @param {Map} actual map we are comparing
 * @param {Map} expected map we're comparing against
 * @param {STRICTNESS.Loose|strictness.Strict} strictness how to compare
 * @param {object} references memoized references to objects in the deepEqual hierarchy
 * @returns {boolean}
 */


function compareMaps(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of objects we need to test more extensively than using #get()/#has()

  for (const [key, value] of actual) {
    if (typeof key === 'object' && key !== null) {
      // non-null object. We need to do our own checking, not use get()/has()
      looseChecks.add(key);
    } else {
      // handle "primitives"
      if (expected.has(key) && deepEqual(value, expected.get(key), strictness, references)) {
        // yay! a nice easy match - both key and value matched exactly - move on
        continue;
      }

      if (strictness === STRICTNESS.Strict) {
        // if we didn't match key/value perfectly in strict mode, fail right away
        return false;
      } // ok, so it didn't match key/value perfectly - but we're in loose mode, so fall back to try again


      looseChecks.add(key);
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // only go through the second Map once!


  for (const [expectedKey, expectedValue] of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedKey === 'object' && expectedKey !== null)) {
      return false;
    } // otherwise, test it // TODO: Wish we could use #find() like on an Array, but Set doesn't have it!


    let found = false;

    for (const key of looseChecks) {
      // if both key and value matches
      if (deepEqual(key, expectedKey, strictness, references) && deepEqual(actual.get(key), expectedValue, strictness, references)) {
        found = true;
        looseChecks.delete(key); // remove from our looseChecks Set since we already matched it

        break;
      }
    } // if not found, we failed to match


    if (!found) {
      return false;
    }
  } // did we leave un-matched keys? if so, fail


  return looseChecks.size === 0;
}
/**
 * @param {Set} actual map we are comparing
 * @param {Set} expected map we're comparing against
 * @param {strictness.Loose|strictness.Strict} strictness how to compare
 * @param {object} references memoized references to objects in the deepEqual hierarchy
 * @returns {boolean}
 */


function compareSets(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of values we need to test more extensively than using #has()

  for (const value of actual) {
    if (typeof value === 'object' && value !== null) {
      // non-null object. We need to do our own checking, not use has()
      looseChecks.add(value);
    } else if (!expected.has(value)) {
      // FIXME: has does "same-value-zero" check, which is like Object.is except for -0/+0 being considered equal
      // so may need to special case that here, that'd have to be in an else below (since has will return true here)
      if (strictness === STRICTNESS.Strict) {
        // failed "same-value" match for primitive in strict mode, so fail right away
        return false;
      } // When doing loose check, we need to fall back to looser check than #has(), so we can't just return false immediately here
      // add to set of values to check more thoroughly


      looseChecks.add(value);
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // Try to whittle down the loose checks set to be empty...
  // only go through the second Set once!


  for (const expectedValue of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedValue === 'object' && expectedValue !== null)) {
      return false;
    }

    let found = false;

    for (const object of looseChecks) {
      if (deepEqual(object, expectedValue, strictness, references)) {
        found = true; // found a match!

        looseChecks.delete(object); // remove from our looseChecks Set since we matched it

        break;
      }
    } // if not found, we failed to match


    if (!found) {
      return false;
    }
  } // did we leave un-matched values? if so, fail


  return looseChecks.size === 0;
}
/**
 * @param {*} actual value we are comparing
 * @param {*} expected values we're comparing against
 * @param {STRICTNESS.Strict|STRICTNESS.Loose} strictness how strict a comparison to do
 * @param {object} [references] optional object to keep track of circular references in the hierarchy
 * @param {Map<object,number>} [references.actual] mapping from objects visited (on `actual`) to their depth
 * @param {Map<object,number>} [references.expected] mapping from objects visited (on `expected`) to their depth
 * @param {number} [references.depth] The current depth of the hierarchy
 * @returns {boolean}
 */


function deepEqual(actual, expected, strictness, references) {
  // if primitives, compare using Object.is
  // This handles: null, undefined, number, string, boolean
  if (isPrimitive(actual) && isPrimitive(expected)) {
    if (strictness === STRICTNESS.Strict) {
      return Object.is(actual, expected);
    } else {
      return actual == expected; // eslint-disable-line eqeqeq
    }
  } // Now we have various objects/functions:
  // Date, Error, RegExp, Array, Map, Set, Object, Function, Arrow functions, WeakMap, DataView, ArrayBuffer, WeakSet, typed arrays
  // notably, this includes "boxed" primitives created by new Boolean(false), new String('value'), Symbol('whatever'), etc
  // Type tags of objects should be the same


  const actualTag = Object.prototype.toString.call(actual);
  const expectedTag = Object.prototype.toString.call(expected);

  if (actualTag !== expectedTag) {
    return false;
  } // [[Prototype]] of objects are compared using the Strict Equality Comparison.


  if (strictness === STRICTNESS.Strict) {
    // don't check prototype when doing "loose"
    const actualPrototype = Object.getPrototypeOf(actual);
    const expectedPrototype = Object.getPrototypeOf(expected);

    if (actualPrototype !== expectedPrototype) {
      return false;
    }
  }

  let comparison = COMPARE_TYPE.Object;

  if (util.types.isRegExp(actual)) {
    // RegExp source and flags should match
    if (!util.types.isRegExp(expected) || actual.flags !== expected.flags || actual.source !== expected.source) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isDate(actual)) {
    // Date's underlying time should match
    if (!util.types.isDate(expected) || actual.getTime() !== expected.getTime()) {
      return false;
    } // continue on to check properties...

  } else if (actual instanceof Error) {
    // Error's name and message must match
    if (!(expected instanceof Error) || actual.name !== expected.name || actual.message !== expected.message) {
      return false;
    } // continue on to check properties...

  } else if (Array.isArray(actual)) {
    // if array lengths differ, quick fail
    if (!Array.isArray(expected) || actual.length !== expected.length) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isBoxedPrimitive(actual)) {
    if (!util.types.isBoxedPrimitive(expected)) {
      return false;
    } // check that they're the same type of wrapped primitive and then call the relevant valueOf() for that type to compare them!


    if (util.types.isNumberObject(actual) && (!util.types.isNumberObject(expected) || !Object.is(Number.prototype.valueOf.call(actual), Number.prototype.valueOf.call(expected)))) {
      return false;
    } else if (util.types.isStringObject(actual) && (!util.types.isStringObject(expected) || String.prototype.valueOf.call(actual) !== String.prototype.valueOf.call(expected))) {
      return false;
    } else if (util.types.isBooleanObject(actual) && (!util.types.isBooleanObject(expected) || Boolean.prototype.valueOf.call(actual) !== Boolean.prototype.valueOf.call(expected))) {
      return false; // FIXME: Uncomment when we support BigInt cross-platform!
      // } else if (util.types.isBigIntObject(actual)
      // 	&& (!util.types.isBigIntObject(expected)
      // 		|| BigInt.prototype.valueOf.call(actual) !== BigInt.prototype.valueOf.call(expected))) {
      // 	return false;
    } else if (util.types.isSymbolObject(actual) && (!util.types.isSymbolObject(expected) || Symbol.prototype.valueOf.call(actual) !== Symbol.prototype.valueOf.call(expected))) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isSet(actual)) {
    if (!util.types.isSet(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Set; // continue on to check properties...
  } else if (util.types.isMap(actual)) {
    if (!util.types.isMap(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Map; // continue on to check properties...
  } // Now iterate over properties and compare them!


  const actualKeys = Object.keys(actual); // for an array, this will return the indices that have values

  const expectedKeys = Object.keys(expected); // and it just magically works
  // Must have same number of properties

  if (actualKeys.length !== expectedKeys.length) {
    return false;
  } // Are they the same keys? If one is missing, then no, fail right away


  if (!actualKeys.every(key => Object.prototype.hasOwnProperty.call(expected, key))) {
    return false;
  } // Don't check own symbols when doing "loose"


  if (strictness === STRICTNESS.Strict) {
    const actualSymbols = Object.getOwnPropertySymbols(actual);
    const expectedSymbols = Object.getOwnPropertySymbols(expected); // Must have same number of symbols

    if (actualSymbols.length !== expectedSymbols.length) {
      return false;
    }

    if (actualSymbols.length > 0) {
      // Have to filter them down to enumerable symbols!
      for (const key of actualSymbols) {
        const actualIsEnumerable = Object.prototype.propertyIsEnumerable.call(actual, key);
        const expectedIsEnumerable = Object.prototype.propertyIsEnumerable.call(expected, key);

        if (actualIsEnumerable !== expectedIsEnumerable) {
          return false; // they differ on whetehr symbol is enumerable, fail!
        } else if (actualIsEnumerable) {
          // it's enumerable, add to keys to check
          actualKeys.push(key);
          expectedKeys.push(key);
        }
      }
    }
  } // Avoid circular references!
  // Record map from objects to depth in the hierarchy


  if (references === undefined) {
    references = {
      actual: new Map(),
      expected: new Map(),
      depth: 0 };

  } else {
    // see if we've already recorded these objects.
    // if so, make sure they refer to same depth in object hierarchy
    const memoizedActual = references.actual.get(actual);

    if (memoizedActual !== undefined) {
      const memoizedExpected = references.expected.get(expected);

      if (memoizedExpected !== undefined) {
        return memoizedActual === memoizedExpected;
      }
    }

    references.depth++;
  } // store the object -> depth mapping


  references.actual.set(actual, references.depth);
  references.expected.set(expected, references.depth); // When comparing Maps/Sets, compare elements before custom properties

  let result = true;

  if (comparison === COMPARE_TYPE.Set) {
    result = compareSets(actual, expected, strictness, references);
  } else if (comparison === COMPARE_TYPE.Map) {
    result = compareMaps(actual, expected, strictness, references);
  }

  if (result) {
    // Now loop over keys and compare them to each other!
    for (const key of actualKeys) {
      if (!deepEqual(actual[key], expected[key], strictness, references)) {
        result = false;
        break;
      }
    }
  } // wipe the object to depth mapping for these objects now


  references.actual.delete(actual);
  references.expected.delete(expected);
  return result;
}

assert.deepStrictEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual' });

  }
};

assert.notDeepStrictEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual' });

  }
};

assert.deepEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepEqual' });

  }
};

assert.notDeepEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepEqual' });

  }
};

assert.fail = (message = 'Failed') => throwError({
  message });


const NO_EXCEPTION = {};

function execute(fn) {
  assertArgumentType(fn, 'fn', 'Function');

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION;
}

function isPromiseLike(fn) {
  return util.types.isPromise(fn) || fn && typeof fn === 'object' && typeof fn.then === 'function';
}

async function executePromise(fn) {
  let promise;
  const fnType = typeof fn;

  if (fnType === 'function') {
    promise = fn();

    if (!isPromiseLike(promise)) {
      throw new TypeError(`Expected instanceof Promise to be returned from the "fn" function but got ${typeof promise}`);
    }
  } else {
    if (!isPromiseLike(fn)) {
      throw new TypeError(`The "fn" argument must be of type Function or Promise. Received type ${fnType}`);
    }

    promise = fn;
  }

  try {
    await promise;
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION;
}

assert.throws = (fn, error, message) => {
  const actual = execute(fn);

  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'throws' });

    return;
  } // They didn't specify how to validate, so just roll with it


  if (!error) {
    return;
  }

  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.rejects = async function (asyncFn, error, message) {
  const actual = await executePromise(asyncFn);

  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'rejects' });

    return;
  } // They didn't specify how to validate, so just roll with it


  if (!error) {
    return;
  }

  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.doesNotThrow = (fn, error, message) => {
  const actual = execute(fn); // no Error, just return

  if (actual === NO_EXCEPTION) {
    return;
  } // They didn't specify how to validate, so just re-throw


  if (!error) {
    throw actual;
  } // If error matches expected, throw an AssertionError


  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}` });

    return;
  } // doesn't match, re-throw


  throw actual;
};

assert.doesNotReject = async function (fn, error, message) {
  const actual = await executePromise(fn); // no Error, just return

  if (actual === NO_EXCEPTION) {
    return;
  } // They didn't specify how to validate, so just re-throw


  if (!error) {
    throw actual;
  } // If error matches expected, throw an AssertionError


  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}` });

    return;
  } // doesn't match, re-throw


  throw actual;
};
/**
 * @param {Error} actual the actual Error generated by the wrapped function/block
 * @param {object|RegExp|Function|Error|Class} expected The value to test against the Error
 * @param {string} [message] custom message to append
 * @returns {boolean} true if the Error matches the expected value/object
 */


function checkError(actual, expected, message) {
  // What we do here depends on what `expected` is:
  // function - call it to validate
  // object - test properties against actual
  // Regexp - test against actual.toString()
  // Error type - check type matches
  // Error instance - compare properties
  if (typeof expected === 'object') {
    if (util.types.isRegExp(expected)) {
      return expected.test(actual); // does the error match the RegExp expression? if so, pass
    } // Test properties (`expected` is either a generic Object or an Error instance)


    const keys = Object.keys(expected); // If we're testing against an instance of an Error, we need to hack in name/message properties.

    if (expected instanceof Error) {
      keys.unshift('name', 'message'); // we want to compare name and message, but they're not set as enumerable on Error
    }

    for (const key of keys) {
      if (!deepEqual(actual[key], expected[key], STRICTNESS.Strict)) {
        if (!message) {
          // generate a meaningful message! Cheat by treating like equality check of values
          // then steal the message it generated
          try {
            throwError({
              actual: actual[key],
              expected: expected[key],
              operator: 'deepStrictEqual' });

          } catch (err) {
            message = err.message;
          }
        }

        throwError({
          actual,
          expected,
          message,
          operator: 'throws' });

        return false;
      }
    }

    return true; // They all matched, pass!
  } else if (typeof expected === 'function') {
    // if `expected` is a "type" and actual is an instance of that type, then pass
    if (expected.prototype != null && actual instanceof expected) {
      // eslint-disable-line no-eq-null,eqeqeq
      return true;
    } // If `expected` is a subclass of Error but `actual` wasn't an instance of it (above), fail


    if (Object.prototype.isPrototypeOf.call(Error, expected)) {
      return false;
    } // ok, let's assume what's left is that `expected` was a validation function,
    // so call it with empty `this` and single argument of the actual error we received


    return expected.call({}, actual);
  }

  return false;
}

assert.ifError = value => {
  if (value === null || value === undefined) {
    return;
  }

  throwError({
    actual: value,
    expected: null,
    message: `ifError got unwanted exception: ${value}`,
    operator: 'ifError' });

}; // Create "strict" copy which overrides "loose" methods to call strict equivalents


assert.strict = (value, message) => assert.ok(value, message); // "Copy" methods from assert to assert.strict!


Object.assign(assert.strict, assert); // Override the "loose" methods to point to the strict ones

assert.strict.deepEqual = assert.deepStrictEqual;
assert.strict.notDeepEqual = assert.notDeepStrictEqual;
assert.strict.equal = assert.strictEqual;
assert.strict.notEqual = assert.notStrictEqual; // hang strict off itself

assert.strict.strict = assert.strict;

/**
 * @param {string} [encoding='utf8'] The character encoding the `StringDecoder` will use.
 */
function StringDecoder(encoding = 'utf8') {
  this.encoding = encoding.toLowerCase();

  switch (this.encoding) {
    case 'utf8':
    case 'utf-8':
      this._impl = new Utf8StringDecoder();
      break;

    case 'ucs2':
    case 'ucs-2':
    case 'utf16-le':
    case 'utf16le':
      this._impl = new Utf16StringDecoder();
      break;

    case 'base64':
      this._impl = new Base64StringDecoder();
      break;

    default:
      this._impl = new StringDecoderImpl(this.encoding);
      break;}

}
/**
 * Returns any remaining input stored in the internal buffer as a string.
 * Bytes representing incomplete UTF-8 and UTF-16 characters will be replaced with substitution
 * characters appropriate for the character encoding.
 *
 * If the buffer argument is provided, one final call to stringDecoder.write() is performed before returning the remaining input.
 * @param {Buffer} [buffer] containing the bytes to decode.
 * @returns {string}
 */


StringDecoder.prototype.end = function end(buffer) {
  return this._impl.end(buffer);
};
/**
 * Returns a decoded string, ensuring that any incomplete multibyte characters at the end of the Buffer, or
 * TypedArray, or DataView are omitted from the returned string and stored in an internal buffer for the
 * next call to stringDecoder.write() or stringDecoder.end().
 * @param {Buffer|TypedArray|DataView} buffer containing the bytes to decode.
 * @returns {string}
 */


StringDecoder.prototype.write = function write(buffer) {
  if (typeof buffer === 'string') {
    return buffer;
  } // empty string for empty buffer


  if (buffer.length === 0) {
    return '';
  }

  return this._impl.write(buffer);
};
/**
 * This is the base class. We override parts of it for certain encodings. For ascii/hex/binary/latin1 the impl is super-easy
 */


class StringDecoderImpl {
  constructor(encoding = 'utf8') {
    this.encoding = encoding;
    this.byteCount = 0;
    this.charLength = 1;
  } // the actual underlying implementation!


  end(buffer) {
    if (buffer && buffer.length !== 0) {
      return this.write(buffer);
    }

    return '';
  }

  write(buffer) {
    if (buffer && buffer.length !== 0) {
      return buffer.toString(this.encoding); // single byte character encodings are a cinch
    }

    return ''; // no buffer, or empty
  }}

// For multi-byte encodings, let's implement some base logic...


class MultiByteStringDecoderImpl extends StringDecoderImpl {
  constructor(encoding, bytesPerChar) {
    super(encoding);
    this.incomplete = Buffer.allocUnsafe(bytesPerChar); // temporary incomplete character buffer
  }
  /**
   * @typedef {Object} IncompleteCharObject
   * @property {integer} bytesNeeded bytes missing to complete the character
   * @property {integer} charLength bytes expected to complete the character
   * @property {integer} index location in the buffer where the character starts
   */

  /**
   * Given a Buffer, sees if we have an incomplete "character" at the end of it.
   * Returns info on that:
   * - bytesNeeded: 0-3, number of bytes still remaining
   * - charLength: expected number of bytes for the incomplete character
   * - index: index in the buffer where the incomplete character begins
   * @param {Buffer} _buffer Buffer we are checking to see if it has an incompelte "character" at the end
   */


  _checkIncompleteBytes(_buffer) {
    throw new Error('subclasses must override!');
  }

  _incompleteEnd() {
    throw new Error('subclasses must override!');
  }

  _incompleteBufferEmptied() {
    // typically we reset byte count back to 0 and character length to 1
    this.byteCount = 0;
    this.charLength = 1;
  }

  end(buffer) {
    let result = super.end(buffer);

    if (this.byteCount !== 0) {
      // we have incomplete characters!
      result += this._incompleteEnd();
    }

    this._incompleteBufferEmptied(); // reset our internals to "wipe" the incomplete buffer


    return result;
  }

  write(buffer) {
    // first let's see if we had some multi-byte character we didn't finish...
    let char = '';

    if (this.byteCount !== 0) {
      // we still needed some bytes to finish the character
      // How many bytes do we still need? charLength - bytes we received
      const left = this.charLength - this.byteCount; // need 4, have 1? then we have 3 "left"

      const bytesCopied = Math.min(left, buffer.length); // copy up to that many bytes
      // copy bytes from `buffer` to our incomplete buffer

      buffer.copy(this.incomplete, this.byteCount, 0, bytesCopied);
      this.byteCount += bytesCopied; // record how many more bytes we copied...

      if (bytesCopied < left) {
        // still need more bytes to complete!
        return '';
      } // we were able to complete, yay!
      // grab the character we completed


      char = this.incomplete.slice(0, this.charLength).toString(this.encoding); // reset our counters

      this._incompleteBufferEmptied(); // do we have any bytes left in this buffer?


      if (bytesCopied === buffer.length) {
        return char; // if not, return the character we finished!
      } // we still have more bytes, so slice the buffer up


      buffer = buffer.slice(bytesCopied, buffer.length);
    } // check this buffer to see if it indicates we need more bytes?


    const incompleteCharData = this._checkIncompleteBytes(buffer);

    if (incompleteCharData.bytesNeeded === 0) {
      return char + buffer.toString(this.encoding); // no incomplete bytes, return any character we completed plus the buffer
    } // ok so the buffer holds an incomplete character at it's end


    this.charLength = incompleteCharData.charLength; // record how many bytes we need for the 'character'

    const incompleteCharIndex = incompleteCharData.index; // this is the index of the multibyte character that is incomplete
    // copy from index of incomplete character to end of buffer

    const bytesToCopy = buffer.length - incompleteCharIndex;
    buffer.copy(this.incomplete, 0, incompleteCharIndex, buffer.length);
    this.byteCount = bytesToCopy; // record how many bytes we actually copied

    if (bytesToCopy < buffer.length) {
      // buffer had bytes before the incomplete character
      // so smush any character we may have completed with any complete characters in the buffer
      return char + buffer.toString(this.encoding, 0, incompleteCharIndex);
    }

    return char; // any now-completed character that was previously incomplete, possibly empty
  }}



class Utf8StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf8', 4);
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length; // FIXME: In Node, they check the last character first!
    // And they rely on Buffer#toString() to handle injecting the '\ufffd' character for busted multi-byte sequences!
    // iOS apparently just returns undefined in that special case and
    // Android differs here because we don't work backwards from the last char
    // Can we cheat here and...
    // see https://github.com/nodejs/string_decoder/blob/master/lib/string_decoder.js#L173-L198
    // - if we see a multi-byte character start, validate the next characters are continuation chars
    // - if they're not replace the sequence with '\ufffd', treat like that multi-byte character was "completed"
    // Note that even if we do hack this, if there's some invalid multi-byte UTF-8 in the buffer that isn't at the last 3 bytes
    // then we're at the mercy of the JS engine/platform code for handling that
    // Here's someone's hack there: https://gist.github.com/oleganza/997155
    // if buffer.length >= 3, check 3rd to last byte

    if (length >= 3) {
      let charLength = checkCharLengthForUTF8(buffer[length - 3]);

      if (charLength === 4) {
        return {
          bytesNeeded: 1,
          // we have 3 last bytes, need 4th
          index: length - 3,
          charLength: 4 };

      }
    } // if buffer.length >= 2, check 2nd to last byte


    if (length >= 2) {
      let charLength = checkCharLengthForUTF8(buffer[length - 2]);

      if (charLength >= 3) {
        return {
          bytesNeeded: charLength - 2,
          // we have 2 bytes of whatever we need
          index: length - 2,
          charLength };

      }
    } // if buffer.length >= 1, check last byte


    if (length >= 1) {
      let charLength = checkCharLengthForUTF8(buffer[length - 1]);

      if (charLength >= 2) {
        return {
          bytesNeeded: charLength - 1,
          // we have 1 byte of whatever we need
          index: length - 1,
          charLength };

      }
    } // base case, no bytes needed - ends on complete character


    return {
      bytesNeeded: 0,
      index: length - 1,
      charLength: 1 };

  }

  _incompleteEnd() {
    return '\ufffd'; // we replace the missing character with a special utf8 char
  }}



class Utf16StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf16le', 4);
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 2; // ok, we have a multiple of 2 bytes

    if (modulo === 0) {
      // is the last byte a leading/high surrogate?
      const byte = buffer[buffer.length - 1];

      if (byte >= 0xD8 && byte <= 0xDB) {
        return {
          bytesNeeded: 2,
          charLength: 4,
          index: length - 2 };

      } // we're good, not a surrogate, so we have our needed 2 bytes


      return {
        bytesNeeded: 0,
        charLength: 2 };

    } // ok we have 1 byte left over, assume we need 2 to form the character


    return {
      bytesNeeded: 1,
      index: length - 1,
      charLength: 2 };

  }

  _incompleteEnd() {
    // Just write out the last N bytes, hopefully the engine can handle it for us?
    return this.incomplete.toString('utf16le', 0, this.byteCount);
  }}



class Base64StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('base64', 3);
    this.charLength = 3; // always 3!
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 3; // base64 needs 3 bytes always, so if we have that many (or a multiple), we have a complete buffer

    if (modulo === 0) {
      return {
        bytesNeeded: 0,
        charLength: 3 };

    } // ok we have 1 or 2 bytes left over


    return {
      bytesNeeded: 3 - modulo,
      // always need 3, so if we have 1 left over -> need 2
      index: length - modulo,
      charLength: 3 // always need 3
    };

  }

  _incompleteBufferEmptied() {
    this.byteCount = 0;
    this.charLength = 3; // always 3!
  }

  _incompleteEnd() {
    // Just write out the last N bytes, it should insert the '=' placeholders
    // it's not really 'missing'/'incomplete', just needs placeholder insertion
    return this.incomplete.toString('base64', 0, this.byteCount);
  }}



function checkCharLengthForUTF8(byte) {
  // 11110XXX => 1110 => 0x1E
  if (byte >> 3 === 0x1E) {
    return 4;
  } // 1110XXXX => 1110 => 0x1E


  if (byte >> 4 === 0x0E) {
    return 3;
  } // 110XXXXX => 110 => 0x06


  if (byte >> 5 === 0x06) {
    return 2;
  }

  return 1;
}

var StringDecoder$1 = {
  StringDecoder };


const printedWarnings = {};

function oneTimeWarning(key, msg) {
  if (!printedWarnings[key]) {
    console.warn(msg);
    printedWarnings[key] = true;
  }
}
/**
 * Prints a one-time warning message that we do not support the given API and performs an effective no-op
 * @param {string} moduleName name of the module/object
 * @param {string} name name of the function.property we don't support
 * @returns {Function} no-op function
 */


function unsupportedNoop(moduleName, name) {
  return () => {
    const fqn = `${moduleName}.${name}`;
    oneTimeWarning(fqn, `"${fqn}" is not supported yet on Titanium and uses a no-op fallback.`);
    return undefined;
  };
}
/**
 * @param {string} moduleName name of the module/object
 * @param {string} name name of the function.property we don't support
 * @param {Function} callback async callback we call in a quick setTimeout
 */


function asyncUnsupportedNoop(moduleName, name, callback) {
  callback = maybeCallback(callback); // enforce we have a valid callback

  unsupportedNoop(moduleName, name)();
  setTimeout(callback, 1);
} // Used to choose the buffer/chunk size when pumping bytes during copies


const COPY_FILE_CHUNK_SIZE = 8092; // what should we use here?
// Keep track of integer -> FileStream mappings

const fileDescriptors = new Map();
let fileDescriptorCount = 4; // global counter used to report file descriptor integers
// Map file system access flags to Ti.Filesystem.MODE_* constants

const FLAGS_TO_TI_MODE = new Map();
FLAGS_TO_TI_MODE.set('a', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('a+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('as+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('r', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('r+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('rs+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('w', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('w+', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx+', Ti.Filesystem.MODE_WRITE); // Common errors

const permissionDenied = (syscall, path) => makeError('EACCES', 'permission denied', -13, syscall, path);

const noSuchFile = (syscall, path) => makeError('ENOENT', 'no such file or directory', -2, syscall, path);

const fileAlreadyExists = (syscall, path) => makeError('EEXIST', 'file already exists', -17, syscall, path);

const notADirectory = (syscall, path) => makeError('ENOTDIR', 'not a directory', -20, syscall, path);

const directoryNotEmpty = (syscall, path) => makeError('ENOTEMPTY', 'directory not empty', -66, syscall, path);

const illegalOperationOnADirectory = (syscall, path) => makeError('EISDIR', 'illegal operation on a directory', -21, syscall, path);

const fs = {
  constants: {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1 } };



class Stats {
  constructor(path) {
    this._file = null;
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 0;
    this.uid = 0;
    this.gid = 0;
    this.rdev = 0;
    this.size = 0;
    this.blksize = 4096; // FIXME: https://stackoverflow.com/questions/1315311/what-is-the-block-size-of-the-iphone-filesystem

    this.blocks = 0;
    this.atimeMs = this.mtimeMs = this.ctimeMs = this.birthtimeMs = 0;
    this.atime = this.mtime = this.ctime = this.birthtime = new Date(0);

    if (path) {
      this._file = getTiFileFromPathLikeValue(path); // TODO: use lazy getters here?

      this.ctime = this.birthtime = this._file.createdAt();
      this.atime = this.mtime = this._file.modifiedAt();
      this.atimeMs = this.atime.getTime();
      this.birthtimeMs = this.birthtime.getTime();
      this.ctimeMs = this.ctime.getTime();
      this.mtimeMs = this.mtime.getTime();
      this.size = this._file.size;
      this.blocks = Math.ceil(this.size / this.blksize); // TODO: Can we fake out the mode based on the readonly/writable/executable properties?
    }
  }

  isFile() {
    return this._file.isFile();
  }

  isDirectory() {
    return this._file.isDirectory();
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isSymbolicLink() {
    return this._file.symbolicLink;
  }

  isFIFO() {
    return false;
  }

  isSocket() {
    return false;
  }}



fs.Stats = Stats;

class ReadStream {}

fs.ReadStream = ReadStream;

class WriteStream {}

fs.WriteStream = WriteStream;
/**
 * @callback statsCallback
 * @param {Error} err - Error if one occurred
 * @param {fs.Stats} stats - file stats
 */

/**
 * @param {string|URL|Buffer} path file path
 * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
 * @param {function} callback async callback
 */

fs.access = function (path, mode, callback) {
  if (typeof mode === 'function') {
    callback = mode;
    mode = fs.constants.F_OK;
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.accessSync(path, mode);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {string|URL|Buffer} path file path
 * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
 */


fs.accessSync = function (path, mode = fs.constants.F_OK) {
  // F_OK is just whether file exists or not, no permissions check
  // R_OK is read check
  // W_OK is write check
  // X_OK is execute check (acts like F_OK on Windows)
  const fileHandle = getTiFileFromPathLikeValue(path);

  if (!fileHandle.exists()) {
    throw noSuchFile('access', path);
  } // TODO: We have no means of testing if a file is readable. It's assumed all files that exist under the app are?


  if (mode & fs.constants.W_OK && !fileHandle.writable) {
    throw permissionDenied('access', path);
  }

  if (mode & fs.constants.X_OK && !fileHandle.executable && fileHandle.isFile()) {
    throw permissionDenied('access', path);
  }
};
/**
 * Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
 * @param {string|Buffer|URL|FileStream} file filepath to file
 * @param {string|Buffer} data data to append to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding='utf8'] encoding to use
 * @param {integer} [options.mode=0o666] mode to create file, if not created
 * @param {string} [options.flag='a'] file system flag
 * @param {Function} callback function to call back with error if failed
 */


fs.appendFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a' });

  fs.writeFile(file, data, options, callback);
};
/**
 * Synchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
 * @param {string|Buffer|URL|FileStream} file filepath to file
 * @param {string|Buffer} data data to append to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding='utf8'] encoding to use
 * @param {integer} [options.mode=0o666] mode to create file, if not created
 * @param {string} [options.flag='a'] file system flag
 */


fs.appendFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a' });

  fs.writeFileSync(file, data, options); // TODO: Use Ti.Filesystem.File.append() instead?
};

fs.chmod = (path, mode, callback) => asyncUnsupportedNoop('fs', 'chmod', callback);

fs.chmodSync = unsupportedNoop('fs', 'chmodSync');

fs.chown = (path, uid, gid, callback) => asyncUnsupportedNoop('fs', 'chown', callback);

fs.chownSync = unsupportedNoop('fs', 'chownSync');
/**
 * Callback for functions that can only throw errors
 *
 * @callback errorCallback
 * @param {Error} [err] - Error thrown
 */

/**
 * @param {integer} fd file descriptor
 * @param {errorCallback} callback callback function
 */

fs.close = (fd, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.closeSync(fd);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {integer} fd file descriptor
 */


fs.closeSync = fd => {
  const stream = streamForDescriptor(fd);
  stream.close();
}; // Rather than use a hack to wrap sync version in setTimeout, use actual async APIs!

/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 * @param {errorCallback} callback callback called at end of operation
 */


fs.copyFile = function (src, dest, flags, callback) {
  if (typeof flags === 'function') {
    callback = flags;
    flags = 0;
  }

  callback = maybeCallback(callback); // FIXME: I don't know why, but changing this to use Ti.Filesystem.openStream(mode, path) fails (at least on iOS)

  const srcFile = Ti.Filesystem.getFile(src);
  const srcStream = srcFile.open(Ti.Filesystem.MODE_READ);
  const destFile = Ti.Filesystem.getFile(dest);
  const destStream = destFile.open(Ti.Filesystem.MODE_WRITE);
  pipe(srcStream, destStream, callback);
};
/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 */


fs.copyFileSync = function (src, dest, flags = 0) {
  const srcFile = Ti.Filesystem.getFile(src);

  if (flags === fs.constants.COPYFILE_EXCL && fs.existsSync(dest)) {
    throw fileAlreadyExists('copyFile', dest);
  }

  if (!srcFile.copy(dest)) {
    throw new Error(`Unable to copy ${src} to ${dest}`); // FIXME: What error should we give?
  }
}; // TODO: fs.createReadStream(path, options)
// /**
//  * @param {string|Buffer|URL} path path like
//  * @param {string|object} [options] options, if a string, it's the encoding
//  * @param {string} [options.flags='r'] See support of file system flags.
//  * @param {string} [options.encoding=null] encoding
//  * @param {integer} [options.fd=null] file descriptor, if specified, `path` is ignored
//  * @param {integer} [options.mode=0o666] permissions to set if file is created
//  * @param {boolean} [options.autoClose=true] if false, file descriptor will not be closed; if true even on error it will be closed
//  * @param {integer} [options.start] start index of range of bytes to read from file
//  * @param {integer} [options.end=Infinity] end index of range of bytes to read from file
//  * @param {integer} [options.highWaterMark=64 * 1024]
//  * @returns {fs.ReadStream}
//  */
// fs.createReadStream = (path, options) => {
// 	options = mergeDefaultOptions(options, { flags: 'r', encoding: null, fd: null, mode: 0o666, autoClose: true, end: Infinity, highWaterMark: 64 * 1024 });
// 	// FIXME: If options.fd, use that in place of path!
// 	const tiFile = getTiFileFromPathLikeValue(path);
// };
// TODO: fs.createWriteStream(path, options)

/**
 * @callback existsCallback
 * @param {boolean} exists - whether path exists
 */

/**
 * @param {string} path path to check
 * @param {existsCallback} callback callback function
 * @returns {void}
 */


fs.exists = function (path, callback) {
  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(fs.existsSync(path));
  }, 1);
};
/**
 * @param {string} path path to check
 * @returns {boolean} whether a file or directory exists at that path
 */


fs.existsSync = function (path) {
  try {
    fs.accessSync(path);
    return true;
  } catch (e) {
    return false;
  }
};

fs.fchmod = (fd, mode, callback) => asyncUnsupportedNoop('fs', 'fchmod', callback);

fs.fchmodSync = unsupportedNoop('fs', 'fchmodSync');

fs.fchown = (fd, uid, gid, callback) => asyncUnsupportedNoop('fs', 'fchown', callback);

fs.fchownSync = unsupportedNoop('fs', 'fchownSync');

fs.fdatasync = (fd, callback) => asyncUnsupportedNoop('fs', 'fdatasync', callback);

fs.fdatasyncSync = unsupportedNoop('fs', 'fdatasyncSync');
/**
 * @param {integer} fd file descriptor
 * @param {object} [options] options
 * @param {boolean} [options.bigint] whether stat values should be bigint
 * @param {function} callback async callback function
 */

fs.fstat = (fd, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let stats;

    try {
      stats = fs.fstatSync(fd, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, stats);
  }, 1);
};
/**
 * @param {integer} fd file descriptor
 * @param {object} [_options] options
 * @param {boolean} [_options.bigint] whether stat values should be bigint
 * @returns {fs.Stats} stats for file descriptor
 */


fs.fstatSync = (fd, _options) => {
  const path = pathForFileDescriptor(fd);
  return fs.statSync(path);
}; // TODO: Add versions of these APIs:
// fs.fsync(fd, callback)
// fs.fsyncSync(fd)
// fs.ftruncate(fd[, len], callback)
// fs.ftruncateSync(fd[, len])
// fs.futimes(fd, atime, mtime, callback)
// fs.futimesSync(fd, atime, mtime)
// fs.lchmod(path, mode, callback)
// fs.lchmodSync(path, mode)
// fs.lchown(path, uid, gid, callback)
// fs.lchownSync(path, uid, gid)
// fs.link(existingPath, newPath, callback)
// fs.linkSync(existingPath, newPath)
// FIXME: If symbolic link we need to follow link to target to get stats! Our API doesn't support that!


fs.lstat = (path, options, callback) => fs.stat(path, options, callback);

fs.lstatSync = (path, options) => fs.statSync(path, options);
/**
 * @param {string|Buffer|URL} path file path
 * @param {string|object} [options] options
 * @param {boolean} [options.recursive=false] recursivley create dirs?
 * @param {integer} [options.mode=0o777] permissions
 * @param {errorCallback} callback async callback
 */


fs.mkdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      recursive: false,
      mode: 0o777 };

  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.mkdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null);
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 * @param {string|object} [options] options
 * @param {boolean} [options.recursive=false] recursivley create dirs?
 * @param {integer} [options.mode=0o777] permissions
 */


fs.mkdirSync = (path, options) => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (typeof options === 'number') {
    options = {
      recursive: false,
      mode: options };

  } else {
    options = mergeDefaultOptions(options, {
      recursive: false,
      mode: 0o777 });

  }

  if (!tiFile.createDirectory(options.recursive) && !options.recursive) {
    if (tiFile.exists()) {
      // already existed!
      throw fileAlreadyExists('mkdir', path);
    } // We failed, probably because we didn't ask for recursive and parent doesn't exist, so reproduce node's error


    throw noSuchFile('mkdir', path);
  }
};
/**
 * @callback tempDirCallback
 * @param {Error} err - Error if one occurred
 * @param {string} folder - generated folder name
 */

/**
 * @param {string} prefix directory name prefix
 * @param {string|object} [options] options
 * @param {string} [options.encoding='utf-8'] prefix encoding
 * @param {tempDirCallback} callback async callback
 */


fs.mkdtemp = (prefix, options, callback) => {
  assertArgumentType(prefix, 'prefix', 'string');

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8' });
  // try to be all async

  const tryMkdtemp = () => {
    const generated = randomCharacters(6, options.encoding); // generate six random characters

    const path = `${prefix}${generated}`;
    fs.mkdir(path, 0o700, err => {
      if (err) {
        if (err.code === 'EEXIST') {
          // retry!
          setTimeout(tryMkdtemp, 1);
          return;
        } // bubble up error


        callback(err);
        return;
      } // succeeded! Hurray!


      callback(null, path);
    });
  };

  setTimeout(tryMkdtemp, 1);
};
/**
 * Creates a unique temporary directory.
 * @param {string} prefix directory name prefix
 * @param {string|object} [options] options
 * @param {string} [options.encoding='utf-8'] prefix encoding
 * @returns {string} path to created directory
 */


fs.mkdtempSync = (prefix, options) => {
  assertArgumentType(prefix, 'prefix', 'string');
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8' });

  let retryCount = 0;
  const MAX_RETRIES = 100;

  while (retryCount < MAX_RETRIES) {
    const generated = randomCharacters(6, options.encoding); // generate six random characters

    const path = `${prefix}${generated}`;

    try {
      fs.mkdirSync(path, 0o700); // don't try recursive

      return path;
    } catch (e) {
      if (e.code !== 'EEXIST') {
        throw e; // bubble up error
      } // name was not unique, so retry


      retryCount++;
    }
  }

  throw new Error(`Failed to create a unique directory name with prefix ${prefix}`);
};
/**
 * @callback fileDescriptorCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} fileDescriptor - generated file descriptor
 */

/**
 * @param {string|Buffer|URL} path path to file
 * @param {string} [flags='r'] file system access flags
 * @param {integer} [mode=0o666] file mode to use when creating file
 * @param {fileDescriptorCallback} callback async callback
 */


fs.open = (path, flags, mode, callback) => {
  // flags and mode are optional, we need to handle if not supplied!
  if (typeof flags === 'function') {
    callback = flags;
    flags = 'r';
    mode = 0o666;
  } else if (typeof mode === 'function') {
    callback = mode;
    mode = 0o666;
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let fileDescriptor;

    try {
      fileDescriptor = fs.openSync(path, flags, mode);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, fileDescriptor);
  }, 1);
};
/**
 * @param {string|Buffer|URL} path path to file
 * @param {string} [flags='r'] file system access flags
 * @param {integer} [_mode=0o666] file mode to use when creating file
 * @returns {integer}
 */


fs.openSync = (path, flags = 'r', _mode = 0o666) => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.exists()) {
    // TODO: Support creating file with specific mode
    oneTimeWarning('fs.openSync.mode', 'fs.openSync\'s mode parameter is unsupported in Titanium and will be ignored');

    if (!tiFile.createFile()) {
      // Oh crap, we failed to create the file. why?
      if (!tiFile.parent.exists()) {
        // parent does not exist!
        throw noSuchFile('open', path);
      }

      throw new Error(`failed to create file at path ${path}`);
    }
  } else if (flags) {
    // file/dir exists...
    if ((flags.charAt(0) === 'w' || flags.charAt(0) === 'a') && tiFile.isDirectory()) {
      // If user is trying to write or append and it's a directory, fail
      throw illegalOperationOnADirectory('open', path);
    }

    if (flags.length > 1 && flags.charAt(1) === 'x') {
      // If user has "exclusive" flag on, fail if file already exists
      throw fileAlreadyExists('open', path);
    }
  }

  const tiMode = FLAGS_TO_TI_MODE.get(flags);

  if (tiMode === undefined) {
    // TODO: Make use of common error type/code for this once we have internal/errors.js
    const err = new TypeError(`The value "${String(flags)}" is invalid for option "flags"`);
    err.code = 'ERR_INVALID_OPT_VALUE';
    throw err;
  }

  return createFileDescriptor(path, tiFile.open(tiMode));
};
/**
 * @callback readCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} bytesRead - number of bytes read
 * @param {Buffer} buffer buffer
 */

/**
 * @param {integer} fd file descriptor
 * @param {Buffer|Ti.Buffer} buffer buffer to read into
 * @param {integer} offset the offset in the buffer to start writing at.
 * @param {integer} length integer specifying the number of bytes to read.
 * @param {integer} position where to begin reading from in the file
 * @param {readCallback} callback async callback
 */


fs.read = (fd, buffer, offset, length, position, callback) => {
  callback = maybeCallback(callback);
  const tiFileStream = streamForDescriptor(fd);

  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  } // FIXME: Allow using position argument!


  if (position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }

  tiFileStream.read(buffer.toTiBuffer(), offset, length, readObj => {
    if (!readObj.success) {
      callback(new Error(readObj.error));
      return;
    }

    callback(null, readObj.bytesProcessed, buffer);
  });
};
/**
 * @param {integer} fd file descriptor
 * @param {Buffer|Ti.Buffer} buffer buffer to read into
 * @param {integer} offset the offset in the buffer to start writing at.
 * @param {integer} length integer specifying the number of bytes to read.
 * @param {integer} _position where to begin reading from in the file
 * @returns {integer} bytes read
 */


fs.readSync = (fd, buffer, offset, length, _position) => {
  const fileStream = streamForDescriptor(fd);

  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  } // FIXME: Allow using position argument!


  if (_position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }

  return fileStream.read(buffer.toTiBuffer(), offset, length);
};
/**
 * @callback filesCallback
 * @param {Error} err - Error if one occurred
 * @param {string[]|Buffer[]|fs.Dirent[]} files - file listing
 */

/**
 * @param {string} path directory to list
 * @param {string|object} [options] optional options
 * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
 * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
 * @param {filesCallback} callback async callback
 */


fs.readdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let result;

    try {
      result = fs.readdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, result);
  }, 1);
};
/**
 * @param {string} filepath directory to list
 * @param {string|object} [options] optional options
 * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
 * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
 * @returns {string[]|Buffer[]|fs.Dirent[]}
 */


fs.readdirSync = (filepath, options) => {
  const file = getTiFileFromPathLikeValue(filepath);

  if (!file.exists()) {
    throw noSuchFile('scandir', filepath);
  }

  if (!file.isDirectory()) {
    throw notADirectory('scandir', filepath);
  }

  options = mergeDefaultOptions(options, {
    encoding: 'utf-8',
    withFileTypes: false });

  const listing = file.getDirectoryListing();

  if (options.withFileTypes === true) {
    // TODO: if options.withFileTypes === true, return fs.Dirent objects
    oneTimeWarning('fs.readdir\'s options.withFileTypes is unsupported by Titanium and strings will be returned');
  } else if (options.encoding === 'buffer') {
    return listing.map(name => Buffer.from(name));
  }

  return listing;
};
/**
 * @callback readFilePostOpenCallback
 * @param {Error} err - Error if one occurred
 * @param {Ti.Buffer} buffer
 */

/**
 * @param {integer} fileDescriptor file descriptor
 * @param {readFilePostOpenCallback} callback async callback
 */


function readFilePostOpen(fileDescriptor, callback) {
  callback = maybeCallback(callback);
  fs.fstat(fileDescriptor, (err, stats) => {
    if (err) {
      callback(err);
      return;
    }

    const fileSize = stats.size; // Create a Ti.Buffer to read into

    const buffer = Ti.createBuffer({
      length: fileSize });
    // Use Ti.Stream.readAll(sourceStream, buffer, callback) which spins off a separate thread to read in while loop!

    const sourceStream = streamForDescriptor(fileDescriptor);
    Ti.Stream.readAll(sourceStream, buffer, readAllObj => {
      if (!readAllObj.success) {
        callback(new Error(readAllObj.error));
        return;
      }

      callback(null, buffer);
    });
  });
}
/**
 * @callback readFileCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} data
 */

/**
 * Asynchronously read entire contents of file
 * @param {string|Buffer|URL|integer} path filename or file descriptor
 * @param {object|string} [options] options
 * @param {string} [options.encoding=null] encoding to use
 * @param {string} [options.flag='r'] file system flag
 * @param {readFileCallback} callback async callback
 */


fs.readFile = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      encoding: null,
      flag: 'r' };

  } else {
    options = mergeDefaultOptions(options, {
      encoding: null,
      flag: 'r' });

  }

  callback = maybeCallback(callback);
  const wasFileDescriptor = typeof path === 'number';
  let fileDescriptor = path; // may be overriden later

  /**
   * @param {Error} err possible Error
   * @param {Ti.Buffer} buffer Ti.Buffer instance
   */

  const handleBuffer = (err, buffer) => {
    if (err) {
      callback(err);
      return;
    } // fs.closeSync if it was not originally a file descriptor


    if (!wasFileDescriptor) {
      fs.closeSync(fileDescriptor);
    } // TODO: trim buffer if we didn't read full size?


    callback(null, encodeBuffer(options.encoding, buffer));
  };

  if (!wasFileDescriptor) {
    fs.open(path, options.flag, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }

      fileDescriptor = fd;
      readFilePostOpen(fd, handleBuffer);
    });
  } else {
    readFilePostOpen(path, handleBuffer);
  }
};
/**
 * Returns the contents of the path.
 * @param {string|Buffer|URL|integer} path path to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding=null] encoding to use
 * @param {string} [options.flag='r'] file system flag
 * @returns {string|Buffer} string if encoding is specified, otherwise Buffer
 */


fs.readFileSync = (path, options) => {
  options = mergeDefaultOptions(options, {
    encoding: null,
    flag: 'r' });

  const wasFileDescriptor = typeof path === 'number';
  const fileDescriptor = wasFileDescriptor ? path : fs.openSync(path, options.flag); // use default mode

  const tiFileStream = streamForDescriptor(fileDescriptor); // Just use our own API that reads full stream in

  const buffer = Ti.Stream.readAll(tiFileStream); // fs.closeSync if it was not originally a file descriptor

  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  } // TODO: trim buffer if we didn't read full size?


  return encodeBuffer(options.encoding, buffer);
}; // TODO: fs.readlink(path[, options], callback)
// TODO: fs.readlinkSync(path[, options])

/**
 * @callback realpathCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} resolvedPath the resolved path
 */

/**
 * @param {string|Buffer|URL} filepath original filepath
 * @param {object} [options] optiosn object
 * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
 * @param {realpathCallback} callback async callback
 */


fs.realpath = (filepath, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8' });

  setTimeout(() => {
    // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.
    const result = path.normalize(filepath);
    fs.exists(result, resultExists => {
      if (resultExists) {
        if (options.encoding === 'buffer') {
          return callback(null, Buffer.from(result));
        }

        return callback(null, result);
      } // this path doesn't exist, try each segment until we find first that doesn't


      const segments = result.split(path.sep); // FIXME: Drop last segment as we already know the full path doesn't exist?

      let partialFilePath = '';
      let index = 0; // handle typical case of empty first segment so we don't need to do an async setTimeout to get to first real case

      if (segments[index].length === 0) {
        index++;
      }

      setTimeout(tryPath, 1);

      function tryPath() {
        if (index >= segments.length) {
          // don't run past end of segments, throw error for resolved path
          return callback(noSuchFile(result));
        } // grab next segment


        const segment = segments[index++];

        if (segment.length === 0) {
          // if it's an empty segment...
          // try again at next index
          return setTimeout(tryPath, 1);
        } // normal case


        partialFilePath += path.sep + segment; // check if path up to this point exists...

        fs.exists(partialFilePath, partialExists => {
          if (!partialExists) {
            // nope, throw the Error
            return callback(noSuchFile('lstat', partialFilePath));
          } // try again at next depth of dir tree


          setTimeout(tryPath, 1);
        });
      }
    });
  }, 1);
};

fs.realpath.native = (path, options, callback) => {
  fs.realpath(path, options, callback);
};
/**
 * @param {string|Buffer|URL} filepath original filepath
 * @param {object} [options] options object
 * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
 * @returns {string|Buffer}
 */


fs.realpathSync = (filepath, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8' });
  // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.

  const result = path.normalize(filepath);

  if (!fs.existsSync(result)) {
    // this path doesn't exist, try each segment until we find first that doesn't
    const segments = result.split(path.sep);
    let partialFilePath = '';

    for (const segment of segments) {
      if (segment.length === 0) {
        continue;
      }

      partialFilePath += path.sep + segment;

      if (!fs.existsSync(partialFilePath)) {
        throw noSuchFile('lstat', partialFilePath);
      }
    }
  }

  if (options.encoding === 'buffer') {
    return Buffer.from(result);
  }

  return result;
};

fs.realpathSync.native = (path, options) => {
  fs.realpathSync(path, options);
};
/**
 * @param {string|Buffer|URL} oldPath source filepath
 * @param {string|Buffer|URL} newPath destination filepath
 * @param {errorCallback} callback async callback
 */


fs.rename = (oldPath, newPath, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.renameSync(oldPath, newPath);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} oldPath source filepath
 * @param {string|Buffer|URL} newPath destination filepath
 */


fs.renameSync = (oldPath, newPath) => {
  const tiFile = getTiFileFromPathLikeValue(oldPath); // src doesn't actually exist?

  if (!tiFile.exists()) {
    const err = noSuchFile('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }

  const destFile = getTiFileFromPathLikeValue(newPath);

  if (destFile.isDirectory()) {
    // dest is a directory that already exists
    const err = illegalOperationOnADirectory('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }

  let tempPath;

  if (destFile.isFile()) {
    // destination file exists, we should overwrite
    // Our APIs will fail if we try, so first let's make a backup copy and delete the the original
    tempPath = path.join(fs.mkdtempSync(path.join(Ti.Filesystem.tempDirectory, 'rename-')), path.basename(newPath));
    destFile.move(tempPath);
  }

  let success = false;

  try {
    success = tiFile.move(newPath);
  } finally {
    if (tempPath) {
      // we temporarily copied the existing destination to back it up...
      if (success) {
        // move worked, so we can wipe it away whenever...
        fs.unlink(tempPath, _err => {});
      } else {
        // move it back, because we failed!
        const tmpFile = getTiFileFromPathLikeValue(tempPath);
        tmpFile.move(newPath);
      }
    }
  }
};
/**
 * @param {string|Buffer|URL} path file path
 * @param {errorCallback} callback async callback
 */


fs.rmdir = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.rmdirSync(path);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 */


fs.rmdirSync = path => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.deleteDirectory(false)) {
    // do not delete contents!
    // we failed to delete, but why?
    // does it exist?
    if (!tiFile.exists()) {
      throw noSuchFile('rmdir', path);
    } // is it a file?


    if (tiFile.isFile()) {
      throw notADirectory('rmdir', path);
    } // is it not empty?


    const subFiles = tiFile.getDirectoryListing();

    if (subFiles && subFiles.length > 0) {
      throw directoryNotEmpty('rmdir', path);
    }
  }
};
/**
 * @param {string|Buffer|URL} path file path
 * @param {object} [options] options
 * @param {boolean} [options.bigint] whether stat values should be bigint
 * @param {statsCallback} callback async callback
 */


fs.stat = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(null, new fs.Stats(path));
  }, 1);
};
/**
 * @param {string|Buffer|URL|integer} path filepath or file descriptor
 * @param {object} [_options] options
 * @param {boolean} [_options.bigint] whether stat values should be bigint
 * @returns {fs.Stats}
 */


fs.statSync = (path, _options) => new fs.Stats(path);

fs.symlink = (target, path, type, callback) => asyncUnsupportedNoop('fs', 'symlink', callback);

fs.symlinkSync = unsupportedNoop('fs', 'symlinkSync');
/**
 * @param {string} path file path
 * @param {integer} [len=0] bytes to trim to
 * @param {errorCallback} callback async callback
 */

fs.truncate = (path, len, callback) => {
  callback = maybeCallback(callback || len);

  if (typeof len !== 'number') {
    len = 0;
  }

  if (len <= 0) {
    fs.writeFile(path, '', callback); // empty the file

    return;
  } // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it


  fs.open(path, (err, fd) => {
    if (err) {
      return callback(err);
    }

    const buffer = Buffer.alloc(len);
    fs.read(fd, buffer, 0, len, null, (err, bytesRead, buffer) => {
      if (err) {
        fs.closeSync(fd);
        return callback(err);
      }

      fs.close(fd, err => {
        if (err) {
          return callback(err);
        }

        fs.writeFile(path, buffer, callback);
      });
    });
  });
};
/**
 * @param {string} path file path
 * @param {integer} [len=0] bytes to trim to
 */


fs.truncateSync = (path, len = 0) => {
  if (len <= 0) {
    // empty the file
    fs.writeFileSync(path, '');
    return;
  } // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it


  const fd = fs.openSync(path);
  const buffer = Buffer.alloc(len);
  fs.readSync(fd, buffer, 0, len, null);
  fs.closeSync(fd);
  fs.writeFileSync(path, buffer);
};
/**
 * @param {string|Buffer|URL} path file path
 * @param {errorCallback} callback async callback
 */


fs.unlink = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.unlinkSync(path);
    } catch (err) {
      callback(err);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 * @returns {undefined}
 */


fs.unlinkSync = path => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.deleteFile()) {
    // we failed, but why?
    if (!tiFile.exists()) {
      throw noSuchFile('unlink', path);
    }

    if (tiFile.isDirectory()) {
      throw illegalOperationOnADirectory('unlink', path);
    }
  }
};

fs.unwatchFile = unsupportedNoop('fs', 'unwatchFile');

fs.utimes = (path, atime, mtime, callback) => asyncUnsupportedNoop('fs', 'utimes', callback);

fs.utimesSync = unsupportedNoop('fs', 'utimesSync');
fs.watch = unsupportedNoop('fs', 'watch');
fs.watchFile = unsupportedNoop('fs', 'watchFile');
/**
 * @param {string|Buffer|URL|integer} file file path or descriptor
 * @param {string|Buffer|TypedArray|DataView} data data to write
 * @param {object|string} [options] options, encoding if string
 * @param {string|null} [options.encoding='utf-8'] options
 * @param {object} [options.mode=0o666] options
 * @param {object} [options.flag='w'] options
 * @param {errorCallback} callback async callback
 */

fs.writeFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w' });
  // Turn into file descriptor

  const wasFileDescriptor = typeof file === 'number';
  let fileDescriptor = file; // may be overriden later

  const finish = err => {
    if (err) {
      callback(err);
      return;
    }

    if (wasFileDescriptor) {
      callback();
      return;
    } // fs.close if it was not originally a file descriptor


    fs.close(fileDescriptor, callback);
  };

  if (!wasFileDescriptor) {
    fs.open(file, options.flag, options.mode, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }

      fileDescriptor = fd;
      fs.write(fileDescriptor, data, finish);
    });
  } else {
    fs.write(fileDescriptor, data, finish);
  }
};
/**
 * @param {string|Buffer|URL|integer} file file path or descriptor
 * @param {string|Buffer|TypedArray|DataView} data data to write
 * @param {object|string} [options] options, encoding if string
 * @param {string} [options.encoding='utf-8'] options
 * @param {object} [options.mode=0o666] options
 * @param {object} [options.flag='w'] options
 */


fs.writeFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w' });
  // Turn into file descriptor

  const wasFileDescriptor = typeof file === 'number';
  const fileDescriptor = wasFileDescriptor ? file : fs.openSync(file, options.flag, options.mode); // if data is a string, make it a buffer first

  if (!Buffer.isBuffer(data)) {
    data = Buffer.from('' + data, options.encoding); // force data to be a string, handles case where it's undefined and writes 'undefined' to file!
  }

  fs.writeSync(fileDescriptor, data); // close if user didn't give us file descriptor

  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  }
};
/**
 * @callback writeTiFileStreamCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 */

/**
 * @param {Ti.Filesystem.FileStream} tiFileStream file stream
 * @param {Buffer} buffer buffer we're writing
 * @param {writeTiFileStreamCallback} callback async callback
 */


function writeTiFileStream(tiFileStream, buffer, callback) {
  callback = maybeCallback(callback);
  Ti.Stream.write(tiFileStream, buffer.toTiBuffer(), writeObj => {
    if (!writeObj.success) {
      callback(new Error(writeObj.error));
      return;
    }

    callback(null, writeObj.bytesProcessed);
  });
}
/**
 * @param {integer} fd file descriptor
 * @param {string|Buffer} buffer contents to write: Buffer or string
 * @param {integer} [offset] offset within Buffer to write; OR offset from the beginning of the file where this data should be written (if string)
 * @param {string|integer} [length] length of bytes to write if Buffer; OR expected string encoding
 * @param {writeCallback|integer} [position] offset from the beginning of the file where this data should be written (if Buffer); OR async callback if string
 * @param {writeCallback} [callback] async callback (if Buffer)
 */


fs.write = (fd, buffer, offset, length, position, callback) => {
  const isBuffer = Buffer.isBuffer(buffer);

  if (isBuffer) {
    writeBuffer(fd, buffer, offset, length, position, callback);
  } else {
    writeString(fd, buffer, offset, length, position);
  }
};
/**
 * @param {integer} fd file descriptor
 * @param {string|Buffer} buffer contents to write
 * @param {integer} [offset] offset from the beginning of the file where this data should be written
 * @param {string|integer} [length]  expected string encoding
 * @param {integer} [position] position
 * @returns {integer} number of bytes written
 */


fs.writeSync = (fd, buffer, offset, length, position) => {
  const isBuffer = Buffer.isBuffer(buffer);

  if (isBuffer) {
    return writeBufferSync(fd, buffer, offset, length);
  }

  return writeStringSync(fd, buffer, offset, length);
}; // TODO: Add FileHandle class to match Node's wrapper for file descriptors. Re-purpose our own wrapper?
// TODO: Add the fs.promises API!
// TODO: Define fs.Dirent class, which can simply wrap a Ti.Filesystem.File (and is very similar to fs.Stats!)
// Helper functions
// --------------------------------------------------------

/**
 * Tracks the pairing of the number we use to represent the file externally, the filepath it's pointing at, and the stream pointing at it.
 */


class FileDescriptor {
  constructor(number, path, stream) {
    this.path = path;
    this.number = number;
    this.stream = stream;
  }}


/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */


function pipe(srcStream, destStream, callback) {
  {
    // Android is probably better off with Ti.Stream.writeStream, less overhead back and forth the bridge
    // Though Android does support the Ti.Stream.pump/Ti.Stream.write pattern using both APIs async
    pipeViaWriteStream(srcStream, destStream, callback);
    return;
  } // iOS has some... issues with writeStream calling the callback every iteration of the loop *and* at the end
}
/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */


function pipeViaWriteStream(srcStream, destStream, callback) {
  Ti.Stream.writeStream(srcStream, destStream, COPY_FILE_CHUNK_SIZE, result => {
    if (!result.success) {
      return callback(new Error(result.error));
    } // Android will only call this at the end or error, so we can safely assume we're done here.
    // iOS will call per loop iteration, see https://jira.appcelerator.org/browse/TIMOB-27320


    callback();
  });
}
/**
 * @param {string|Buffer|URL} path file path
 * @param {Ti.Filesystem.FileStream} fileStream file stream
 * @returns {integer} file descriptor
 */


function createFileDescriptor(path, fileStream) {
  const pointer = fileDescriptorCount++; // increment global counter

  const fd = new FileDescriptor(pointer, path, fileStream);
  fileDescriptors.set(pointer, fd); // use it to refer to this file stream as the "descriptor"

  return pointer;
}
/**
 * @param {integer} fd file descriptor
 * @returns {Ti.Filesystem.FileStream} matching stream
 */


function streamForDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.stream;
}
/**
 * @param {integer} fd file descriptor
 * @returns {string} matching stream
 */


function pathForFileDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.path;
}
/**
 * Used to merge the user-supplied options with the defaults for a function. Special cases a string to be encoding.
 * @param {*} options user-supplied options
 * @param {object} defaults defaults to use
 * @return {object}
 */


function mergeDefaultOptions(options, defaults) {
  if (options === null) {
    return defaults;
  }

  const optionsType = typeof options;

  switch (optionsType) {
    case 'undefined':
    case 'function':
      return defaults;

    case 'string':
      // Use copy of defaults but with encoding set to the 'options' value!
      const merged = Object.assign({}, defaults);
      merged.encoding = options;
      return merged;

    case 'object':
      return options;

    default:
      assertArgumentType(options, 'options', 'object');
      return null;
    // should never get reached
  }
}
/**
 * Enforces that we have a valid callback function. Throws TypeError if not.
 * @param {*} cb possible callback function
 * @returns {Function}
 * @throws {TypeError}
 */


function maybeCallback(cb) {
  if (typeof cb === 'function') {
    return cb;
  }

  const err = new TypeError(`Callback must be a function. Received ${cb}`);
  err.code = 'ERR_INVALID_CALLBACK';
  throw err;
}
/**
 * returns randomly generated characters of given length 1-16
 * @param {integer} length 1 - 16
 * @param {string} [_encoding='utf8'] encoding of the string generated
 * @returns {string}
 */


function randomCharacters(length, _encoding = 'utf8') {
  // FIXME: use the encoding specified!
  return (Math.random().toString(36) + '00000000000000000').slice(2, length + 2);
}

function makeError(code, message, errno, syscall, path) {
  const error = new Error(`${code}: ${message}, ${syscall} '${path}'`);
  error.errno = errno;
  error.syscall = syscall;
  error.code = code;
  error.path = path;
  return error;
}
/**
 * @param {string} encoding what we're encoding to
 * @param {Ti.Buffer} tiBuffer Ti.Buffer instance
 * @returns {Buffer} node-compatible Buffer instance
 */


function encodeBuffer(encoding, tiBuffer) {
  switch (encoding) {
    case 'buffer':
    case null:
    case undefined:
      // In this case we're always reading a file into a Ti.Buffer
      // Wrapping Ti.Buffer is super-slow and should really only be if we're going to write to it
      // Go the faster path by converting to ArrayBuffer and wrapping that
      // TODO: Explicitly release the blob after conversion?
      return Buffer.from(tiBuffer.toBlob().toArrayBuffer());

    default:
      // here' were converting to a string based on encoding. Internally our faster Buffer impl still delegates to Ti.Buffer in most cases
      // so I don't think there's much benefit from converting to ArrayBuffer first
      return Buffer.from(tiBuffer).toString(encoding);}

}
/**
 * @param {string|Buffer|URL} path file path
 * @return {Ti.Filesystem.File}
 */


function getTiFileFromPathLikeValue(path) {
  // This is a hack that is likely to work in most cases?
  // Basically assumes Buffer is holding a utf-8 string filename/path
  // Node just copies the bytes from the buffer as-is on the native side and adds a null terminator
  if (Buffer.isBuffer(path)) {
    path = path.toString(); // assumes utf-8 string
  } // FIXME: Handle URLs! We don't have an URL shim yet, so no way to handle those yet


  assertArgumentType(path, 'path', 'string');
  return Ti.Filesystem.getFile(path);
}
/**
 * @callback writeBufferCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 * @param {Buffer} buffer - original Buffer being written
 */

/**
 * @param {integer} fd file descriptor
 * @param {Buffer} buffer contents to write
 * @param {integer} [offset] offset within Buffer to write
 * @param {integer} [length] length of bytes to write if Buffer
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {writeBufferCallback} callback async callback
 */


function writeBuffer(fd, buffer, offset, length, position, callback) {
  callback = maybeCallback(callback || position || length || offset);

  if (typeof offset !== 'number') {
    offset = 0;
  }

  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }

  if (typeof position !== 'number') {
    position = null;
  } // ok now what?


  const tiFileStream = streamForDescriptor(fd); // Make use of the buffer slice that's specified by offset/length

  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  } // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow


  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }

    callback(null, bytesProcessed, buffer);
  });
}
/**
 * @param {integer} fd file descriptor
 * @param {Buffer} buffer contents to write
 * @param {integer} [offset] offset within Buffer to write
 * @param {integer} [length] length of bytes to write if Buffer
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @returns {integer} number of bytes written
 */


function writeBufferSync(fd, buffer, offset, length, position) {
  if (typeof offset !== 'number') {
    offset = 0;
  }

  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }


  const tiFileStream = streamForDescriptor(fd); // Make use of the buffer slice that's specified by offset/length

  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  } // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow


  return tiFileStream.write(buffer.toTiBuffer());
}
/**
 * @callback writeStringCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 * @param {string} string - original string being written
 */

/**
 * @param {integer} fd file descriptor
 * @param {string} string contents to write
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {string} [encoding='utf8'] expected string encoding
 * @param {writeStringCallback} [callback] async callback
 */


function writeString(fd, string, position, encoding, callback) {
  callback = maybeCallback(callback || encoding || position); // position could be: number, function (callback)

  if (typeof position !== 'number') {
    position = null;
  } // encoding could be: function (callback) or string


  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string

  const buffer = Buffer.from(string, encoding); // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow

  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }

    callback(null, bytesProcessed, string);
  });
}
/**
 * @param {integer} fd file descriptor
 * @param {string} string contents to write
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {string} [encoding='utf8'] expected string encoding
 * @returns {integer} number of bytes written
 */


function writeStringSync(fd, string, position, encoding) {

  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string

  const buffer = Buffer.from(string, encoding); // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow

  return tiFileStream.write(buffer.toTiBuffer());
}

function Stream(_opts) {
  // FIXME: Can't call EventEmitter as a function!
  this._eventsToListeners = {};
  this._maxListeners = undefined; // EventEmitter.call(this, opts);
  // TODO: Provide more than an empty class?
}

Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter); // Use util.inherits?

function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  } // TODO: readableState?


  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') {
      this._read = options.read;
    }

    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }
  }

  Stream.call(this);
}

util.inherits(Readable, Stream);

Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

Readable.prototype._read = function (_n) {
  throw new Error('method not implemented: _read()');
};

function Writable(options) {
  const isDuplex = this instanceof Duplex;

  if (!isDuplex && !(this instanceof Writable)) {
    return new Writable(options);
  }

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') {
      this._write = options.write;
    }

    if (typeof options.writev === 'function') {
      this._writev = options.writev;
    }

    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }

    if (typeof options.final === 'function') {
      this._final = options.final;
    }
  }

  Stream.call(this);
}

util.inherits(Writable, Stream);

function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }

  Readable.call(this, options);
  Writable.call(this, options); // TODO: Provide more than an empty class!

  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }

    if (options.writable === false) {
      this.writable = false;
    }

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false; // this.once('end', onend);
    }
  }
}

util.inherits(Duplex, Readable); // Copy Writable methods to Duplex (basically the odd double-inheritance)

const writableMethods = Object.keys(Writable.prototype);

for (let i = 0; i < writableMethods.length; i++) {
  const method = writableMethods;

  if (!Duplex.prototype[method]) {
    Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }

  Duplex.call(this, options); // TODO: Provide more than an empty class!

  if (options) {
    if (typeof options.transform === 'function') {
      this._transform = options.transform;
    }

    if (typeof options.flush === 'function') {
      this._flush = options.flush;
    }
  } // When the writable side finishes, then flush out anything remaining.
  // this.on('prefinish', prefinish);

}

util.inherits(Transform, Duplex);
Stream.Stream = Stream; // legacy compat

Stream.Transform = Transform;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex; // Stream.PassThrough = PassThrough;

// Load all the node compatible core modules
register('path', path);
register('os', OS);
register('tty', tty);
register('util', util);
register('assert', assert);
register('events', EventEmitter);
register('buffer', BufferModule);
register('string_decoder', StringDecoder$1);
register('fs', fs);
register('stream', Stream); // Register require('buffer').Buffer as global

global.Buffer = BufferModule.Buffer;

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * Description:
 * This script loads all JavaScript files ending with the name "*.bootstrap.js" and then executes them.
 * The main intention of this feature is to allow JavaScript files to kick-off functionality or
 * display UI to the end-user before the "app.js" gets loaded. This feature is the CommonJS
 * equivalent to Titanium's Android module onAppCreate() or iOS module load() features.
 *
 * Use-Cases:
 * - Automatically kick-off analytics functionality on app startup.
 * - Ensure "Google Play Services" is installed/updated on app startup on Android.
 */

/**
 * Attempts to load all bootstraps from a "bootstrap.json" file created by the app build system.
 * This is an optional feature and is the fastest method of acquiring boostraps configured for the app.
 * This JSON file, if provided, must be in the same directory as this script.
 * @returns {string[]}
 * Returns an array of require() compatible strings if bootstraps were successfully loaded from JSON.
 * Returns an empty array if JSON file was found, but no bootstraps were configured for the app.
 * Returns null if JSON file was not found.
 */
function fetchScriptsFromJson() {
  const JSON_FILE_NAME = 'bootstrap.json';

  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, `ti.internal/${JSON_FILE_NAME}`);

    if (jsonFile.exists()) {
      const settings = JSON.parse(jsonFile.read().text);

      if (Array.isArray(settings.scripts)) {
        return settings.scripts;
      }

      return [];
    }
  } catch (error) {
    Ti.API.error(`Failed to read "${JSON_FILE_NAME}". Reason: ${error.message}`);
  }

  return null;
}
/**
 * Recursively searches the "Resources" directory for all "*.bootstrap.js" files.
 * @returns {Array.<string>}
 * Returns an array of require() compatible strings for each bootstrap found in the search.
 * Returns an empty array if no bootstrap files were found.
 */


function fetchScriptsFromResourcesDirectory() {
  const resourceDirectory = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory);
  const resourceDirectoryPathLength = resourceDirectory.nativePath.length;
  const bootstrapScripts = [];

  function loadFrom(file) {
    if (file) {
      if (file.isDirectory()) {
        // This is a directory. Recursively look for bootstrap files under it.
        const fileNameArray = file.getDirectoryListing();

        if (fileNameArray) {
          for (let index = 0; index < fileNameArray.length; index++) {
            loadFrom(Ti.Filesystem.getFile(file.nativePath, fileNameArray[index]));
          }
        }
      } else if (file.name.search(/.bootstrap.js$/) >= 0) {
        // This is a bootstrap file.
        // Convert its path to something loadable via require() and add it to the array.
        let bootstrapPath = file.nativePath;
        bootstrapPath = bootstrapPath.substr(resourceDirectoryPathLength, bootstrapPath.length - resourceDirectoryPathLength - '.js'.length);
        bootstrapScripts.push(bootstrapPath);
      }
    }
  }

  loadFrom(resourceDirectory);
  return bootstrapScripts;
}
/**
 * Non-blocking function which loads and executes all bootstrap scripts configured for the app.
 * @param {function} finished Callback to be invoked once all bootstraps have finished executing. Cannot be null.
 */


function loadAsync(finished) {
  // Acquire an array of all bootstrap scripts included with the app.
  // - For best performance, attempt to fetch scripts via an optional JSON file created by the build system.
  // - If JSON file not found (will return null), then search "Resources" directory for bootstrap files.
  let bootstrapScripts = fetchScriptsFromJson();

  if (!bootstrapScripts) {
    bootstrapScripts = fetchScriptsFromResourcesDirectory();
  } // Do not continue if no bootstraps were found.


  if (!bootstrapScripts || bootstrapScripts.length <= 0) {
    finished();
    return;
  } // Sort the bootstraps so that they'll be loaded in a consistent order between platforms.


  bootstrapScripts.sort(); // Loads all bootstrap scripts found.

  function loadBootstrapScripts(finished) {
    let bootstrapIndex = 0;

    function doLoad() {
      // Attempt to load all bootstrap scripts.
      while (bootstrapIndex < bootstrapScripts.length) {
        // Load the next bootstrap.
        const fileName = bootstrapScripts[bootstrapIndex];

        const bootstrap = require(fileName); // eslint-disable-line security/detect-non-literal-require
        // Invoke the bootstrap's execute() method if it has one. (This is optional.)
        // We must wait for the given callback to be invoked before loading the next script.
        // Note: This is expected to be used to display UI to the end-user.


        if (bootstrap.execute) {
          bootstrap.execute(onBootstrapExecutionFinished);
          return;
        } // We're done with the current bootstrap. Time to load the next one.


        bootstrapIndex++;
      } // Invoke given callback to inform caller that all loading is done.


      finished();
    }

    function onBootstrapExecutionFinished() {
      // Last bootstrap has finished execution. Time to load the next one.
      // Note: Add a tiny delay so whatever UI the last bootstrap loaded has time to close.
      bootstrapIndex++;
      setTimeout(() => doLoad(), 1);
    }

    doLoad();
  } // We've finished loading/executing all bootstrap scripts.
  // Inform caller by invoking the callback given to loadAsync().


  loadBootstrapScripts(finished);
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * This script is loaded on app startup on all platforms. It is used to do the following:
 * - Provide consistent startup behavior between platforms, such as logging Titanium version.
 * - Load Titanium's core JavaScript extensions shared by all platforms.
 * - Provide "*.bootstrap.js" script support. (Similar to native module onAppCreate()/load() support.)
 * - Load the app developer's main "app.js" script after doing all of the above.
 */

Ti.API.info(`${Ti.App.name} ${Ti.App.version} (Powered by Titanium ${"10.0.0"}.${"416af89b8f"})`); // Load JS language polyfills
loadAsync(function () {
  // We've finished loading/executing all bootstrap scripts.
  // We can now proceed to run the main "app.js" script.
  require('./app'); // This event is to be fired after "app.js" execution. Reasons:
  // - Allow system to queue startup related events until "app.js" has had a chance to add listeners.
  // - For Alloy apps, we now know that Alloy has been initialized and its globals were added.


  Ti.App.fireEvent('started');
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRpLm1haW4uanMiXSwibmFtZXMiOlsiX2ludGVyb3BOYW1lc3BhY2UiLCJlIiwiX19lc01vZHVsZSIsIm4iLCJPYmplY3QiLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicmVxdWlyZSIsImNhdGNoIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImRlZmluZVByb3BlcnRpZXMiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiT1NfVkVSU0lPTl9NQUpPUiIsIlRpIiwiUGxhdGZvcm0iLCJ2ZXJzaW9uTWFqb3IiLCJPU19WRVJTSU9OX01JTk9SIiwidmVyc2lvbk1pbm9yIiwiT1NfVkVSU0lPTl9QQVRDSCIsInZlcnNpb25QYXRjaCIsImtOb2RlTW9kdWxlc1JFIiwiY3VzdG9tSW5zcGVjdFN5bWJvbCIsIlN5bWJvbCIsImZvciIsImlzQnVmZmVyIiwiY29sb3JSZWdFeHAiLCJyZW1vdmVDb2xvcnMiLCJzdHIiLCJyZXBsYWNlIiwiaXNFcnJvciIsImlzTmF0aXZlRXJyb3IiLCJFcnJvciIsImdldFN0cnVjdHVyZWRTdGFjayIsIlN0YWNrVHJhY2VFcnJvciIsInByZXBhcmVTdGFja1RyYWNlIiwiZXJyIiwidHJhY2UiLCJzdGFja1RyYWNlTGltaXQiLCJJbmZpbml0eSIsImlzSW5zaWRlTm9kZU1vZHVsZXMiLCJ1bmRlZmluZWQiLCJzdGFjayIsInN0YWNrRnJhbWVzIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJsaW5lSW5mbyIsIm1hdGNoIiwiZmlsZW5hbWUiLCJwdXNoIiwiZ2V0RmlsZU5hbWUiLCJBcnJheSIsImlzQXJyYXkiLCJmcmFtZSIsInRlc3QiLCJqb2luJDEiLCJvdXRwdXQiLCJzZXBhcmF0b3IiLCJsZW5ndGgiLCJsYXN0SW5kZXgiLCJpIiwidW5jdXJyeVRoaXMiLCJmIiwiY2FsbCIsImFwcGx5IiwiYXJndW1lbnRzIiwiQUxMX1BST1BFUlRJRVMkMiIsIk9OTFlfRU5VTUVSQUJMRSQyIiwicHJvcGVydHlGaWx0ZXIiLCJBTExfUFJPUEVSVElFUyIsIk9OTFlfRU5VTUVSQUJMRSIsImdldE93bk5vbkluZGV4UHJvcGVydGllcyIsIm9iaiIsImZpbHRlciIsInByb3BzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleSIsImlzQWxsRGlnaXRzIiwicyIsImNvZGUiLCJjaGFyQ29kZUF0IiwiVHlwZWRBcnJheVByb3RvdHlwZSQxIiwiZ2V0UHJvdG90eXBlT2YiLCJVaW50OEFycmF5IiwicHJvdG90eXBlIiwiVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJpc09iamVjdCIsImlzRnVuY3Rpb24iLCJjaGVja1Byb3RvdHlwZSIsIm5hbWUiLCJ0b1N0cmluZyIsImlzQW55QXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNBcnJheUJ1ZmZlclZpZXciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImlzQXN5bmNGdW5jdGlvbiIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc0Jvb2xlYW5PYmplY3QiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzU3ltYm9sT2JqZWN0IiwiaXNEYXRhVmlldyIsImlzRGF0ZSIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiaXNHZW5lcmF0b3JPYmplY3QiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzTWFwIiwiaXNNYXBJdGVyYXRvciIsImNvbnN0cnVjdG9yIiwiaW5jbHVkZXMiLCJpc1Byb21pc2UiLCJpc1JlZ0V4cCIsImlzU2V0IiwiaXNTZXRJdGVyYXRvciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiaXNUeXBlZEFycmF5IiwiaXNCdWlsdEluVHlwZWRBcnJheSIsImlzVWludDhBcnJheSIsImlzVWludDhDbGFtcGVkQXJyYXkiLCJpc1VpbnQxNkFycmF5IiwiaXNVaW50MzJBcnJheSIsImlzV2Vha01hcCIsImlzV2Vha1NldCIsInR5cGVzIiwiX19wcm90b19fIiwiZXJyb3IiLCJsYXp5RXJyb3IiLCJjb2RlcyIsIkVSUl9JTlRFUk5BTF9BU1NFUlRJT04iLCJhc3NlcnQkMSIsIm1lc3NhZ2UiLCJmYWlsIiwibWVzc2FnZXMiLCJNYXAiLCJTeXN0ZW1FcnJvciIsIkUiLCJzeW0iLCJ2YWwiLCJkZWYiLCJvdGhlckNsYXNzZXMiLCJzZXQiLCJtYWtlTm9kZUVycm9yV2l0aENvZGUiLCJjbGF6eiIsIkJhc2UiLCJOb2RlRXJyb3IiLCJhcmdzIiwiZ2V0TWVzc2FnZSIsImNvbmZpZ3VyYWJsZSIsImFkZENvZGVUb05hbWUiLCJtc2ciLCJleHBlY3RlZExlbmd0aCIsInVuc2hpZnQiLCJmb3JtYXQkMSIsIlJhbmdlRXJyb3IiLCJzdWZmaXgiLCJleHBlY3RlZCIsImFjdHVhbCIsImRldGVybWluZXIiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJvbmVPZiIsInR5cGUiLCJUeXBlRXJyb3IiLCJtYXhTdGFja19FcnJvck5hbWUiLCJtYXhTdGFja19FcnJvck1lc3NhZ2UiLCJpc1N0YWNrT3ZlcmZsb3dFcnJvciIsIm92ZXJmbG93U3RhY2siLCJ0aGluZyIsImxlbiIsIm1hcCIsIlN0cmluZyIsInNsaWNlIiwiam9pbiIsIkZhc3RCdWZmZXIiLCJzdHJpbmdUb0hleEJ5dGVzIiwiYnl0ZUFycmF5IiwibnVtZXJpY1ZhbHVlIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJOdW1iZXIiLCJpc05hTiIsImFycmF5SW5kZXhIYW5kbGVyIiwidGFyZ2V0IiwicHJvcEtleSIsInJlY2VpdmVyIiwibnVtIiwiaXNTYWZlSW50ZWdlciIsImdldEFkanVzdGVkSW5kZXgiLCJSZWZsZWN0Iiwic2V0QWRqdXN0ZWRJbmRleCIsImhhcyIsIl90aUJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJ0aUJ1ZmZlciIsInN0YXJ0IiwiYnl0ZU9mZnNldCIsImZyb21UaUJ1ZmZlciIsIlByb3h5IiwiZnJvbVN0cmluZyIsImVuY29kaW5nIiwiQnVmZmVyIiwiaXNFbmNvZGluZyIsInRvTG93ZXJDYXNlIiwiYmxvYiIsIlV0aWxzIiwiYmFzZTY0ZGVjb2RlIiwiYmxvYlN0cmVhbSIsIlN0cmVhbSIsImNyZWF0ZVN0cmVhbSIsInNvdXJjZSIsIm1vZGUiLCJNT0RFX1JFQUQiLCJidWZmZXIiLCJyZWFkQWxsIiwiY2xvc2UiLCJieXRlcyIsImNyZWF0ZUJ1ZmZlciIsImdldFRpQ29kZWNDaGFyc2V0IiwiZnJvbSIsIl9zbGljZSIsIm9mZnNldCIsIl9maWxsIiwiZW5kIiwidmFsdWVUeXBlIiwiYnVmVG9GaWxsV2l0aCIsImZpbGxCdWZMZW5ndGgiLCJmaWxsIiwiZmlsbENoYXIiLCJpbmRleCIsInNyYyIsIm51bUJ5dGVzIiwidG9UaUJ1ZmZlciIsImNsb25lIiwiYnVmIiwiVElfQ09ERUNfTUFQIiwiQ29kZWMiLCJDSEFSU0VUX1VURjgiLCJDSEFSU0VUX1VURjE2TEUiLCJDSEFSU0VUX0lTT19MQVRJTl8xIiwiQ0hBUlNFVF9BU0NJSSIsIkFMTF9QUk9QRVJUSUVTJDEiLCJPTkxZX0VOVU1FUkFCTEUkMSIsIlZBTElEX0VOQ09ESU5HUyIsImRvdWJsZUFycmF5IiwiRmxvYXQ2NEFycmF5IiwidWludDhEb3VibGVBcnJheSIsImZsb2F0QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJ1aW50OEZsb2F0QXJyYXkiLCJCdWZmZXIkMSIsInBvb2xTaXplIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImFwaU5hbWUiLCJzaG93RmxhZ2dlZERlcHJlY2F0aW9uIiwiYWxsb2MiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXkiLCJmcm9tQnVmZmVyIiwibWF4TGVuZ3RoIiwiYnl0ZUxlbmd0aCIsIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsInRvQXJyYXlCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImNvcHkiLCJzZXRQcm90b3R5cGVPZiIsImNvbXBhcmUiLCJ0YXJnZXRTdGFydCIsInRhcmdldEVuZCIsInNvdXJjZVN0YXJ0Iiwic291cmNlRW5kIiwiYnVmMSIsInNvdXJjZUxlbmd0aCIsImRlc3QiLCJkZXN0TGVuZ3RoIiwiTWF0aCIsIm1pbiIsInRhcmdldFZhbHVlIiwic291cmNlVmFsdWUiLCJyZW1haW5pbmciLCJzb3VyY2VMZW4iLCJlbnRyaWVzIiwibmV4dEluZGV4IiwiZW50cnlJdGVyYXRvciIsIm5leHQiLCJyZXN1bHQiLCJkb25lIiwiaXRlcmF0b3IiLCJlcXVhbHMiLCJvdGhlckJ1ZmZlciIsIm9mZnNldFR5cGUiLCJUeXBlZEFycmF5UHJvdG90eXBlIiwiVHlwZWRBcnJheVByb3RvX2J5dGVMZW5ndGgiLCJUeXBlZEFycmF5RmlsbCIsImJ5dGVMZW4iLCJmaWxsTGVuZ3RoIiwiaW5kZXhPZiIsIm1hdGNoTGVuZ3RoIiwiY3VycmVudEluZGV4IiwidGhpc0xlbmd0aCIsImZpcnN0TWF0Y2giLCJmaXJzdEJ5dGVNYXRjaCIsIngiLCJteUl0ZXJhdG9yIiwicmVhZERvdWJsZUJFIiwiY2hlY2tPZmZzZXQiLCJyZWFkRG91YmxlTEUiLCJyZWFkRmxvYXRCRSIsInJlYWRGbG9hdExFIiwicmVhZEludDgiLCJ1bnNpZ25lZFZhbHVlIiwicmVhZFVJbnQ4IiwidW5zaWduZWRUb1NpZ25lZCIsInJlYWRJbnQxNkJFIiwicmVhZFVJbnQxNkJFIiwicmVhZEludDE2TEUiLCJyZWFkVUludDE2TEUiLCJyZWFkSW50MzJCRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnQzMkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZEludEJFIiwicmVhZFVJbnRCRSIsInJlYWRJbnRMRSIsInJlYWRVSW50TEUiLCJtdWx0aXBsaWVyIiwic3ViYXJyYXkiLCJzd2FwMTYiLCJmaXJzdCIsInNlY29uZCIsInN3YXAzMiIsInRoaXJkIiwiZm91cnRoIiwic3dhcDY0IiwiZmlmdGgiLCJzaXh0aCIsInNldmVudGgiLCJlaWdodGgiLCJ0b0pTT04iLCJkYXRhIiwiYmFzZTY0ZW5jb2RlIiwidG9CbG9iIiwiaGV4U2xpY2UiLCJsYXRpbjFTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhc2NpaSIsInVjczJTbGljZSIsImhleFN0ciIsImhleCIsIm91dCIsImJ5dGUxIiwiYnl0ZTIiLCJjb2RlX3VuaXQiLCJmcm9tQ29kZVBvaW50IiwiY29weUJ1ZmZlciIsInNyY0xlbmd0aCIsImRlc3RJbmRleCIsInZhbHVlcyIsIndyaXRlIiwic3RyaW5nIiwid3JpdGVEb3VibGVCRSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUludDgiLCJjaGVja1ZhbHVlIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQzMkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnRCRSIsIm1pbk1heEJhc2UiLCJwb3ciLCJieXRlVmFsdWUiLCJ3cml0ZUludExFIiwid3JpdGVVSW50OCIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludExFIiwiYWxsb2NVbnNhZmVTbG93IiwidXRmOEJ5dGVMZW5ndGgiLCJjaGFyQXQiLCJmbG9vciIsImJ1ZjIiLCJjb25jYXQiLCJsaXN0IiwidG90YWxMZW5ndGgiLCJwb3NpdGlvbiIsIklOU1BFQ1RfTUFYX0JZVEVTIiwicmVjdXJzZVRpbWVzIiwiY3R4IiwibWF4IiwiYWN0dWFsTWF4IiwidHJpbSIsImV4dHJhcyIsInNob3dIaWRkZW4iLCJyZWR1Y2UiLCJpbnNwZWN0IiwiYnJlYWtMZW5ndGgiLCJjb21wYWN0IiwiQXJyYXlCdWZmZXJJc1ZpZXciLCJCdWZmZXJNb2R1bGUiLCJ0cmFuc2NvZGUiLCJfc291cmNlIiwiX2Zyb21FbmNvZGluZyIsIl90b0VuY29kaW5nIiwia01heExlbmd0aCIsImtTdHJpbmdNYXhMZW5ndGgiLCJjb25zdGFudHMiLCJNQVhfTEVOR1RIIiwiTUFYX1NUUklOR19MRU5HVEgiLCJzaW5nbGVCeXRlIiwiYml0TGVuZ3RoIiwibWF4UG9zaXRpdmVWYWx1ZSIsIm1heFVuc2lnbmVkVmFsdWUiLCJyZWxlYXNlIiwiZW5kT2Zmc2V0IiwiYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkIiwibm9kZU1vZHVsZXNDaGVja0NvdW50ZXIiLCJidWZmZXJXYXJuaW5nIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiQm9vbGVhblByb3RvdHlwZSIsIkJvb2xlYW4iLCJEYXRlUHJvdG90eXBlIiwiRGF0ZSIsIkVycm9yUHJvdG90eXBlIiwiTnVtYmVyUHJvdG90eXBlIiwiTWFwUHJvdG90eXBlIiwiUmVnRXhwUHJvdG90eXBlIiwiUmVnRXhwIiwiU3RyaW5nUHJvdG90eXBlIiwiU2V0UHJvdG90eXBlIiwiU2V0IiwiU3ltYm9sUHJvdG90eXBlIiwiaXNJb3MiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJidWlsdEluT2JqZWN0cyIsImluc3BlY3REZWZhdWx0T3B0aW9ucyIsInNlYWwiLCJkZXB0aCIsImNvbG9ycyIsImN1c3RvbUluc3BlY3QiLCJzaG93UHJveHkiLCJtYXhBcnJheUxlbmd0aCIsInNvcnRlZCIsImdldHRlcnMiLCJrT2JqZWN0VHlwZSIsImtBcnJheVR5cGUiLCJrQXJyYXlFeHRyYXNUeXBlIiwic3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwIiwic3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHBTaW5nbGUiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlclNpbmdsZSIsImtleVN0clJlZ0V4cCIsIm51bWJlclJlZ0V4cCIsIm5vZGVNb2R1bGVzUmVnRXhwIiwia01pbkxpbmVMZW5ndGgiLCJrV2VhayIsImtJdGVyYXRvciIsImtNYXBFbnRyaWVzIiwibWV0YSIsImdldFVzZXJPcHRpb25zIiwic3R5bGl6ZSIsInVzZXJPcHRpb25zIiwib3B0cyIsImJ1ZGdldCIsImluZGVudGF0aW9uTHZsIiwic2VlbiIsImN1cnJlbnREZXB0aCIsInN0eWxpemVOb0NvbG9yIiwib3B0S2V5cyIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsImN1c3RvbSIsIm9wdGlvbnMiLCJhc3NpZ24iLCJib2xkIiwiaXRhbGljIiwidW5kZXJsaW5lIiwiaW52ZXJzZSIsIndoaXRlIiwiZ3JleSIsImJsYWNrIiwiYmx1ZSIsImN5YW4iLCJncmVlbiIsIm1hZ2VudGEiLCJyZWQiLCJ5ZWxsb3ciLCJzdHlsZXMiLCJzcGVjaWFsIiwibnVtYmVyIiwiYmlnaW50IiwiYm9vbGVhbiIsIm51bGwiLCJzeW1ib2wiLCJkYXRlIiwicmVnZXhwIiwibW9kdWxlIiwiYWRkUXVvdGVzIiwicXVvdGVzIiwiZXNjYXBlRm4iLCJzdHJFc2NhcGUiLCJlc2NhcGVUZXN0IiwiZXNjYXBlUmVwbGFjZSIsInNpbmdsZVF1b3RlIiwibGFzdCIsInBvaW50Iiwic3R5bGVUeXBlIiwic3R5bGUiLCJjb2xvciIsImdldEVtcHR5Rm9ybWF0QXJyYXkiLCJnZXRDb25zdHJ1Y3Rvck5hbWUiLCJfY3R4IiwiZmlyc3RQcm90byIsImRlc2NyaXB0b3IiLCJnZXRQcmVmaXgiLCJ0YWciLCJmYWxsYmFjayIsImdldEtleXMiLCJzeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0Q3R4U3R5bGUiLCJmaW5kVHlwZWRDb25zdHJ1Y3RvciIsImNoZWNrIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJsYXp5TnVsbFByb3RvdHlwZUNhY2hlIiwiY2xhenpXaXRoTnVsbFByb3RvdHlwZSIsImNhY2hlZENsYXNzIiwiTnVsbFByb3RvdHlwZSIsIm5vUHJvdG90eXBlSXRlcmF0b3IiLCJuZXdWYWwiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZm9ybWF0UmF3IiwidHlwZWRBcnJheSIsImZvcm1hdFByaW1pdGl2ZSIsImNvbnRleHQiLCJtYXliZUN1c3RvbSIsInJldCIsInJlcGVhdCIsImNpcmN1bGFyIiwic2l6ZSIsImJhc2UiLCJmb3JtYXR0ZXIiLCJicmFjZXMiLCJub0l0ZXJhdG9yIiwiZXh0cmFzVHlwZSIsInByZWZpeCIsImZvcm1hdEFycmF5IiwiZm9ybWF0U2V0IiwiZm9ybWF0TWFwIiwiZm9ybWF0VHlwZWRBcnJheSIsImdldEl0ZXJhdG9yQnJhY2VzIiwiZm9ybWF0SXRlcmF0b3IiLCJnZXRGdW5jdGlvbkJhc2UiLCJyZWdFeHAiLCJnZXRUaW1lIiwidG9JU09TdHJpbmciLCJmb3JtYXRFcnJvciIsIm5hdGl2ZUVycm9yUHJvcHMiLCJldmVyeSIsImFycmF5VHlwZSIsImZvcm1hdEFycmF5QnVmZmVyIiwiZm9ybWF0TnVtYmVyIiwiZm9ybWF0UHJvbWlzZSIsImZvcm1hdFdlYWtTZXQiLCJmb3JtYXRXZWFrQ29sbGVjdGlvbiIsImZvcm1hdFdlYWtNYXAiLCJnZXRCb3hlZEJhc2UiLCJzcGVjaWFsSXRlcmF0b3IiLCJjb25zdHJ1Y3Rvck5hbWUiLCJmb3JtYXRQcm9wZXJ0eSIsImhhbmRsZU1heENhbGxTdGFja1NpemUiLCJyZWZlcmVuY2UiLCJwb3AiLCJjb21wYXJhdG9yIiwic29ydCIsInNwbGljZSIsInJlcyIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwibmV3TGVuZ3RoIiwiZm4iLCJ2YWx1ZU9mIiwic3RhY2tMaW5lIiwiYXRTeW1ib2xJbmRleCIsInNvdXJjZVBhdHRlcm4iLCJzeW1ib2xOYW1lIiwic291cmNlTWF0Y2giLCJmaWxlUGF0aCIsImxpbmVOdW1iZXIiLCJjb2x1bW4iLCJGaWxlc3lzdGVtIiwicmVzb3VyY2VzRGlyZWN0b3J5IiwicG9zIiwic3RhY2tTdGFydCIsIm5ld1N0YWNrIiwibm9kZU1vZHVsZSIsImV4ZWMiLCJpbmRlbnRhdGlvbiIsIl92YWx1ZSIsIl9yZWN1cnNlVGltZXMiLCJleHRyYSIsImRlc2MiLCJkaWZmIiwibGFiZWwiLCJzcCIsInRtcCIsInByaW1pdGl2ZSIsImdyb3VwQXJyYXlFbGVtZW50cyIsIm91dHB1dExlbmd0aCIsInNlcGFyYXRvclNwYWNlIiwiZGF0YUxlbiIsImFwcHJveENoYXJIZWlnaHRzIiwiYXZlcmFnZUJpYXMiLCJzcXJ0IiwiYmlhc2VkTWF4IiwiY29sdW1ucyIsInJvdW5kIiwibWF4TGluZUxlbmd0aCIsImxpbmVNYXhMZW5ndGgiLCJqIiwib3JkZXIiLCJwYWRkaW5nIiwicGFkU3RhcnQiLCJpcyIsImZvcm1hdEJpZ0ludCIsImZvcm1hdFNwZWNpYWxBcnJheSIsImVtcHR5SXRlbXMiLCJlbmRpbmciLCJ2YWxMZW4iLCJlbGVtZW50Rm9ybWF0dGVyIiwidiIsImZvcm1hdFNldEl0ZXJJbm5lciIsInN0YXRlIiwiZm9ybWF0TWFwSXRlcklubmVyIiwiX2tleXMiLCJpc0tleVZhbHVlIiwiY3VycmVudEVudHJ5IiwiaXNCZWxvd0JyZWFrTGVuZ3RoIiwibG4iLCJmb3JtYXRXaXRoT3B0aW9ucyIsImZpcnN0RXJyb3JMaW5lIiwiQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSIsInRyeVN0cmluZ2lmeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJhIiwiaW5zcGVjdE9wdGlvbnMiLCJ0ZW1wU3RyIiwibGFzdFBvcyIsIm5leHRDaGFyIiwidGVtcEFyZyIsImNvbnN0ciIsInRlbXBOdW0iLCJ0ZW1wSW50ZWdlciIsInRlbXBGbG9hdCIsInBhcnNlRmxvYXQiLCJub29wJDEiLCJsb2dUaW1lIiwibG9nRGF0YSIsInN0YXJ0VGltZSIsIl90aW1lcyIsImR1cmF0aW9uIiwibm93IiwibG9nIiwia0NvbG9ySW5zcGVjdE9wdGlvbnMiLCJrTm9Db2xvckluc3BlY3RPcHRpb25zIiwidGFibGVXYXJuZWQiLCJjcmVhdGVXcml0ZUVycm9ySGFuZGxlciIsInN0cmVhbSIsIl93cml0YWJsZVN0YXRlIiwiZXJyb3JFbWl0dGVkIiwibGlzdGVuZXJDb3VudCIsIm9uY2UiLCJDb25zb2xlIiwic3RkZXJyIiwiaWdub3JlRXJyb3JzIiwiX2FwaU1vZHVsZSIsInN0ZG91dCIsIl9zdGRvdXQiLCJfc3RkZXJyIiwiX2lnbm9yZUVycm9ycyIsIl9zdGRvdXRFcnJvckhhbmRsZXIiLCJfc3RkZXJyRXJyb3JIYW5kbGVyIiwiX2NvbG9yTW9kZSIsImNvbG9yTW9kZSIsIl9pbnNwZWN0T3B0aW9ucyIsIl9jb3VudHMiLCJfZ3JvdXBJbmRlbnQiLCJfd3JpdGVUb0NvbnNvbGUiLCJsZXZlbCIsInVzZVN0ZEVyciIsImVycm9ySGFuZGxlciIsInJlbW92ZUxpc3RlbmVyIiwiaW5mbyIsIndhcm4iLCJkZWJ1ZyIsImNsZWFyIiwiZ3JvdXAiLCJncm91cEVuZCIsImRpciIsImFzc2VydCIsImNvdW50IiwiY291bnRSZXNldCIsImRlbGV0ZSIsInRpbWUiLCJ0aW1lRW5kIiwid2FybmVkIiwidGltZUxvZyIsInRhYmxlIiwiZGlyeG1sIiwiZ3JvdXBDb2xsYXBzZWQiLCJnbG9iYWxDb25zb2xlIiwiQVBJIiwiY29uc29sZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInByb3BlcnRpZXMiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJfbWFrZVRpQ3JlYXRpb25Qcm9wZXJ0aWVzRnJvbSIsIm9sZE9wdGlvbnMiLCJkYXRlU3R5bGUiLCJtb250aCIsImRheSIsInllYXIiLCJkZWZhdWx0T3B0aW9ucyIsImxvY2FsZSIsImZvcm1hdCIsInRvTG9jYWxlVGltZVN0cmluZyIsInRpbWVTdHlsZSIsImhvdXIiLCJtaW51dGUiLCJ0b0xvY2FsZVN0cmluZyIsImhhc09wdGlvbiIsIndlZWtkYXkiLCJtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tIiwic3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uIiwic3VwcG9ydGVkTG9jYWxlcyIsIlRpQ29sbGF0b3IiLCJMb2NhbGUiLCJnZXRTdXBwb3J0ZWRDb2xsYXRvckxvY2FsZXMiLCJjb2xsYXRvciIsIkNvbGxhdG9yIiwiYmluZCIsInN1cHBvcnRlZExvY2FsZXNPZiIsIlRpRGF0ZVRpbWVGb3JtYXQiLCJnZXRTdXBwb3J0ZWREYXRlVGltZUZvcm1hdExvY2FsZXMiLCJUaU51bWJlckZvcm1hdCIsImdldFN1cHBvcnRlZE51bWJlckZvcm1hdExvY2FsZXMiLCJOdW1iZXJGb3JtYXQiLCJnZXRDYW5vbmljYWxMb2NhbGVzIiwibG9jYWxlQ29tcGFyZSIsImNvbXBhcmVTdHJpbmciLCJsb2NhbGVzIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJtYWtlTG93ZXJDYXNlIiwidG9Mb2NhbGVVcHBlckNhc2UiLCJtYWtlVXBwZXJDYXNlIiwiYmluZGluZ3MiLCJyZWRpcmVjdHMiLCJpc0hpamFja2FibGVNb2R1bGVJZCIsInBhdGgiLCJmaXJzdENoYXIiLCJvcmlnaW5hbFJlcXVpcmUiLCJtb2R1bGVJZCIsIm9yaWdpbmFsTW9kdWxlUmVxdWlyZSIsIk1vZHVsZSIsInJlZ2lzdGVyIiwiYmluZGluZyIsInJlZGlyZWN0IiwiZmlsZXBhdGgiLCJUaXRhbml1bSIsIkFjdGl2aXR5Iiwia2V5Q291bnQiLCJzZXJpYWxpemVkIiwiUHJvcGVydGllcyIsIkFwcCIsIm51bGxPckRlZmF1bHRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsInByb3BlcnR5R2V0dGVyIiwiZGVsZWdhdGUiLCJoYXNQcm9wZXJ0eSIsImdldHRlciIsImdldExpc3QiLCJnZXRPYmplY3QiLCJwYXJzZSIsImdldFN0cmluZyIsInNldExpc3QiLCJzZXRPYmplY3QiLCJzZXRTdHJpbmciLCJCbG9iUHJvdG90eXBlIiwicmVqZWN0Iiwid3JhcHBlZEdldFN0cmluZyIsImRlZmF1bHRWYWx1ZVR5cGUiLCJMIiwiUGVyc2lzdGVudEhhbmRsZSIsIm9iamVjdCIsImNlbGwiLCJsYXN0SWQiLCJvYmplY3RzIiwiZGlzcG9zZSIsIkhUVFBDbGllbnQiLCJOZXR3b3JrIiwiX3NlbmQiLCJzZW5kIiwiaGFuZGxlIiwib24iLCJrcm9sbCIsIkRCRyIsImlQaG9uZUNvbnN0YW50IiwiVUkiLCJpUGhvbmUiLCJBY3Rpdml0eUluZGljYXRvclN0eWxlIiwiQklHIiwiREFSSyIsIkFuaW1hdGlvblN0eWxlIiwiRkxJUF9GUk9NX0xFRlQiLCJQcm9ncmVzc0JhclN0eWxlIiwiU0lNUExFIiwiU3lzdGVtQnV0dG9uIiwiRkxFWElCTEVfU1BBQ0UiLCJESVNDTE9TVVJFIiwiU3lzdGVtQnV0dG9uU3R5bGUiLCJCQVIiLCJUYWJsZVZpZXdDZWxsU2VsZWN0aW9uU3R5bGUiLCJOT05FIiwiVGFibGVWaWV3U2VwYXJhdG9yU3R5bGUiLCJSb3dBbmltYXRpb25TdHlsZSIsIlRhYmxlVmlld1Njcm9sbFBvc2l0aW9uIiwiTUlERExFIiwiVGFibGVWaWV3U3R5bGUiLCJHUk9VUEVEIiwiTGlzdFZpZXciLCJkZWZhdWx0VGVtcGxhdGUiLCJoZWlnaHQiLCJjaGlsZFRlbXBsYXRlcyIsImJpbmRJZCIsImxlZnQiLCJ3aWR0aCIsInJpZ2h0IiwiY3JlYXRlTGlzdFZpZXciLCJ0ZW1wbGF0ZXMiLCJMSVNUX0lURU1fVEVNUExBVEVfREVGQVVMVCIsImN1cnJlbnRUZW1wbGF0ZSIsInByb2Nlc3NUZW1wbGF0ZSIsInByb2Nlc3NDaGlsZFRlbXBsYXRlcyIsImNlbGxQcm94eSIsImNyZWF0ZUxpc3RJdGVtIiwiZXZlbnRzIiwidGlQcm94eSIsImFkZEV2ZW50TGlzdGVuZXJzIiwiY2hpbGRQcm9wZXJ0aWVzIiwiY2hpbGQiLCJwcm94eVR5cGUiLCJjcmVhdGlvblByb3BlcnRpZXMiLCJjcmVhdGlvbkZ1bmN0aW9uIiwibG9va3VwIiwiY2hpbGRQcm94eSIsInByb3h5IiwiZXZlbnROYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxvb2t1cFByb3h5Q29uc3RydWN0b3IiLCJuYW1lc3BhY2UiLCJuYW1lc3BhY2VJbmRleCIsImxhc3RJbmRleE9mIiwicHJveHlOYW1lIiwicGFyZW50TmFtZXNwYWNlIiwic3Vic3RyaW5nIiwic2VnbWVudHMiLCJwYXJlbnRQcm94eSIsIm1ldGhvZCIsIndpZGdldCIsIm1haW4iLCJwYXJhbWV0ZXJzIiwiZ2V0VmlldyIsIk5hdmlnYXRpb25XaW5kb3ciLCJIRVhfM19SRUdFWCIsIkhFWF80X1JFR0VYIiwiSEVYXzZfUkVHRVgiLCJIRVhfOF9SRUdFWCIsInBhZGRlZEhleCIsImludGVnZXIiLCJDb2xvciIsInIiLCJnIiwiYiIsImFscGhhIiwiaXNPcGFxdWUiLCJhbHBoYUhleCIsIl90b1JHQkhleFN0cmluZyIsInRvUkdCQUhleFN0cmluZyIsInRvQVJHQkhleFN0cmluZyIsInRvSGV4IiwidG9SR0JBU3RyaW5nIiwidG9GaXhlZCIsImZyb21IZXg2U3RyaW5nIiwic3RhcnRJbmRleCIsImZyb21IZXg4U3RyaW5nIiwiZnJvbVNlbWFudGljQ29sb3JzRW50cnkiLCJlbnRyeSIsImhhZEFscGhhIiwibSIsInVzZXJJbnRlcmZhY2VTdHlsZSIsIlVTRVJfSU5URVJGQUNFX1NUWUxFX0RBUksiLCJTRU1BTlRJQ19DT0xPUl9UWVBFX0RBUksiLCJTRU1BTlRJQ19DT0xPUl9UWVBFX0xJR0hUIiwiY29sb3JzZXQiLCJmZXRjaFNlbWFudGljQ29sb3IiLCJjb2xvck5hbWUiLCJjb2xvcnNldEZpbGVOYW1lIiwiY29sb3JzZXRGaWxlIiwiZ2V0RmlsZSIsImV4aXN0cyIsImNvbG9yQXJyYXkiLCJjb2xvclR5cGUiLCJjb2xvck9iaiIsIkFuZHJvaWQiLCJSIiwiVGFiIiwiY3JlYXRlVGFiIiwidGFiIiwiX3dpbmRvdyIsIm9wZW4iLCJ0YWJPcGVuIiwiZ2V0V2luZG93Iiwic2V0V2luZG93IiwiX3NldFdpbmRvdyIsIlRhYkdyb3VwIiwiVmlldyIsIl9hZGQiLCJhZGQiLCJUaVdpbmRvdyIsIl9jaGlsZHJlbiIsIl9yZW1vdmUiLCJyZW1vdmUiLCJjaGlsZHJlbiIsImNoaWxkSW5kZXgiLCJUaVZpZXciLCJjcmVhdGVXZWJWaWV3IiwiY3JlYXRlV2ViVmlld1dyYXBwZXIiLCJ3ZWJWaWV3Iiwib25DcmVhdGVXaW5kb3ciLCJpc1VzZXJHZXN0dXJlIiwid2luIiwiY3JlYXRlV2luZG93IiwiZnVsbHNjcmVlbiIsIm5ld1dlYlZpZXciLCJUQUciLCJTY3JpcHQiLCJXaW5kb3ciLCJfY2FjaGVkQWN0aXZpdHlQcm94eSIsImFjdGl2aXR5UHJveHlHZXR0ZXIiLCJhY3Rpdml0eVByb3h5IiwiX2dldFdpbmRvd0FjdGl2aXR5UHJveHkiLCJnZXRBY3Rpdml0eSIsIl9vcGVuIiwiX2Nsb3NlRnJvbUFjdGl2aXR5Rm9yY2VkVG9EZXN0cm95IiwiX3VybENvbnRleHQiLCJkaXNwb3NlQ29udGV4dCIsInBvc3RXaW5kb3dDcmVhdGVkIiwiX2ludGVybmFsQWN0aXZpdHkiLCJleHRlbmQiLCJfYWRkTGlzdGVuZXIiLCJlbWl0dGVyIiwibGlzdGVuZXIiLCJwcmVwZW5kIiwiX2V2ZW50c1RvTGlzdGVuZXJzIiwibmV3TGlzdGVuZXIiLCJlbWl0IiwiZXZlbnRMaXN0ZW5lcnMiLCJnZXRNYXhMaXN0ZW5lcnMiLCJ3Iiwib25jZVdyYXAiLCJ3cmFwcGVyIiwid3JhcHBlZEZ1bmMiLCJ3cmFwcGVyVGhpcyIsImJvdW5kIiwiRXZlbnRFbWl0dGVyIiwiX21heExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImZvdW5kSW5kZXgiLCJ1bndyYXBwZWRMaXN0ZW5lciIsIm9mZiIsImV2ZW50TmFtZXMiLCJsaXN0ZW5lcnMiLCJyYXciLCJsIiwicmF3TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsInJlbW92ZUFsbExpc3RlbmVycyIsIm5hbWVzIiwiYXNzZXJ0QXJndW1lbnRUeXBlIiwidHlwZW5hbWUiLCJzdGFuZGFyZGl6ZUFyY2giLCJvcmlnaW5hbCIsInByb2Nlc3MkMSIsImFib3J0IiwiYXJjaCIsImFyY2hpdGVjdHVyZSIsImFyZ3YiLCJjaGFubmVsIiwiY2hkaXIiLCJjb25maWciLCJjb25uZWN0ZWQiLCJjcHVVc2FnZSIsInVzZXIiLCJzeXN0ZW0iLCJjd2QiLCJfX2Rpcm5hbWUiLCJhc3NldHMiLCJqc29uIiwicmVhZEFzc2V0IiwiZGVwbG95RGF0YSIsImRlYnVnZ2VyUG9ydCIsImRpc2Nvbm5lY3QiLCJkbG9wZW4iLCJ3YXJuaW5nIiwiY3RvciIsImRldGFpbCIsImlzRGVwcmVjYXRpb24iLCJub0RlcHJlY2F0aW9uIiwidGhyb3dEZXByZWNhdGlvbiIsImxvYWRFbnZKc29uIiwianNvbkZpbGUiLCJyZWFkIiwidGV4dCIsImVudiIsImV4ZWNBcmd2IiwiZXhlY1BhdGgiLCJleGl0IiwiZXhpdENvZGUiLCJwaWQiLCJwbGF0Zm9ybSIsInBwaWQiLCJpc1RUWSIsImNodW5rIiwiY2FsbGJhY2siLCJ0aXRsZSIsInRyYWNlRGVwcmVjYXRpb24iLCJ1bWFzayIsInVwdGltZSIsImRpZmZNcyIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm1vZHVsZXMiLCJ2OCIsImpzYyIsIldBUk5JTkdfUFJFRklYIiwidW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayIsImhhc1VuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrIiwic2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2siLCJldmVudCIsImJhY2t0cmFjZSIsImZpbGVOYW1lIiwic291cmNlTmFtZSIsImNvbHVtbk51bWJlciIsImxpbmVPZmZzZXQiLCJDYWxsYmFja1dpdGhBcmdzIiwiZnVuYyIsInJ1biIsImZ1biIsInRpY2tRdWV1ZSIsImltbWVkaWF0ZVF1ZXVlIiwiZHJhaW5pbmdUaWNrUXVldWUiLCJkcmFpblF1ZXVlc1RpbWVvdXQiLCJkcmFpblRpY2tRdWV1ZSIsInRpY2siLCJzaGlmdCIsImRyYWluUXVldWVzIiwiaW1tZWRpYXRlc1JlbWFpbmluZyIsInByb2Nlc3NJbW1lZGlhdGVRdWV1ZSIsInNldFRpbWVvdXQiLCJpbW1lZGlhdGVEZWFkbGluZSIsImltbWVkaWF0ZSIsIm5leHRUaWNrIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiLCJGT1JXQVJEX1NMQVNIIiwiQkFDS1dBUkRfU0xBU0giLCJpc1dpbmRvd3NEZXZpY2VOYW1lIiwiY2hhckNvZGUiLCJpc0Fic29sdXRlIiwiaXNQb3NpeCIsInRoaXJkQ2hhciIsImRpcm5hbWUiLCJmcm9tSW5kZXgiLCJoYWRUcmFpbGluZyIsImV4dG5hbWUiLCJlbmRJbmRleCIsImxhc3RJbmRleFdpbjMyU2VwYXJhdG9yIiwiY2hhciIsImJhc2VuYW1lIiwiZXh0IiwibGFzdENoYXJDb2RlIiwibm9ybWFsaXplIiwiaXNXaW5kb3dzIiwiaGFkTGVhZGluZyIsImlzVU5DIiwicGFydHMiLCJzZWdtZW50Iiwibm9ybWFsaXplZCIsImFzc2VydFNlZ21lbnQiLCJwYXRocyIsInJlc29sdmVkIiwiaGl0Um9vdCIsInJlbGF0aXZlIiwidG8iLCJ1cENvdW50IiwicmVtYWluaW5nUGF0aCIsInJvb3QiLCJiYXNlTGVuZ3RoIiwidG9TdWJ0cmFjdCIsImZpcnN0Q2hhckNvZGUiLCJ0aGlyZENoYXJDb2RlIiwicGF0aE9iamVjdCIsInRvTmFtZXNwYWNlZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJXaW4zMlBhdGgiLCJzZXAiLCJkZWxpbWl0ZXIiLCJQb3NpeFBhdGgiLCJ3aW4zMiIsInBvc2l4IiwiUG9zaXhDb25zdGFudHMiLCJVVl9VRFBfUkVVU0VBRERSIiwiZXJybm8iLCJFMkJJRyIsIkVBQ0NFUyIsIkVBRERSSU5VU0UiLCJFQUREUk5PVEFWQUlMIiwiRUFGTk9TVVBQT1JUIiwiRUFHQUlOIiwiRUFMUkVBRFkiLCJFQkFERiIsIkVCQURNU0ciLCJFQlVTWSIsIkVDQU5DRUxFRCIsIkVDSElMRCIsIkVDT05OQUJPUlRFRCIsIkVDT05OUkVGVVNFRCIsIkVDT05OUkVTRVQiLCJFREVBRExLIiwiRURFU1RBRERSUkVRIiwiRURPTSIsIkVEUVVPVCIsIkVFWElTVCIsIkVGQVVMVCIsIkVGQklHIiwiRUhPU1RVTlJFQUNIIiwiRUlEUk0iLCJFSUxTRVEiLCJFSU5QUk9HUkVTUyIsIkVJTlRSIiwiRUlOVkFMIiwiRUlPIiwiRUlTQ09OTiIsIkVJU0RJUiIsIkVMT09QIiwiRU1GSUxFIiwiRU1MSU5LIiwiRU1TR1NJWkUiLCJFTVVMVElIT1AiLCJFTkFNRVRPT0xPTkciLCJFTkVURE9XTiIsIkVORVRSRVNFVCIsIkVORVRVTlJFQUNIIiwiRU5GSUxFIiwiRU5PQlVGUyIsIkVOT0RBVEEiLCJFTk9ERVYiLCJFTk9FTlQiLCJFTk9FWEVDIiwiRU5PTENLIiwiRU5PTElOSyIsIkVOT01FTSIsIkVOT01TRyIsIkVOT1BST1RPT1BUIiwiRU5PU1BDIiwiRU5PU1IiLCJFTk9TVFIiLCJFTk9TWVMiLCJFTk9UQ09OTiIsIkVOT1RESVIiLCJFTk9URU1QVFkiLCJFTk9UU09DSyIsIkVOT1RTVVAiLCJFTk9UVFkiLCJFTlhJTyIsIkVPUE5PVFNVUFAiLCJFT1ZFUkZMT1ciLCJFUEVSTSIsIkVQSVBFIiwiRVBST1RPIiwiRVBST1RPTk9TVVBQT1JUIiwiRVBST1RPVFlQRSIsIkVSQU5HRSIsIkVST0ZTIiwiRVNQSVBFIiwiRVNSQ0giLCJFU1RBTEUiLCJFVElNRSIsIkVUSU1FRE9VVCIsIkVUWFRCU1kiLCJFV09VTERCTE9DSyIsIkVYREVWIiwic2lnbmFscyIsIlNJR0hVUCIsIlNJR0lOVCIsIlNJR1FVSVQiLCJTSUdJTEwiLCJTSUdUUkFQIiwiU0lHQUJSVCIsIlNJR0lPVCIsIlNJR0JVUyIsIlNJR0ZQRSIsIlNJR0tJTEwiLCJTSUdVU1IxIiwiU0lHU0VHViIsIlNJR1VTUjIiLCJTSUdQSVBFIiwiU0lHQUxSTSIsIlNJR1RFUk0iLCJTSUdDSExEIiwiU0lHQ09OVCIsIlNJR1NUT1AiLCJTSUdUU1RQIiwiU0lHVFRJTiIsIlNJR1RUT1UiLCJTSUdVUkciLCJTSUdYQ1BVIiwiU0lHWEZTWiIsIlNJR1ZUQUxSTSIsIlNJR1BST0YiLCJTSUdXSU5DSCIsIlNJR0lPIiwiU0lHSU5GTyIsIlNJR1NZUyIsInByaW9yaXR5IiwiUFJJT1JJVFlfTE9XIiwiUFJJT1JJVFlfQkVMT1dfTk9STUFMIiwiUFJJT1JJVFlfTk9STUFMIiwiUFJJT1JJVFlfQUJPVkVfTk9STUFMIiwiUFJJT1JJVFlfSElHSCIsIlBSSU9SSVRZX0hJR0hFU1QiLCJPUyIsIkVPTCIsImNwdXMiLCJwcm9jZXNzb3JDb3VudCIsImFycmF5IiwibW9kZWwiLCJzcGVlZCIsInRpbWVzIiwibmljZSIsInN5cyIsImlkbGUiLCJpcnEiLCJlbmRpYW5uZXNzIiwiZ2V0TmF0aXZlQnl0ZU9yZGVyIiwiTElUVExFX0VORElBTiIsImZyZWVtZW0iLCJhdmFpbGFibGVNZW1vcnkiLCJnZXRQcmlvcml0eSIsImhvbWVkaXIiLCJhcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnkiLCJob3N0bmFtZSIsImFkZHJlc3MiLCJsb2FkYXZnIiwibmV0d29ya0ludGVyZmFjZXMiLCJzZXRQcmlvcml0eSIsInRtcGRpciIsInRlbXBEaXJlY3RvcnkiLCJ0b3RhbG1lbSIsInRvdGFsTWVtb3J5IiwidXNlckluZm8iLCJ1aWQiLCJnaWQiLCJ1c2VybmFtZSIsInNoZWxsIiwidHR5IiwiaXNhdHR5IiwiUmVhZFN0cmVhbSIsIldyaXRlU3RyZWFtIiwiTU9OVEhTIiwidXRpbCIsImlzQm9vbGVhbiIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc1ByaW1pdGl2ZSIsImlzU3RyaW5nIiwiaXNTeW1ib2wiLCJpc1VuZGVmaW5lZCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJwcmludCIsInB1dHMiLCJpbmhlcml0cyIsInN1cGVyQ29uc3RydWN0b3IiLCJwcm9taXNpZnkiLCJ3cmFwcGVkIiwiY2FsbGJhY2tpZnkiLCJwcm9taXNlIiwid3JhcHBlZEVycm9yIiwicmVhc29uIiwiZGVwcmVjYXRlIiwibm9vcCIsImRlYnVnbG9nIiwiREVGQVVMVF9NRVNTQUdFUyIsImRlZXBTdHJpY3RFcXVhbCIsInN0cmljdEVxdWFsIiwiZGVlcEVxdWFsIiwiZXF1YWwiLCJub3REZWVwU3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsIm5vdERlZXBFcXVhbCIsIm5vdEVxdWFsIiwiQ09NUEFSRV9UWVBFIiwiU1RSSUNUTkVTUyIsIlN0cmljdCIsIkxvb3NlIiwiQXNzZXJ0aW9uRXJyb3IiLCJvcGVyYXRvciIsImdlbmVyYXRlZE1lc3NhZ2UiLCJvayIsInRocm93RXJyb3IiLCJjb21wYXJlTWFwcyIsInN0cmljdG5lc3MiLCJyZWZlcmVuY2VzIiwibG9vc2VDaGVja3MiLCJleHBlY3RlZEtleSIsImV4cGVjdGVkVmFsdWUiLCJmb3VuZCIsImNvbXBhcmVTZXRzIiwiYWN0dWFsVGFnIiwiZXhwZWN0ZWRUYWciLCJhY3R1YWxQcm90b3R5cGUiLCJleHBlY3RlZFByb3RvdHlwZSIsImNvbXBhcmlzb24iLCJmbGFncyIsImFjdHVhbEtleXMiLCJleHBlY3RlZEtleXMiLCJhY3R1YWxTeW1ib2xzIiwiZXhwZWN0ZWRTeW1ib2xzIiwiYWN0dWFsSXNFbnVtZXJhYmxlIiwiZXhwZWN0ZWRJc0VudW1lcmFibGUiLCJtZW1vaXplZEFjdHVhbCIsIm1lbW9pemVkRXhwZWN0ZWQiLCJOT19FWENFUFRJT04iLCJleGVjdXRlIiwiaXNQcm9taXNlTGlrZSIsImV4ZWN1dGVQcm9taXNlIiwiZm5UeXBlIiwidGhyb3dzIiwiY2hlY2tFcnJvciIsInJlamVjdHMiLCJhc3luY0ZuIiwiZG9lc05vdFRocm93IiwiZG9lc05vdFJlamVjdCIsImlzUHJvdG90eXBlT2YiLCJpZkVycm9yIiwic3RyaWN0IiwiU3RyaW5nRGVjb2RlciIsIl9pbXBsIiwiVXRmOFN0cmluZ0RlY29kZXIiLCJVdGYxNlN0cmluZ0RlY29kZXIiLCJCYXNlNjRTdHJpbmdEZWNvZGVyIiwiU3RyaW5nRGVjb2RlckltcGwiLCJieXRlQ291bnQiLCJjaGFyTGVuZ3RoIiwiTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwiLCJieXRlc1BlckNoYXIiLCJpbmNvbXBsZXRlIiwiX2NoZWNrSW5jb21wbGV0ZUJ5dGVzIiwiX2J1ZmZlciIsIl9pbmNvbXBsZXRlRW5kIiwiX2luY29tcGxldGVCdWZmZXJFbXB0aWVkIiwiYnl0ZXNDb3BpZWQiLCJpbmNvbXBsZXRlQ2hhckRhdGEiLCJieXRlc05lZWRlZCIsImluY29tcGxldGVDaGFySW5kZXgiLCJieXRlc1RvQ29weSIsImNoZWNrQ2hhckxlbmd0aEZvclVURjgiLCJtb2R1bG8iLCJieXRlIiwiU3RyaW5nRGVjb2RlciQxIiwicHJpbnRlZFdhcm5pbmdzIiwib25lVGltZVdhcm5pbmciLCJ1bnN1cHBvcnRlZE5vb3AiLCJtb2R1bGVOYW1lIiwiZnFuIiwiYXN5bmNVbnN1cHBvcnRlZE5vb3AiLCJtYXliZUNhbGxiYWNrIiwiQ09QWV9GSUxFX0NIVU5LX1NJWkUiLCJmaWxlRGVzY3JpcHRvcnMiLCJmaWxlRGVzY3JpcHRvckNvdW50IiwiRkxBR1NfVE9fVElfTU9ERSIsIk1PREVfQVBQRU5EIiwiTU9ERV9XUklURSIsInBlcm1pc3Npb25EZW5pZWQiLCJzeXNjYWxsIiwibWFrZUVycm9yIiwibm9TdWNoRmlsZSIsImZpbGVBbHJlYWR5RXhpc3RzIiwibm90QURpcmVjdG9yeSIsImRpcmVjdG9yeU5vdEVtcHR5IiwiaWxsZWdhbE9wZXJhdGlvbk9uQURpcmVjdG9yeSIsImZzIiwiT19SRE9OTFkiLCJPX1dST05MWSIsIk9fUkRXUiIsIlNfSUZNVCIsIlNfSUZSRUciLCJTX0lGRElSIiwiU19JRkNIUiIsIlNfSUZCTEsiLCJTX0lGSUZPIiwiU19JRkxOSyIsIlNfSUZTT0NLIiwiT19DUkVBVCIsIk9fRVhDTCIsIk9fTk9DVFRZIiwiT19UUlVOQyIsIk9fQVBQRU5EIiwiT19ESVJFQ1RPUlkiLCJPX05PRk9MTE9XIiwiT19TWU5DIiwiT19EU1lOQyIsIk9fU1lNTElOSyIsIk9fTk9OQkxPQ0siLCJTX0lSV1hVIiwiU19JUlVTUiIsIlNfSVdVU1IiLCJTX0lYVVNSIiwiU19JUldYRyIsIlNfSVJHUlAiLCJTX0lXR1JQIiwiU19JWEdSUCIsIlNfSVJXWE8iLCJTX0lST1RIIiwiU19JV09USCIsIlNfSVhPVEgiLCJGX09LIiwiUl9PSyIsIldfT0siLCJYX09LIiwiVVZfRlNfQ09QWUZJTEVfRVhDTCIsIkNPUFlGSUxFX0VYQ0wiLCJTdGF0cyIsIl9maWxlIiwiZGV2IiwiaW5vIiwibmxpbmsiLCJyZGV2IiwiYmxrc2l6ZSIsImJsb2NrcyIsImF0aW1lTXMiLCJtdGltZU1zIiwiY3RpbWVNcyIsImJpcnRodGltZU1zIiwiYXRpbWUiLCJtdGltZSIsImN0aW1lIiwiYmlydGh0aW1lIiwiZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUiLCJjcmVhdGVkQXQiLCJtb2RpZmllZEF0IiwiY2VpbCIsImlzRmlsZSIsImlzRGlyZWN0b3J5IiwiaXNCbG9ja0RldmljZSIsImlzQ2hhcmFjdGVyRGV2aWNlIiwiaXNTeW1ib2xpY0xpbmsiLCJzeW1ib2xpY0xpbmsiLCJpc0ZJRk8iLCJpc1NvY2tldCIsImFjY2VzcyIsImFjY2Vzc1N5bmMiLCJmaWxlSGFuZGxlIiwiZXhlY3V0YWJsZSIsImFwcGVuZEZpbGUiLCJmaWxlIiwibWVyZ2VEZWZhdWx0T3B0aW9ucyIsImZsYWciLCJ3cml0ZUZpbGUiLCJhcHBlbmRGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJjaG1vZCIsImNobW9kU3luYyIsImNob3duIiwiY2hvd25TeW5jIiwiZmQiLCJjbG9zZVN5bmMiLCJzdHJlYW1Gb3JEZXNjcmlwdG9yIiwiY29weUZpbGUiLCJzcmNGaWxlIiwic3JjU3RyZWFtIiwiZGVzdEZpbGUiLCJkZXN0U3RyZWFtIiwicGlwZSIsImNvcHlGaWxlU3luYyIsImV4aXN0c1N5bmMiLCJmY2htb2QiLCJmY2htb2RTeW5jIiwiZmNob3duIiwiZmNob3duU3luYyIsImZkYXRhc3luYyIsImZkYXRhc3luY1N5bmMiLCJmc3RhdCIsInN0YXRzIiwiZnN0YXRTeW5jIiwiX29wdGlvbnMiLCJwYXRoRm9yRmlsZURlc2NyaXB0b3IiLCJzdGF0U3luYyIsImxzdGF0Iiwic3RhdCIsImxzdGF0U3luYyIsIm1rZGlyIiwicmVjdXJzaXZlIiwibWtkaXJTeW5jIiwidGlGaWxlIiwiY3JlYXRlRGlyZWN0b3J5IiwibWtkdGVtcCIsInRyeU1rZHRlbXAiLCJnZW5lcmF0ZWQiLCJyYW5kb21DaGFyYWN0ZXJzIiwibWtkdGVtcFN5bmMiLCJyZXRyeUNvdW50IiwiTUFYX1JFVFJJRVMiLCJmaWxlRGVzY3JpcHRvciIsIm9wZW5TeW5jIiwiX21vZGUiLCJjcmVhdGVGaWxlIiwicGFyZW50IiwidGlNb2RlIiwiY3JlYXRlRmlsZURlc2NyaXB0b3IiLCJ0aUZpbGVTdHJlYW0iLCJyZWFkT2JqIiwic3VjY2VzcyIsImJ5dGVzUHJvY2Vzc2VkIiwicmVhZFN5bmMiLCJfcG9zaXRpb24iLCJmaWxlU3RyZWFtIiwicmVhZGRpciIsInJlYWRkaXJTeW5jIiwid2l0aEZpbGVUeXBlcyIsImxpc3RpbmciLCJnZXREaXJlY3RvcnlMaXN0aW5nIiwicmVhZEZpbGVQb3N0T3BlbiIsImZpbGVTaXplIiwic291cmNlU3RyZWFtIiwicmVhZEFsbE9iaiIsInJlYWRGaWxlIiwid2FzRmlsZURlc2NyaXB0b3IiLCJoYW5kbGVCdWZmZXIiLCJlbmNvZGVCdWZmZXIiLCJyZWFkRmlsZVN5bmMiLCJyZWFscGF0aCIsInJlc3VsdEV4aXN0cyIsInBhcnRpYWxGaWxlUGF0aCIsInRyeVBhdGgiLCJwYXJ0aWFsRXhpc3RzIiwibmF0aXZlIiwicmVhbHBhdGhTeW5jIiwicmVuYW1lIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJyZW5hbWVTeW5jIiwidGVtcFBhdGgiLCJtb3ZlIiwidW5saW5rIiwiX2VyciIsInRtcEZpbGUiLCJybWRpciIsInJtZGlyU3luYyIsImRlbGV0ZURpcmVjdG9yeSIsInN1YkZpbGVzIiwic3ltbGluayIsInN5bWxpbmtTeW5jIiwidHJ1bmNhdGUiLCJieXRlc1JlYWQiLCJ0cnVuY2F0ZVN5bmMiLCJ1bmxpbmtTeW5jIiwiZGVsZXRlRmlsZSIsInVud2F0Y2hGaWxlIiwidXRpbWVzIiwidXRpbWVzU3luYyIsIndhdGNoIiwid2F0Y2hGaWxlIiwiZmluaXNoIiwid3JpdGVTeW5jIiwid3JpdGVUaUZpbGVTdHJlYW0iLCJ3cml0ZU9iaiIsIndyaXRlQnVmZmVyIiwid3JpdGVTdHJpbmciLCJ3cml0ZUJ1ZmZlclN5bmMiLCJ3cml0ZVN0cmluZ1N5bmMiLCJGaWxlRGVzY3JpcHRvciIsInBpcGVWaWFXcml0ZVN0cmVhbSIsIndyaXRlU3RyZWFtIiwicG9pbnRlciIsImRlZmF1bHRzIiwib3B0aW9uc1R5cGUiLCJtZXJnZWQiLCJjYiIsIl9lbmNvZGluZyIsInJhbmRvbSIsIl9vcHRzIiwiUmVhZGFibGUiLCJyZWFkYWJsZSIsIl9yZWFkIiwiZGVzdHJveSIsIl9kZXN0cm95IiwiX24iLCJXcml0YWJsZSIsImlzRHVwbGV4IiwiRHVwbGV4IiwiX3dyaXRlIiwid3JpdGV2IiwiX3dyaXRldiIsImZpbmFsIiwiX2ZpbmFsIiwiYWxsb3dIYWxmT3BlbiIsIndyaXRhYmxlTWV0aG9kcyIsIlRyYW5zZm9ybSIsInRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJmbHVzaCIsIl9mbHVzaCIsImZldGNoU2NyaXB0c0Zyb21Kc29uIiwiSlNPTl9GSUxFX05BTUUiLCJzZXR0aW5ncyIsInNjcmlwdHMiLCJmZXRjaFNjcmlwdHNGcm9tUmVzb3VyY2VzRGlyZWN0b3J5IiwicmVzb3VyY2VEaXJlY3RvcnkiLCJyZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGgiLCJuYXRpdmVQYXRoIiwiYm9vdHN0cmFwU2NyaXB0cyIsImxvYWRGcm9tIiwiZmlsZU5hbWVBcnJheSIsInNlYXJjaCIsImJvb3RzdHJhcFBhdGgiLCJsb2FkQXN5bmMiLCJmaW5pc2hlZCIsImxvYWRCb290c3RyYXBTY3JpcHRzIiwiYm9vdHN0cmFwSW5kZXgiLCJkb0xvYWQiLCJib290c3RyYXAiLCJvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkIiwiZmlyZUV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxTQUFTQSxpQkFBVCxDQUEyQkMsQ0FBM0IsRUFBOEI7QUFDN0IsTUFBSUEs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QU07QUFDUCxHQXZEMEIsQ0F1RHpCO0FBQ0Y7OztBQUdBRixFQUFBQSxvQkFBb0IsQ0FBQ0QsUUFBRCxDQUFwQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQXhuRCxFQUFFLENBQUNpdEIsR0FBSCxDQUFPbkIsSUFBUCxDQUFhLEdBQUU5ckIsRUFBRSxDQUFDZ3hCLEdBQUgsQ0FBT25zQixJQUFLLElBQUc3RSxFQUFFLENBQUNneEIsR0FBSCxDQUFPNlEsT0FBUSx5QkFBd0IsUUFBUyxJQUFHLFlBQWEsR0FBOUYsRSxDQUFtRztBQUNuRzBsQixTQUFTLENBQUMsWUFBWTtBQUNwQjtBQUNBO0FBQ0Fsb0QsRUFBQUEsT0FBTyxDQUFDLE9BQUQsQ0FBUCxDQUhvQixDQUdGO0FBQ2xCO0FBQ0E7OztBQUdBVyxFQUFBQSxFQUFFLENBQUNneEIsR0FBSCxDQUFPODJCLFNBQVAsQ0FBaUIsU0FBakI7QUFDRCxDQVRRLENBQVQiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcblx0aWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcblx0dmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRpZiAoZSkge1xuXHRcdE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHRcdGlmIChrICE9PSAnZGVmYXVsdCcpIHtcblx0XHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZVtrXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cdG5bJ2RlZmF1bHQnXSA9IGU7XG5cdHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAyMCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqXG4gKiBUaGlzIHNjcmlwdCBpcyB1c2VkIHRvIGxvYWQgQUNBIChBeHdheSBDcmFzaCBBbmFseXRpY3MpLlxuICogVGhpcyBhbGxvd3MgQUNBIHRvIGJlIHRoZSBmaXJzdCBtb2R1bGUgdG8gbG9hZCBvbiBzdGFydHVwLlxuICovXG5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShyZXF1aXJlKCdjb20uYXBwY2VsZXJhdG9yLmFjYScpKTsgfSkuY2F0Y2goKCkgPT4gey8vIE5vIG5lZWQgdG8gbm90aWZ5IG9mIEFDQSBsb2FkIGZhaWx1cmUuXG59KTtcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDIwIGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBxdW90ZS1wcm9wcyAqL1xuXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQsIE9TX0lPUyAqL1xuLy8gQWRkIGdsb2JhbCBjb25zdGFudHMuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbW1vbmpzR2xvYmFsLCB7XG4gICdPU19BTkRST0lEJzoge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICAnT1NfSU9TJzoge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgT1NfVkVSU0lPTl9NQUpPUjoge1xuICAgIHZhbHVlOiBUaS5QbGF0Zm9ybS52ZXJzaW9uTWFqb3IsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gIE9TX1ZFUlNJT05fTUlOT1I6IHtcbiAgICB2YWx1ZTogVGkuUGxhdGZvcm0udmVyc2lvbk1pbm9yLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBPU19WRVJTSU9OX1BBVENIOiB7XG4gICAgdmFsdWU6IFRpLlBsYXRmb3JtLnZlcnNpb25QYXRjaCxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfVxufSk7XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvbnN0IGtOb2RlTW9kdWxlc1JFID0gL14oLiopW1xcXFwvXW5vZGVfbW9kdWxlc1tcXFxcL10vO1xuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyk7XG5jb25zdCBpc0J1ZmZlciA9IFN5bWJvbC5mb3IoJ3RpdGFuaXVtLmJ1ZmZlci5pc0J1ZmZlcicpO1xuY29uc3QgY29sb3JSZWdFeHAgPSAvXFx1MDAxYlxcW1xcZFxcZD9tL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG5mdW5jdGlvbiByZW1vdmVDb2xvcnMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjb2xvclJlZ0V4cCwgJycpO1xufVxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIC8vIEFuIGVycm9yIGNvdWxkIGJlIGFuIGluc3RhbmNlIG9mIEVycm9yIHdoaWxlIG5vdCBiZWluZyBhIG5hdGl2ZSBlcnJvclxuICAvLyBvciBjb3VsZCBiZSBmcm9tIGEgZGlmZmVyZW50IHJlYWxtIGFuZCBub3QgYmUgaW5zdGFuY2Ugb2YgRXJyb3IgYnV0IHN0aWxsXG4gIC8vIGJlIGEgbmF0aXZlIGVycm9yLlxuICByZXR1cm4gaXNOYXRpdmVFcnJvcihlKSB8fCBlIGluc3RhbmNlb2YgRXJyb3I7XG59XG5sZXQgZ2V0U3RydWN0dXJlZFN0YWNrO1xuXG5jbGFzcyBTdGFja1RyYWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5TdGFja1RyYWNlRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSAoZXJyLCB0cmFjZSkgPT4gdHJhY2U7XG5cblN0YWNrVHJhY2VFcnJvci5zdGFja1RyYWNlTGltaXQgPSBJbmZpbml0eTtcbmZ1bmN0aW9uIGlzSW5zaWRlTm9kZU1vZHVsZXMoKSB7XG4gIGlmIChnZXRTdHJ1Y3R1cmVkU3RhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIGdldFN0cnVjdHVyZWRTdGFjayA9ICgpID0+IG5ldyBTdGFja1RyYWNlRXJyb3IoKS5zdGFjaztcbiAgfVxuXG4gIGxldCBzdGFjayA9IGdldFN0cnVjdHVyZWRTdGFjaygpOyAvLyBzdGFjayBpcyBvbmx5IGFuIGFycmF5IG9uIHY4LCB0cnkgdG8gY29udmVydCBtYW51YWxseSBpZiBzdHJpbmdcblxuICBpZiAodHlwZW9mIHN0YWNrID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHN0YWNrRnJhbWVzID0gW107XG4gICAgY29uc3QgbGluZXMgPSBzdGFjay5zcGxpdCgvXFxuLyk7XG5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IGxpbmVJbmZvID0gbGluZS5tYXRjaCgvKC4qKUAoLiopOihcXGQrKTooXFxkKykvKTtcblxuICAgICAgaWYgKGxpbmVJbmZvKSB7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gbGluZUluZm9bMl0ucmVwbGFjZSgnZmlsZTovLycsICcnKTtcbiAgICAgICAgc3RhY2tGcmFtZXMucHVzaCh7XG4gICAgICAgICAgZ2V0RmlsZU5hbWU6ICgpID0+IGZpbGVuYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrID0gc3RhY2tGcmFtZXM7XG4gIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCBzdGFjayBmcmFtZXMgYW5kIGxvb2sgZm9yIHRoZSBmaXJzdCBvbmUgbm90IGNvbWluZ1xuICAvLyBmcm9tIGluc2lkZSBOb2RlLmpzIGl0c2VsZjpcblxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0YWNrKSkge1xuICAgIGZvciAoY29uc3QgZnJhbWUgb2Ygc3RhY2spIHtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gZnJhbWUuZ2V0RmlsZU5hbWUoKTsgLy8gSWYgYSBmaWxlbmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIC8gb3IgY29udGFpbiBcXCxcbiAgICAgIC8vIGl0J3MgbGlrZWx5IGZyb20gTm9kZS5qcyBjb3JlLlxuXG4gICAgICBpZiAoIS9eXFwvfFxcXFwvLnRlc3QoZmlsZW5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga05vZGVNb2R1bGVzUkUudGVzdChmaWxlbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gam9pbiQxKG91dHB1dCwgc2VwYXJhdG9yKSB7XG4gIGxldCBzdHIgPSAnJztcblxuICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IG91dHB1dC5sZW5ndGggLSAxO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgLy8gSXQgaXMgZmFzdGVyIG5vdCB0byB1c2UgYSB0ZW1wbGF0ZSBzdHJpbmcgaGVyZVxuICAgICAgc3RyICs9IG91dHB1dFtpXTtcbiAgICAgIHN0ciArPSBzZXBhcmF0b3I7XG4gICAgfVxuXG4gICAgc3RyICs9IG91dHB1dFtsYXN0SW5kZXhdO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZi5jYWxsLmFwcGx5KGYsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5jb25zdCBBTExfUFJPUEVSVElFUyQyID0gMDtcbmNvbnN0IE9OTFlfRU5VTUVSQUJMRSQyID0gMjtcbmNvbnN0IHByb3BlcnR5RmlsdGVyID0ge1xuICBBTExfUFJPUEVSVElFUzogQUxMX1BST1BFUlRJRVMkMixcbiAgT05MWV9FTlVNRVJBQkxFOiBPTkxZX0VOVU1FUkFCTEUkMlxufTtcbmZ1bmN0aW9uIGdldE93bk5vbkluZGV4UHJvcGVydGllcyhvYmosIGZpbHRlcikge1xuICBjb25zdCBwcm9wcyA9IFtdO1xuICBjb25zdCBrZXlzID0gZmlsdGVyID09PSBPTkxZX0VOVU1FUkFCTEUkMiA/IE9iamVjdC5rZXlzKG9iaikgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlzQWxsRGlnaXRzKGtleSkpIHtcbiAgICAgIHByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59XG5cbmZ1bmN0aW9uIGlzQWxsRGlnaXRzKHMpIHtcbiAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHMuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGUkMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSk7XG5jb25zdCBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcgPSB1bmN1cnJ5VGhpcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFR5cGVkQXJyYXlQcm90b3R5cGUkMSwgU3ltYm9sLnRvU3RyaW5nVGFnKS5nZXQpO1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgbmFtZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gYFtvYmplY3QgJHtuYW1lfV1gO1xufVxuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNBcmd1bWVudHNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0FyZ3VtZW50cycpO1xufVxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXJyYXlCdWZmZXInKTtcbn0gLy8gQ2FjaGVkIHRvIG1ha2Ugc3VyZSBubyB1c2VybGFuZCBjb2RlIGNhbiB0YW1wZXIgd2l0aCBpdC5cblxuY29uc3QgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXN5bmNGdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdCb29sZWFuJyk7XG59XG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fCBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHwgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSAvLyB8fCBpc0JpZ0ludE9iamVjdCh2YWx1ZSlcbiAgfHwgaXNTeW1ib2xPYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnRGF0YVZpZXcnKTtcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnRGF0ZScpO1xufSAvLyBAdG9kbyBpc0V4dGVybmFsXG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnR2VuZXJhdG9yRnVuY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdHZW5lcmF0b3InKTtcbn1cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnTWFwJyk7XG59XG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgcmV0dXJuIHByb3RvdHlwZSAmJiBwcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01hcCBJdGVyYXRvcic7XG59IC8vIEB0b2RvIGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0XG5cbmZ1bmN0aW9uIGlzTmF0aXZlRXJyb3IodmFsdWUpIHtcbiAgLy8gaWYgbm90IGFuIGluc3RhbmNlIG9mIGFuIEVycm9yLCBkZWZpbml0ZWx5IG5vdCBhIG5hdGl2ZSBlcnJvclxuICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghdmFsdWUgfHwgIXZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFsnRXJyb3InLCAnRXZhbEVycm9yJywgJ1JhbmdlRXJyb3InLCAnUmVmZXJlbmNlRXJyb3InLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJ10uaW5jbHVkZXModmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG59XG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnTnVtYmVyJyk7XG59XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1Byb21pc2UnKTtcbn0gLy8gQHRvZG8gaXNQcm94eVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnUmVnRXhwJyk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU2V0Jyk7XG59XG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgcmV0dXJuIHByb3RvdHlwZSAmJiBwcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ1NldCBJdGVyYXRvcic7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICghZ2xvYmFsLlNoYXJlZEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1NoYXJlZEFycmF5QnVmZmVyJyk7XG59XG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3RyaW5nJyk7XG59XG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3ltYm9sJyk7XG59XG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgY29uc3QgaXNCdWlsdEluVHlwZWRBcnJheSA9IFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgIT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNCdWlsdEluVHlwZWRBcnJheSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlW2lzQnVmZmVyXSA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdXZWFrTWFwJyk7XG59XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1dlYWtTZXQnKTtcbn0gLy8gQHRvZG8gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlXG5cbnZhciB0eXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRpc0FueUFycmF5QnVmZmVyOiBpc0FueUFycmF5QnVmZmVyLFxuXHRpc0FyZ3VtZW50c09iamVjdDogaXNBcmd1bWVudHNPYmplY3QsXG5cdGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG5cdGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcblx0aXNBc3luY0Z1bmN0aW9uOiBpc0FzeW5jRnVuY3Rpb24sXG5cdGlzQmlnSW50NjRBcnJheTogaXNCaWdJbnQ2NEFycmF5LFxuXHRpc0JpZ1VpbnQ2NEFycmF5OiBpc0JpZ1VpbnQ2NEFycmF5LFxuXHRpc0Jvb2xlYW5PYmplY3Q6IGlzQm9vbGVhbk9iamVjdCxcblx0aXNCb3hlZFByaW1pdGl2ZTogaXNCb3hlZFByaW1pdGl2ZSxcblx0aXNEYXRhVmlldzogaXNEYXRhVmlldyxcblx0aXNEYXRlOiBpc0RhdGUsXG5cdGlzRmxvYXQzMkFycmF5OiBpc0Zsb2F0MzJBcnJheSxcblx0aXNGbG9hdDY0QXJyYXk6IGlzRmxvYXQ2NEFycmF5LFxuXHRpc0dlbmVyYXRvckZ1bmN0aW9uOiBpc0dlbmVyYXRvckZ1bmN0aW9uLFxuXHRpc0dlbmVyYXRvck9iamVjdDogaXNHZW5lcmF0b3JPYmplY3QsXG5cdGlzSW50OEFycmF5OiBpc0ludDhBcnJheSxcblx0aXNJbnQxNkFycmF5OiBpc0ludDE2QXJyYXksXG5cdGlzSW50MzJBcnJheTogaXNJbnQzMkFycmF5LFxuXHRpc01hcDogaXNNYXAsXG5cdGlzTWFwSXRlcmF0b3I6IGlzTWFwSXRlcmF0b3IsXG5cdGlzTmF0aXZlRXJyb3I6IGlzTmF0aXZlRXJyb3IsXG5cdGlzTnVtYmVyT2JqZWN0OiBpc051bWJlck9iamVjdCxcblx0aXNQcm9taXNlOiBpc1Byb21pc2UsXG5cdGlzUmVnRXhwOiBpc1JlZ0V4cCxcblx0aXNTZXQ6IGlzU2V0LFxuXHRpc1NldEl0ZXJhdG9yOiBpc1NldEl0ZXJhdG9yLFxuXHRpc1NoYXJlZEFycmF5QnVmZmVyOiBpc1NoYXJlZEFycmF5QnVmZmVyLFxuXHRpc1N0cmluZ09iamVjdDogaXNTdHJpbmdPYmplY3QsXG5cdGlzU3ltYm9sT2JqZWN0OiBpc1N5bWJvbE9iamVjdCxcblx0aXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG5cdGlzVWludDhBcnJheTogaXNVaW50OEFycmF5LFxuXHRpc1VpbnQ4Q2xhbXBlZEFycmF5OiBpc1VpbnQ4Q2xhbXBlZEFycmF5LFxuXHRpc1VpbnQxNkFycmF5OiBpc1VpbnQxNkFycmF5LFxuXHRpc1VpbnQzMkFycmF5OiBpc1VpbnQzMkFycmF5LFxuXHRpc1dlYWtNYXA6IGlzV2Vha01hcCxcblx0aXNXZWFrU2V0OiBpc1dlYWtTZXRcbn0pO1xuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5sZXQgZXJyb3I7XG5cbmZ1bmN0aW9uIGxhenlFcnJvcigpIHtcbiAgaWYgKCFlcnJvcikge1xuICAgIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gICAgLy8gZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLmNvZGVzLkVSUl9JTlRFUk5BTF9BU1NFUlRJT047XG4gICAgZXJyb3IgPSBjb2Rlcy5FUlJfSU5URVJOQUxfQVNTRVJUSU9OO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBhc3NlcnQkMSh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgY29uc3QgRVJSX0lOVEVSTkFMX0FTU0VSVElPTiA9IGxhenlFcnJvcigpO1xuICAgIHRocm93IG5ldyBFUlJfSU5URVJOQUxfQVNTRVJUSU9OKG1lc3NhZ2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICBjb25zdCBFUlJfSU5URVJOQUxfQVNTRVJUSU9OID0gbGF6eUVycm9yKCk7XG4gIHRocm93IG5ldyBFUlJfSU5URVJOQUxfQVNTRVJUSU9OKG1lc3NhZ2UpO1xufVxuXG5hc3NlcnQkMS5mYWlsID0gZmFpbDtcblxuLy8gQ29weXJpZ2h0IE5vZGUuanMgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29uc3QgbWVzc2FnZXMgPSBuZXcgTWFwKCk7XG5jb25zdCBjb2RlcyA9IHt9OyAvLyBAdG9kbyBpbXBsZW1lbnQgdGhpcyBvbmNlIG5lZWRlZFxuXG5jbGFzcyBTeXN0ZW1FcnJvciBleHRlbmRzIEVycm9yIHt9IC8vIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIHRoZSBlcnJvciBjb2Rlcy5cblxuXG5mdW5jdGlvbiBFKHN5bSwgdmFsLCBkZWYsIC4uLm90aGVyQ2xhc3Nlcykge1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIFN5c3RlbUVycm9yIHRoYXQgZm9ybWF0cyB0aGUgZXJyb3IgbWVzc2FnZSBkaWZmZXJlbnRseVxuICAvLyBUaGUgU3lzdGVtRXJyb3JzIG9ubHkgaGF2ZSBTeXN0ZW1FcnJvciBhcyB0aGVpciBiYXNlIGNsYXNzZXMuXG4gIG1lc3NhZ2VzLnNldChzeW0sIHZhbCk7XG5cbiAgaWYgKGRlZiA9PT0gU3lzdGVtRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgY29tcGF0aWJsZSBTeXN0ZW1FcnJvciBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICB9IGVsc2Uge1xuICAgIGRlZiA9IG1ha2VOb2RlRXJyb3JXaXRoQ29kZShkZWYsIHN5bSk7XG4gIH1cblxuICBpZiAob3RoZXJDbGFzc2VzLmxlbmd0aCAhPT0gMCkge1xuICAgIG90aGVyQ2xhc3Nlcy5mb3JFYWNoKGNsYXp6ID0+IHtcbiAgICAgIGRlZltjbGF6ei5uYW1lXSA9IG1ha2VOb2RlRXJyb3JXaXRoQ29kZShjbGF6eiwgc3ltKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvZGVzW3N5bV0gPSBkZWY7XG59XG5cbmZ1bmN0aW9uIG1ha2VOb2RlRXJyb3JXaXRoQ29kZShCYXNlLCBrZXkpIHtcbiAgcmV0dXJuIGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZ2V0TWVzc2FnZShrZXksIGFyZ3MsIHRoaXMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogbWVzc2FnZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYWRkQ29kZVRvTmFtZSh0aGlzLCBzdXBlci5uYW1lLCBrZXkpO1xuICAgIH1cblxuICAgIGdldCBjb2RlKCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBzZXQgY29kZSh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtrZXl9XTogJHt0aGlzLm1lc3NhZ2V9YDtcbiAgICB9XG5cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShrZXksIGFyZ3MsIHNlbGYpIHtcbiAgY29uc3QgbXNnID0gbWVzc2FnZXMuZ2V0KGtleSk7XG4gIC8qXG4gIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkge1xuICBcdGFzc2VydCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvYXNzZXJ0Jyk7XG4gIH1cbiAgKi9cblxuICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2VydCQxKG1zZy5sZW5ndGggPD0gYXJncy5sZW5ndGgsIC8vIERlZmF1bHQgb3B0aW9ucyBkbyBub3QgY291bnQuXG4gICAgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBgICsgYG1hdGNoIHRoZSByZXF1aXJlZCBvbmVzICgke21zZy5sZW5ndGh9KS5gKTtcbiAgICByZXR1cm4gbXNnLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSAobXNnLm1hdGNoKC8lW2RmaWpvT3NdL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGFzc2VydCQxKGV4cGVjdGVkTGVuZ3RoID09PSBhcmdzLmxlbmd0aCwgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBgICsgYG1hdGNoIHRoZSByZXF1aXJlZCBvbmVzICgke2V4cGVjdGVkTGVuZ3RofSkuYCk7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG1zZztcbiAgfVxuXG4gIGFyZ3MudW5zaGlmdChtc2cpO1xuICByZXR1cm4gZm9ybWF0JDEuYXBwbHkobnVsbCwgYXJncyk7IC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gIC8vIHJldHVybiBsYXp5SW50ZXJuYWxVdGlsSW5zcGVjdCgpLmZvcm1hdC5hcHBseShudWxsLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gYWRkQ29kZVRvTmFtZShlcnIsIG5hbWUsIGNvZGUpIHtcbiAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICBlcnIubmFtZSA9IGAke25hbWV9IFske2NvZGV9XWA7IC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gIC8vIGZyb20gdGhlIG5hbWUuXG4gIC8vIEBmaXhtZTogVGhpcyBvbmx5IHdvcmtzIG9uIFY4L0FuZHJvaWQsIGlPUy9KU0MgaGFzIGEgZGlmZmVyZW50IEVycm9yIHN0cnVjdHVyZS5cbiAgLy8gc2hvdWxkIHdlIHRyeSB0byBtYWtlIGVycm9ycyBiZWhhdmUgdGhlIHNhbWUgYWNyb3NzIHBsYXRmb3Jtcz9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gIGVyci5zdGFjazsgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuXG4gIGlmIChuYW1lID09PSAnU3lzdGVtRXJyb3InKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogbmFtZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgZXJyLm5hbWU7XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJywgLy8gVXNpbmcgYSBkZWZhdWx0IGFyZ3VtZW50IGhlcmUgaXMgaW1wb3J0YW50IHNvIHRoZSBhcmd1bWVudCBpcyBub3QgY291bnRlZFxuLy8gdG93YXJkcyBgRnVuY3Rpb24jbGVuZ3RoYC5cbihuYW1lID0gdW5kZWZpbmVkKSA9PiB7XG4gIGlmIChuYW1lKSB7XG4gICAgcmV0dXJuIGBcIiR7bmFtZX1cIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgO1xuICB9XG5cbiAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJztcbn0sIFJhbmdlRXJyb3IpO1xuRSgnRVJSX0lOVEVSTkFMX0FTU0VSVElPTicsIG1lc3NhZ2UgPT4ge1xuICBjb25zdCBzdWZmaXggPSAnVGhpcyBpcyBjYXVzZWQgYnkgZWl0aGVyIGEgYnVnIGluIFRpdGFuaXVtICcgKyAnb3IgaW5jb3JyZWN0IHVzYWdlIG9mIFRpdGFuaXVtIGludGVybmFscy5cXG4nICsgJ1BsZWFzZSBvcGVuIGFuIGlzc3VlIHdpdGggdGhpcyBzdGFjayB0cmFjZSBhdCAnICsgJ2h0dHBzOi8vamlyYS5hcHBjZWxlcmF0b3Iub3JnXFxuJztcbiAgcmV0dXJuIG1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/IHN1ZmZpeCA6IGAke21lc3NhZ2V9XFxuJHtzdWZmaXh9YDtcbn0sIEVycm9yKTtcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpID0+IHtcbiAgYXNzZXJ0JDEodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnXFwnbmFtZVxcJyBtdXN0IGJlIGEgc3RyaW5nJyk7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgbGV0IGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgZXhwZWN0ZWQuc3RhcnRzV2l0aCgnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgbGV0IG1zZztcblxuICBpZiAobmFtZS5lbmRzV2l0aCgnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gYFRoZSAke25hbWV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCAndHlwZScpfWA7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBgLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmxldCBtYXhTdGFja19FcnJvck5hbWU7XG5sZXQgbWF4U3RhY2tfRXJyb3JNZXNzYWdlO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYGVyci5uYW1lYCBhbmQgYGVyci5tZXNzYWdlYCBhcmUgZXF1YWwgdG8gZW5naW5lLXNwZWNpZmljXG4gKiB2YWx1ZXMgaW5kaWNhdGluZyBtYXggY2FsbCBzdGFjayBzaXplIGhhcyBiZWVuIGV4Y2VlZGVkLlxuICogXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiIGluIFY4LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzU3RhY2tPdmVyZmxvd0Vycm9yKGVycikge1xuICBpZiAobWF4U3RhY2tfRXJyb3JNZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICB0cnkge1xuICAgICAgZnVuY3Rpb24gb3ZlcmZsb3dTdGFjaygpIHtcbiAgICAgICAgb3ZlcmZsb3dTdGFjaygpO1xuICAgICAgfVxuXG4gICAgICBvdmVyZmxvd1N0YWNrKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbWF4U3RhY2tfRXJyb3JNZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgICAgbWF4U3RhY2tfRXJyb3JOYW1lID0gZS5uYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnIubmFtZSA9PT0gbWF4U3RhY2tfRXJyb3JOYW1lICYmIGVyci5tZXNzYWdlID09PSBtYXhTdGFja19FcnJvck1lc3NhZ2U7XG59XG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBhc3NlcnQkMSh0eXBlb2YgdGhpbmcgPT09ICdzdHJpbmcnLCAnYHRoaW5nYCBoYXMgdG8gYmUgb2YgdHlwZSBzdHJpbmcnKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICBjb25zdCBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgYXNzZXJ0JDEobGVuID4gMCwgJ0F0IGxlYXN0IG9uZSBleHBlY3RlZCB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChpID0+IFN0cmluZyhpKSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIGBvbmUgb2YgJHt0aGluZ30gJHtleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpfSwgb3IgYCArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkWzBdfSBvciAke2V4cGVjdGVkWzFdfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtleHBlY3RlZFswXX1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYG9mICR7dGhpbmd9ICR7U3RyaW5nKGV4cGVjdGVkKX1gO1xuICB9XG59XG5cbmNsYXNzIEZhc3RCdWZmZXIgZXh0ZW5kcyBVaW50OEFycmF5IHt9XG4vKipcbiAqIGxvb3Agb3ZlciBpbnB1dCwgZXZlcnkgMiBjaGFyYWN0ZXJzLCBwYXJzZSBhcyBhbiBpbnRcbiAqIGJhc2ljYWxseSBlYWNoIHR3byBjaGFyYWN0ZXJzIGFyZSBhIFwiYnl0ZVwiIG9yIGFuIDgtYml0IHVpbnRcbiAqIHdlIGFwcGVuZCB0aGVtIGFsbCB0b2dldGhlciB0byBmb3JtIGEgc2luZ2xlIGJ1ZmZlciBob2xkaW5nIGFsbCB0aGUgdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgc3RyaW5nIHdlJ3JlIGVuY29kaW5nIGluIGhleFxuICogQHJldHVybnMge2ludGVnZXJbXX0gYXJyYXkgb2YgZW5jb2RlZCBieXRlc1xuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvSGV4Qnl0ZXModmFsdWUpIHtcbiAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoIC8gMjtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG51bWVyaWNWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cihpICogMiwgMiksIDE2KTtcblxuICAgIGlmICghTnVtYmVyLmlzTmFOKG51bWVyaWNWYWx1ZSkpIHtcbiAgICAgIC8vIGRyb3AgYmFkIGhleCBjaGFyYWN0ZXJzXG4gICAgICBieXRlQXJyYXkucHVzaChudW1lcmljVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmNvbnN0IGFycmF5SW5kZXhIYW5kbGVyID0ge1xuICBnZXQodGFyZ2V0LCBwcm9wS2V5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgcHJvcEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihwcm9wS2V5KTtcblxuICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkanVzdGVkSW5kZXgodGFyZ2V0LCBudW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gaXNCdWZmZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BLZXksIHJlY2VpdmVyKTtcbiAgfSxcblxuICBzZXQodGFyZ2V0LCBwcm9wS2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHByb3BLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBudW0gPSBOdW1iZXIocHJvcEtleSk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGFyZ2V0LCBudW0sIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcEtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgfSxcblxuICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihrZXkpO1xuXG4gICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICAvLyBlbnN1cmUgaXQncyBhIHBvc2l0aXZlIFwic2FmZVwiIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgYnVmZmVyXG4gICAgICAgIHJldHVybiBudW0gPj0gMCAmJiBudW0gPCB0YXJnZXQuX3RpQnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5IGluIHRhcmdldDtcbiAgfVxuXG59OyAvLyBUaGlzIGlzIGEgc3BlY2lhbCBCdWZmZXIgdGhhdCB3cmFwcyBUaS5CdWZmZXJcbi8vIGFzIGEgcmVzdWx0IGl0IGlzICptdWNoKiBzbG93ZXIgdG8gcmVhZC93cml0ZSB2YWx1ZXNcbi8vIGJlY2F1c2Ugd2UgbmVlZCB0byBnbyBhY3Jvc3MgdGhlIEpTL05hdGl2ZSBib3VuZGFyeSBwZXItYnl0ZSFcbi8vIFdlIGFsc28gbmVlZCB0byB1c2UgYSBQcm94eSB0byBoYW5kbGUgaW50ZXJjZXB0aW5nIHNldC9nZXQgb2YgaW5kaWNlcyB0byByZWRpcmVjdCB0byB0aGUgdW5kZXJseWluZyBUaS5CdWZmZXJcblxuY2xhc3MgU2xvd0J1ZmZlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlci5cbiAgICpcbiAgICogUHJpbWFyaWx5IHVzZWQgaW50ZXJuYWxseSBpbiB0aGlzIG1vZHVsZSB0b2dldGhlciB3aXRoIGBuZXdCdWZmZXJgIHRvXG4gICAqIGNyZWF0ZSBhIG5ldyBCdWZmZXIgaW5zdGFuY2Ugd3JhcHBpbmcgYSBUaS5CdWZmZXIuXG4gICAqXG4gICAqIEFsc28gc3VwcG9ydHMgdGhlIGRlcHJlY2F0ZWQgQnVmZmVyKCkgY29uc3RydWN0b3JzIHdoaWNoIGFyZSBzYWZlXG4gICAqIHRvIHVzZSBvdXRzaWRlIG9mIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gdGlCdWZmZXIgdGhlIHVuZGVybHlpbmcgZGF0YS9ieXRlc1xuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydD0wXSBzdGFydCBvZmZzZXQgb2YgYXJyYXkvYnVmZmVyXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aF0gbGVuZ3RoIG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5L2J1ZmZlciB0byB3cmFwXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aUJ1ZmZlciwgc3RhcnQgPSAwLCBsZW5ndGggPSB0aUJ1ZmZlci5sZW5ndGggLSBzdGFydCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGJ5dGVPZmZzZXQ6IHtcbiAgICAgICAgdmFsdWU6IHN0YXJ0XG4gICAgICB9LFxuICAgICAgbGVuZ3RoOiB7XG4gICAgICAgIHZhbHVlOiBsZW5ndGhcbiAgICAgIH0sXG4gICAgICBfdGlCdWZmZXI6IHtcbiAgICAgICAgdmFsdWU6IHRpQnVmZmVyXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGNyZWF0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlIGluc2lkZSBhIFByb3h5IHNvIHdlIGNhbiBoYW5kbGUgYXJyYXkgaW5kZXggYWNjZXNzXG4gICAqIEBwYXJhbSB7VGkuQnVmZmVyfSB0aUJ1ZmZlciB0aGUgdW5kZXJseWluZyBkYXRhL2J5dGVzXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIHN0YXJ0IG9mZnNldCBvZiBhcnJheS9idWZmZXJcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgdGhlIHVuZGVybHlpbmcgYXJyYXkvYnVmZmVyIHRvIHdyYXBcbiAgICogQHJldHVybnMge0J1ZmZlcn0gd3JhcHBlZCBpbnNpZGUgYSBQcm94eVxuICAgKi9cblxuXG4gIHN0YXRpYyBmcm9tVGlCdWZmZXIodGlCdWZmZXIsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KG5ldyBTbG93QnVmZmVyKHRpQnVmZmVyLCBzdGFydCwgbGVuZ3RoKSwgYXJyYXlJbmRleEhhbmRsZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHNlY3VyaXR5L2RldGVjdC1uZXctYnVmZmVyXG4gIH1cblxuICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5rbm93biBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICB9XG5cbiAgICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICBjb25zdCBibG9iID0gVGkuVXRpbHMuYmFzZTY0ZGVjb2RlKHZhbHVlKTtcbiAgICAgIGNvbnN0IGJsb2JTdHJlYW0gPSBUaS5TdHJlYW0uY3JlYXRlU3RyZWFtKHtcbiAgICAgICAgc291cmNlOiBibG9iLFxuICAgICAgICBtb2RlOiBUaS5TdHJlYW0uTU9ERV9SRUFEXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IFRpLlN0cmVhbS5yZWFkQWxsKGJsb2JTdHJlYW0pO1xuICAgICAgYmxvYlN0cmVhbS5jbG9zZSgpO1xuICAgICAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgY29uc3QgYnl0ZXMgPSBzdHJpbmdUb0hleEJ5dGVzKHZhbHVlKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRpQnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9KTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aUJ1ZmZlcltpXSA9IGJ5dGVzW2ldICYgMHhGRjsgLy8gbWFzayB0byBvbmUgYnl0ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIodGlCdWZmZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpQnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHR5cGU6IGdldFRpQ29kZWNDaGFyc2V0KGVuY29kaW5nKVxuICAgIH0pO1xuICAgIHJldHVybiBTbG93QnVmZmVyLmZyb21UaUJ1ZmZlcih0aUJ1ZmZlcik7XG4gIH0gLy8gVGhpcyBpcyBhIG1ldGhvZCB3ZSBzaG91bGQgZ2V0IGJ5IGV4dGVuZGluZyBVaW50OEFycmF5LCBzbyByZWFsbHkgc2hvdWxkIG9ubHkgYmUgb3ZlcnJpZGVuIG9uIGEgXCJTbG93QnVmZmVyXCIgdGhhdCB3cmFwcyBUaS5CdWZmZXJcblxuXG4gIGdldCBidWZmZXIoKSB7XG4gICAgLy8gR2V0IHRoZSBzbGljZSBvZiB0aGUgYXJyYXkgZnJvbSBieXRlT2Zmc2V0IHRvIGxlbmd0aFxuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20odGhpcykuYnVmZmVyO1xuICB9XG5cbiAgX3NsaWNlKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKHRoaXMuX3RpQnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBfZmlsbCh2YWx1ZSwgb2Zmc2V0LCBlbmQsIGVuY29kaW5nKSB7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGJ1ZlRvRmlsbFdpdGggPSBTbG93QnVmZmVyLmZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgIGNvbnN0IGZpbGxCdWZMZW5ndGggPSBidWZUb0ZpbGxXaXRoLmxlbmd0aDtcblxuICAgICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB2YWxpZCBmaWxsIGRhdGEnKTtcbiAgICAgIH0gLy8gSWYgdGhlIGJ1ZmZlciBsZW5ndGggPT09IDEsIHdlIGNhbiBqdXN0IGRvIHRoaXMuX3RpQnVmZmVyLmZpbGwodmFsdWUsIG9mZnNldCwgZW5kKTtcblxuXG4gICAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl90aUJ1ZmZlci5maWxsKGJ1ZlRvRmlsbFdpdGguX3RpQnVmZmVyWzBdLCBvZmZzZXQsIGVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIG11bHRpcGxlIGJ5dGUgZmlsbCFcblxuXG4gICAgICBjb25zdCBsZW5ndGggPSBlbmQgLSBvZmZzZXQ7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBhY2NvdW50IGZvciBieXRlT2Zmc2V0IGhlcmUgKG9uIGB0aGlzYCwgbm90IG9uIHRoZSBidWZmZXIgd2UganVzdCBjcmVhdGVkKT9cbiAgICAgICAgY29uc3QgZmlsbENoYXIgPSBidWZUb0ZpbGxXaXRoLl90aUJ1ZmZlcltpICUgZmlsbEJ1Zkxlbmd0aF07XG4gICAgICAgIHRoaXMuX3RpQnVmZmVyW2kgKyBvZmZzZXRdID0gZmlsbENoYXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyIChvciBhIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGJ5dGUpIHdlIGNhbiB1c2UgdGlCdWZmZXIuZmlsbCgpO1xuXG5cbiAgICB0aGlzLl90aUJ1ZmZlci5maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCk7XG4gIH1cblxuICBnZXRBZGp1c3RlZEluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGdldEFkanVzdGVkSW5kZXgodGhpcywgaW5kZXgpO1xuICB9XG5cbiAgc2V0QWRqdXN0ZWRJbmRleChpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpbmRleCwgdmFsdWUpO1xuICB9IC8vIFRoaXMgaXMgYSBtZXRob2Qgd2Ugc2hvdWxkIGdldCBieSBleHRlbmRpbmcgVWludDhBcnJheSwgc28gcmVhbGx5IHNob3VsZCBvbmx5IGJlIG92ZXJyaWRlbiBvbiBhIFwiU2xvd0J1ZmZlclwiIHRoYXQgd3JhcHMgVGkuQnVmZmVyXG5cblxuICBzZXQoc3JjLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgbnVtQnl0ZXMgPSBzcmMubGVuZ3RoOyAvLyBjaGVjayBzcmMubGVuZ3RoICsgb2Zmc2V0IGRvZXNuJ3QgZ28gYmV5b25kIG91ciBsZW5ndGghXG4gICAgLy8gRklYTUU6IFJlLWVuYWJsZVxuICAgIC8vIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgbnVtQnl0ZXMpO1xuICAgIC8vIGNvcHkgc3JjIHZhbHVlcyBpbnRvIHRoaXMgYnVmZmVyIHN0YXJ0aW5nIGF0IG9mZnNldFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1CeXRlczsgaSsrKSB7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyBvZmZzZXQsIHNyY1tpXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gbWV0aG9kIGZvciBpbnRlcmFjdGluZyB3aXRoIFRpIEFQSXMgdGhhdCByZXF1aXJlIGEgVGkuQnVmZmVyXG4gICAqIEByZXR1cm5zIHtUaS5CdWZmZXJ9IHRoZSB1bmRlcmx5aW5nIFRpLkJ1ZmZlciBiYWNraW5nIHRoaXMgQnVmZmVyIGluc3RhbmNlXG4gICAqL1xuXG5cbiAgdG9UaUJ1ZmZlcigpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IHRoaXMuX3RpQnVmZmVyLmxlbmd0aCAmJiB0aGlzLmJ5dGVPZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl90aUJ1ZmZlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdGlCdWZmZXIuY2xvbmUodGhpcy5ieXRlT2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXRBZGp1c3RlZEluZGV4KGJ1ZiwgaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gLy8gV3JhcHBpbmcgVGkuQnVmZmVyP1xuXG5cbiAgaWYgKGJ1Zi5fdGlCdWZmZXIpIHtcbiAgICBpZiAoaW5kZXggPj0gYnVmLl90aUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zi5fdGlCdWZmZXJbaW5kZXggKyBidWYuYnl0ZU9mZnNldF07XG4gIH0gLy8gUmF3IFR5cGVkQXJyYXkvQXJyYXlCdWZmZXJcbiAgLy8gRklYTUU6IGRvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlP1xuXG5cbiAgcmV0dXJuIGJ1ZltpbmRleF07XG59XG5cbmZ1bmN0aW9uIHNldEFkanVzdGVkSW5kZXgoYnVmLCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBXcmFwcGluZyBUaS5CdWZmZXI/XG5cblxuICBpZiAoYnVmLl90aUJ1ZmZlcikge1xuICAgIGlmIChpbmRleCA8IGJ1Zi5fdGlCdWZmZXIubGVuZ3RoKSB7XG4gICAgICBidWYuX3RpQnVmZmVyW2luZGV4ICsgYnVmLmJ5dGVPZmZzZXRdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIFJhdyBUeXBlZEFycmF5L0FycmF5QnVmZmVyXG4gIC8vIEZJWE1FOiBkbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGJ5dGVPZmZzZXQgaGVyZT9cblxuXG4gIGJ1ZltpbmRleF0gPSB2YWx1ZTtcbn0gLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfYnVmZmVyc19hbmRfY2hhcmFjdGVyX2VuY29kaW5nc1xuXG5cbmNvbnN0IFRJX0NPREVDX01BUCA9IG5ldyBNYXAoKTtcblRJX0NPREVDX01BUC5zZXQoJ3V0Zi04JywgVGkuQ29kZWMuQ0hBUlNFVF9VVEY4KTtcblRJX0NPREVDX01BUC5zZXQoJ3V0ZjgnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjgpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmLTE2bGUnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjE2TEUpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmMTZsZScsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCd1Y3MyJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ3Vjcy0yJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ2xhdGluMScsIFRpLkNvZGVjLkNIQVJTRVRfSVNPX0xBVElOXzEpO1xuVElfQ09ERUNfTUFQLnNldCgnYmluYXJ5JywgVGkuQ29kZWMuQ0hBUlNFVF9JU09fTEFUSU5fMSk7XG5USV9DT0RFQ19NQVAuc2V0KCdhc2NpaScsIFRpLkNvZGVjLkNIQVJTRVRfQVNDSUkpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgZGVzaXJlZCBlbmNvZGluZyBuYW1lXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gVGkuQ29kZWMgY29uc3RhbnQgdGhhdCBtYXBzIHRvIHRoZSBlbmNvZGluZ1xuICovXG5cbmZ1bmN0aW9uIGdldFRpQ29kZWNDaGFyc2V0KGVuY29kaW5nKSB7XG4gIHJldHVybiBUSV9DT0RFQ19NQVAuZ2V0KGVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIEJ1ZmZlciB1c2VzIGEgVGkuQnVmZmVyIGludGVybmFsbHkgdG8gYmFjayBpdC5cbiAqIFRoaXMgaXMgbGlrbGV5IGFuIG9yZGVyIG9mIG1hZ25pdHVkZSBzbG93ZXIgdGhhbiB1c2luZyBhIHZhcmlhbnQgdGhhdCBleHRlbmRzIFVpbnQ4QXJyYXkhXG4gKiBJIHRoaW5rIGlmIHdlJ3JlIG5vdCBhbHJlYWR5IHdyYXBwaW5nIGEgVGkuQnVmZmVyLCBpdCBtYXkgYmUgYmV0dGVyIHRvIGhhdmUgdHdvIGltcGxlbWVudGF0aW9uc1xuICogYW5kLCBsaWtlIGJyb3dzZXJpZnksIGp1c3QgZXh0ZW5kIFVpbnQ4QXJyYXkgZm9yIGFueSBCdWZmZXJzIHdlIG5lZWQgdG8gcmVhZC93cml0ZSBhIGxvdFxuICogYW5kIHRoZW4gYWRkIGEgc2ltcGxlIGNvbnZlcnNpb24gbWV0aG9kIHRvIHR1cm4gaXQgaW50byBhIFRpLkJ1ZmZlciB3aGVuIG5lZWRlZC5cbiAqXG4gKiBUaGUgVGkuQnVmZmVyIGltcGwgaGFzIHRvIGdvIHRocm91Z2ggdGhlIGJpbmRpbmcgbGF5ZXIgZm9yIHJlYWRpbmcvd3JpdGluZyBldmVyeSBieXRlLlxuICogSWYgd2UgYW50aWNpcGF0ZSB0aGUgQnVmZmVyIHN0YXlpbmcgb24gdGhlIEpTIHNpZGUsIEknbSB3aWxsaW5nIHRvIGJldCB0aGF0IHRoZSBVaW50OEFycmF5XG4gKiB0aGUgSlMgZW5naW5lIHByb3ZpZGVzIHdvdWxkIGJlICp3YXkqIGZhc3Rlci5cbiAqXG4gKiBBbHNvIG5vdGUgdGhhdCBib3RoIFRpLkJ1ZmZlciBhbmQgTm9kZSdzIEJ1ZmZlciB3ZXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBKUyBlbmdpbmVzIGhhZCB0eXBlZCBhcnJheXNcbiAqIChhbmQgVWludDhBcnJheSBpbiBwYXJ0aWN1bGFyKSBhcyBhIG1lYW5zIG9mIGVuY2Fwc3VsYXRpbmcgYSBieXRlIGFycmF5LiBXZSBzaG91bGQgY29uc2lkZXIgYWNjZXB0aW5nXG4gKiBhIFVpbnQ4QXJyYXkgaW4gYW55IG9mIG91ciBBUElzIHRoYXQgdGFrZSBhIFRpLkJ1ZmZlciBhbmQgZXZlbnR1YWxseSBkZXByZWNhdGluZy9yZW1vdmluZyBUaS5CdWZmZXIuXG4gKi9cbmNvbnN0IHtcbiAgQUxMX1BST1BFUlRJRVM6IEFMTF9QUk9QRVJUSUVTJDEsXG4gIE9OTFlfRU5VTUVSQUJMRTogT05MWV9FTlVNRVJBQkxFJDFcbn0gPSBwcm9wZXJ0eUZpbHRlcjtcbmNvbnN0IFZBTElEX0VOQ09ESU5HUyA9IFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnbGF0aW4xJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJ107IC8vIFVzZWQgdG8gY2hlYXQgZm9yIHJlYWQvd3JpdGVzIG9mIGRvdWJsZXNcblxuY29uc3QgZG91YmxlQXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KDEpO1xuY29uc3QgdWludDhEb3VibGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGRvdWJsZUFycmF5LmJ1ZmZlcik7IC8vIFVzZWQgdG8gY2hlYXQgdG8gcmVhZC93cml0ZSBmbG9hdHNcblxuY29uc3QgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5jb25zdCB1aW50OEZsb2F0QXJyYXkgPSBuZXcgVWludDhBcnJheShmbG9hdEFycmF5LmJ1ZmZlcik7IC8vIE5vZGUuanMgZG9lcyBzb21lIHZlcnkgd2VpcmQgc3R1ZmYgaGVyZVxuXG5GYXN0QnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJ1ZmZlciQxOyAvLyBuZXcgRmFzdEJ1ZmZlcigpIGNhbGxzIEJ1ZmZlciBmdW5jdGlvbj9cblxuQnVmZmVyJDEucHJvdG90eXBlID0gRmFzdEJ1ZmZlci5wcm90b3R5cGU7IC8vIFRoZW4gaXQgaGlqYWNrcyBCdWZmZXIncyBwcm90b3R5cGUgdG8gcG9pbnQgYXQgRmFzdEJ1ZmZlcidzPyFcbi8vIERvZXMgdGhpcyBlZmZlY3RpdmVseSBtZWFuIEJ1ZmZlciBleHRlbmRzIFVpbnQ4QXJyYXksIGJlY2F1c2UgRmFzdEJ1ZmZlciBkaWQ/IFRoaXMgZmFpbHMgZm9yIG1lXG4vLyBIb3cgdGhlIGhlbGwgY2FuIHdlIG1ha2UgaXQgaGFwcHk/IFdlIHJlYWxseSB3YW50IHRvIGV4dGVuZCBVaW50OEFycmF5IGlmIHdlIGNhblxuLy8gYWRkQnVmZmVyUHJvdG90eXBlTWV0aG9kcyhCdWZmZXIucHJvdG90eXBlKTsgLy8gSGVyZSdzIHdoZXJlIGl0IGhhbmdzIHNvbWUgb2YgdGhlIG1ldGhvZHNcblxuQnVmZmVyJDEucG9vbFNpemUgPSA4MTkyO1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBQcmltYXJpbHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoaXMgbW9kdWxlIHRvZ2V0aGVyIHdpdGggYG5ld0J1ZmZlcmAgdG9cbiAqIGNyZWF0ZSBhIG5ldyBCdWZmZXIgaW5zdGFuY2Ugd3JhcHBpbmcgYSBUaS5CdWZmZXIuXG4gKlxuICogQWxzbyBzdXBwb3J0cyB0aGUgZGVwcmVjYXRlZCBCdWZmZXIoKSBjb25zdHJ1Y3RvcnMgd2hpY2ggYXJlIHNhZmVcbiAqIHRvIHVzZSBvdXRzaWRlIG9mIHRoaXMgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcltdfEJ1ZmZlcnxpbnRlZ2VyfHN0cmluZ3xUaS5CdWZmZXJ9IGFyZyB0aGUgdW5kZXJseWluZyBkYXRhL2J5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBlbmNvZGluZ09yT2Zmc2V0IGVuY29kaW5nIG9mIHRoZSBzdHJpbmcsIG9yIHN0YXJ0IG9mZnNldCBvZiBhcnJheS9idWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIGxlbmd0aCBvZiB0aGUgdW5kZXJseWluZyBhcnJheS9idWZmZXIgdG8gd3JhcFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIkMShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnLmFwaU5hbWUgIT09ICdUaS5CdWZmZXInKSB7XG4gICAgc2hvd0ZsYWdnZWREZXByZWNhdGlvbigpO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBcInN0cmluZ1wiLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFyZ31gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJ1ZmZlciQxLmFsbG9jKGFyZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlciQxLmZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9IC8vIFRoZSBzbG93IGNhc2UgLSB3ZSdyZSB3cmFwcGluZyBhIFRpLkJ1ZmZlclxuXG5cbiAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyW118QnVmZmVyfHN0cmluZ30gdmFsdWUgdmFsdWUgd2UncmUgd3JhcHBpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IGVuY29kaW5nT3JPZmZzZXQgZW5jb2Rpbmcgb2YgdGhlIHN0cmluZywgb3Igc3RhcnQgb2Zmc2V0IG9mIGFycmF5L2J1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggbGVuZ3RoIG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5L2J1ZmZlciB0byB3cmFwXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuQnVmZmVyJDEuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXkodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIkMS5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQnVmZmVyKHZhbHVlKTtcbiAgICB9IC8vIFdlIHdhbnQgdG8gbGltaXQgdGhlIHVzZSBvZiBTbG93QnVmZmVycyB0byBvbmx5IHdoZW4gd2UncmUgd3JhcHBpbmcgYSBUaS5CdWZmZXIsIGhvcGVmdWxseSFcblxuXG4gICAgaWYgKHZhbHVlLmFwaU5hbWUgJiYgdmFsdWUuYXBpTmFtZSA9PT0gJ1RpLkJ1ZmZlcicpIHtcbiAgICAgIHJldHVybiBTbG93QnVmZmVyLmZyb21UaUJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFxcJ3ZhbHVlXFwnIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGU6IFxcJ3N0cmluZ1xcJywgXFwnQXJyYXlcXCcsIFxcJ0J1ZmZlclxcJywgXFwnVGkuQnVmZmVyXFwnJyk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBvYmogQXJyYXlCdWZmZXIgdG8gd3JhcFxuICogQHBhcmFtIHtudW1iZXJ9IFtieXRlT2Zmc2V0PTBdIGJ5dGUgb2Zmc3RlIHRvIGJlZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gbGVuZ3RoIHRvIHdyYXBcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIob2JqLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29udmVydCBieXRlT2Zmc2V0IHRvIGludGVnZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDtcblxuICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1heExlbmd0aCA9IG9iai5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldDtcblxuICBpZiAobWF4TGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoJ29mZnNldCcpO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnZlcnQgbGVuZ3RoIHRvIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgY29kZXMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKCdsZW5ndGgnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIob2JqLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdmFsdWUgdG8gd3JhcFxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIGNoYXJhY3RlciBlbmNvZGluZ1xuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGlmICghQnVmZmVyJDEuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICB9XG5cbiAgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICBjb25zdCBibG9iID0gVGkuVXRpbHMuYmFzZTY0ZGVjb2RlKHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoYmxvYi50b0FycmF5QnVmZmVyKCkpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgIHJldHVybiBmcm9tQXJyYXkoc3RyaW5nVG9IZXhCeXRlcyh2YWx1ZSkpO1xuICB9IC8vIENvbnZlcnQgdGhlIFNsb3dCdWZmZXIgdG8gYSBmYXN0IGJ1ZmZlciBieSBqdXN0IGNvcHlpbmcgYnl0ZXMgcmVjdXJzaXZlbHkgaGVyZVxuXG5cbiAgcmV0dXJuIGZyb21CdWZmZXIoU2xvd0J1ZmZlci5mcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZykpO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJbXXxVaW50OEFycmF5fGFycmF5fSB2YWx1ZSB2YWx1ZXMgdG8gd3JhcFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZSkge1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcigpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHZhbHVlKTtcbn1cbi8qKlxuICogSWRlYWxseSB0aGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB3ZSdyZSBjb3B5aW5nIGEgU2xvd0J1ZmZlciBpbnRvIGEgbmV3IEZhc3RCdWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBidWZmZXIgdG8gY29weVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIodmFsdWUpIHtcbiAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoKTtcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhbHVlLmNvcHkoYnVmZmVyLCAwLCAwLCBsZW5ndGgpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyJDEsIFVpbnQ4QXJyYXkpOyAvLyBXaGF0IGlzIHRoaXMgZG9pbmc/ISBNYWtpbmcgQnVmZmVyLnByb3RvdHlwZSBwb2ludCBhdCBVaW50OEFycmF5IG5vd1xuXG4vKipcbiAqIDAgaXMgcmV0dXJuZWQgaWYgdGFyZ2V0IGlzIHRoZSBzYW1lIGFzIGJ1ZlxuICogMSBpcyByZXR1cm5lZCBpZiB0YXJnZXQgc2hvdWxkIGNvbWUgYmVmb3JlIGJ1ZiB3aGVuIHNvcnRlZC5cbiAqIC0xIGlzIHJldHVybmVkIGlmIHRhcmdldCBzaG91bGQgY29tZSBhZnRlciBidWYgd2hlbiBzb3J0ZWQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0IEJ1ZmZlciB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3RhcmdldFN0YXJ0PTBdIGluZGV4IHRvIHN0YXJ0IGluIHRhcmdldFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbdGFyZ2V0RW5kPXRhcmdldC5sZW5ndGhdIGluZGV4IHRvIGVuZCBpbiB0YXJnZXRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZVN0YXJ0PTBdIGluZGV4IHRvIHN0YXJ0IGluIHRoaXMgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VFbmQ9dGhpcy5sZW5ndGhdIGluZGV4IHRvIGVuZCBpbiB0aGlzIEJ1ZmZlclxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuQnVmZmVyJDEucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRTdGFydCwgdGFyZ2V0RW5kLCBzb3VyY2VTdGFydCwgc291cmNlRW5kKSB7XG4gIGlmICghQnVmZmVyJDEuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYnVmMX1gKTtcbiAgfVxuXG4gIGlmICh0YXJnZXRTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGFyZ2V0U3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHNvdXJjZVN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VTdGFydCA9IDA7XG4gIH1cblxuICBpZiAodGFyZ2V0RW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0YXJnZXRFbmQgPSB0YXJnZXQubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHNvdXJjZUVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlRW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gLy8gRVJSX09VVF9PRl9SQU5HRSBpcyB0aHJvd24gaWYgdGFyZ2V0U3RhcnQgPCAwLCBzb3VyY2VTdGFydCA8IDAsIHRhcmdldEVuZCA+IHRhcmdldC5ieXRlTGVuZ3RoLCBvciBzb3VyY2VFbmQgPiBzb3VyY2UuYnl0ZUxlbmd0aFxuXG5cbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCB8fCBzb3VyY2VTdGFydCA8IDAgfHwgdGFyZ2V0RW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCBzb3VyY2VFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTsgLy8gRklYTUU6IHNldCBcImNvZGVcIiB0byBFUlJfSU5ERVhfT1VUX09GX1JBTkdFXG4gIH0gLy8gVXNlIHNsaWNlcyB0byBtYWtlIHRoZSBsb29wIGVhc2llclxuXG5cbiAgY29uc3Qgc291cmNlID0gdGhpcy5zbGljZShzb3VyY2VTdGFydCwgc291cmNlRW5kKTtcbiAgY29uc3Qgc291cmNlTGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgY29uc3QgZGVzdCA9IHRhcmdldC5zbGljZSh0YXJnZXRTdGFydCwgdGFyZ2V0RW5kKTtcbiAgY29uc3QgZGVzdExlbmd0aCA9IGRlc3QubGVuZ3RoO1xuICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihzb3VyY2VMZW5ndGgsIGRlc3RMZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IGRlc3QuZ2V0QWRqdXN0ZWRJbmRleChpKTtcbiAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZS5nZXRBZGp1c3RlZEluZGV4KGkpO1xuXG4gICAgaWYgKHRhcmdldFZhbHVlICE9PSBzb3VyY2VWYWx1ZSkge1xuICAgICAgLy8gTm8gbWF0Y2ghIFJldHVybiAxIG9yIC0xIGJhc2VkIG9uIHdoYXQgaXMgZ3JlYXRlciFcbiAgICAgIGlmIChzb3VyY2VWYWx1ZSA8IHRhcmdldFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9IC8vIHNvcnQgYmFzZWQgb24gbGVuZ3RoIVxuXG5cbiAgaWYgKHNvdXJjZUxlbmd0aCA8IGRlc3RMZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoc291cmNlTGVuZ3RoID4gZGVzdExlbmd0aCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBDb3BpZXMgZnJvbSB0aGlzIHRvIHRhcmdldFxuICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldCBkZXN0aW5hdGlvbiB3ZSdyZSBjb3B5aW5nIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3RhcmdldFN0YXJ0PTBdIHN0YXJ0IGluZGV4IHRvIGNvcHkgaW50byBpbiBkZXN0aW5hdGlvbiBCdWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZVN0YXJ0PTBdIHN0YXJ0IGluZGV4IHRvIGNvcHkgZnJvbSB3aXRoaW4gYHRoaXNgXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VFbmQ9dGhpcy5sZW5ndGhdIGVuZCBpbmRleCB0byBjb3B5IGZyb20gd2l0aGluIGB0aGlzYFxuICogQHJldHVybnMge2ludGVnZXJ9IG51bWJlciBvZiBieXRlcyBjb3BpZWRcbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgaWYgKHRhcmdldFN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0YXJnZXRTdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc291cmNlU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzb3VyY2VFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZUVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHNvdXJjZVN0YXJ0ID09PSBzb3VyY2VFbmQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gVE9ETzogY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XG5cblxuICBsZXQgbGVuZ3RoID0gc291cmNlRW5kIC0gc291cmNlU3RhcnQ7IC8vIENhcCBsZW5ndGggdG8gcmVtYWluaW5nIGJ5dGVzIGluIHRhcmdldCFcblxuICBjb25zdCByZW1haW5pbmcgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQ7XG5cbiAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgIHNvdXJjZUVuZCA9IHNvdXJjZVN0YXJ0ICsgcmVtYWluaW5nO1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSAvLyBEZXRlcm1pbmUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3ZSdsbCBjb3B5LCBjb25zdHJhaW4gYnkgc291cmNlIGJ1ZmZlciBsZW5ndGggYXMgd2VsbCBhcyB0YXJnZXQgKGFib3ZlKVxuXG5cbiAgbGV0IG51bUJ5dGVzID0gbGVuZ3RoO1xuICBjb25zdCBzb3VyY2VMZW4gPSB0aGlzLmxlbmd0aCAtIHNvdXJjZVN0YXJ0O1xuXG4gIGlmIChudW1CeXRlcyA+IHNvdXJjZUxlbikge1xuICAgIG51bUJ5dGVzID0gc291cmNlTGVuO1xuICB9IC8vIFRPRE86IGhhbmRsZSBvdmVybGFwIHdoZW4gdGFyZ2V0ID09PSB0aGlzIVxuICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIHRha2UgdGFyZ2V0IGJ5dGVPZmZzZXQgaW50byBhY2NvdW50IGhlcmU/XG5cblxuICBsZXQgc291cmNlID0gdGhpcztcblxuICBpZiAoc291cmNlU3RhcnQgIT09IDAgfHwgc291cmNlRW5kIDwgc291cmNlLmxlbmd0aCkge1xuICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyBzb3VyY2VTdGFydCwgbnVtQnl0ZXMpO1xuICB9XG5cbiAgdGFyZ2V0LnNldChzb3VyY2UsIHRhcmdldFN0YXJ0KTtcbiAgcmV0dXJuIG51bUJ5dGVzO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBpdGVyYXRvciBvZiBbaW5kZXgsIGJ5dGVdIHBhaXJzIGZyb20gdGhlIGNvbnRlbnRzIG9mIGJ1Zi5cbiAqIEByZXR1cm5zIHtJdGVyYXRvcn1cbiAqL1xuLy8gVE9ETzogSXMgdGhpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgU2xvd0J1ZmZlcj9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYnVmZmVyID0gdGhpcztcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZCA9IHRoaXMubGVuZ3RoO1xuICBjb25zdCBlbnRyeUl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiBbbmV4dEluZGV4LCBidWZmZXIuZ2V0QWRqdXN0ZWRJbmRleChuZXh0SW5kZXgpXSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHJldHVybiBlbnRyeUl0ZXJhdG9yO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlckJ1ZmZlcikge1xuICBpZiAoIUJ1ZmZlciQxLmlzQnVmZmVyKG90aGVyQnVmZmVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKTtcbiAgfVxuXG4gIGlmIChvdGhlckJ1ZmZlciA9PT0gdGhpcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlckJ1ZmZlcikgPT09IDA7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VUludDhBcnJheXxpbnRlZ2VyfSB2YWx1ZSBUaGUgdmFsdWUgd2l0aCB3aGljaCB0byBmaWxsIGBidWZgLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byBmaWxsIGBidWZgXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmRdIFdoZXJlIHRvIHN0b3AgZmlsbGluZyBidWYgKG5vdCBpbmNsdXNpdmUpLiBgYnVmLmxlbmd0aGAgYnkgZGVmYXVsdFxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBlbmNvZGluZyBmb3IgYHZhbHVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICogQHJldHVybnMge3RoaXN9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBlbmQsIGVuY29kaW5nKSB7XG4gIGNvbnN0IG9mZnNldFR5cGUgPSB0eXBlb2Ygb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXRUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHZhbHVlIHN1cHBsaWVkXG4gICAgb2Zmc2V0ID0gMDtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfSBlbHNlIGlmIChvZmZzZXRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIC8vIHZhbHVlLCBlbmNvZGluZyBzdXBwbGllZFxuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IDA7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyB2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZyBzdXBwbGllZFxuICAgIGVuY29kaW5nID0gZW5kO1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgdGhpcy5fZmlsbCh2YWx1ZSwgb2Zmc2V0LCBlbmQsIGVuY29kaW5nKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheS5wcm90b3R5cGUpO1xuY29uc3QgVHlwZWRBcnJheVByb3RvX2J5dGVMZW5ndGggPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlTGVuZ3RoJykuZ2V0O1xuY29uc3QgVHlwZWRBcnJheUZpbGwgPSBUeXBlZEFycmF5UHJvdG90eXBlLmZpbGw7XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5fZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBlbmQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgLy8gT09CIGNoZWNrXG4gICAgY29uc3QgYnl0ZUxlbiA9IFR5cGVkQXJyYXlQcm90b19ieXRlTGVuZ3RoLmNhbGwodGhpcyk7XG4gICAgY29uc3QgZmlsbExlbmd0aCA9IGVuZCAtIG9mZnNldDtcblxuICAgIGlmIChvZmZzZXQgPiBlbmQgfHwgZmlsbExlbmd0aCArIG9mZnNldCA+IGJ5dGVMZW4pIHtcbiAgICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKTtcbiAgICB9XG5cbiAgICBUeXBlZEFycmF5RmlsbC5jYWxsKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGVuZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnVmVG9GaWxsV2l0aCA9IFNsb3dCdWZmZXIuZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICAgIGNvbnN0IGZpbGxCdWZMZW5ndGggPSBidWZUb0ZpbGxXaXRoLmxlbmd0aDtcblxuICAgIGlmIChmaWxsQnVmTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHZhbGlkIGZpbGwgZGF0YScpO1xuICAgIH1cblxuICAgIGlmIChmaWxsQnVmTGVuZ3RoID09PSAxKSB7XG4gICAgICBUeXBlZEFycmF5RmlsbC5jYWxsKHRoaXMsIGJ1ZlRvRmlsbFdpdGguX3RpQnVmZmVyWzBdLCBvZmZzZXQsIGVuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIG11bHRpcGxlIGJ5dGUgZmlsbCFcblxuXG4gICAgY29uc3QgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBhY2NvdW50IGZvciBieXRlT2Zmc2V0IGhlcmUgKG9uIGB0aGlzYCwgbm90IG9uIHRoZSBidWZmZXIgd2UganVzdCBjcmVhdGVkKT9cbiAgICAgIGNvbnN0IGZpbGxDaGFyID0gYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbaSAlIGZpbGxCdWZMZW5ndGhdO1xuICAgICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyBvZmZzZXQsIGZpbGxDaGFyKTtcbiAgICB9XG4gIH1cbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uICh2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxpbnRlZ2VyfSB2YWx1ZSBXaGF0IHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2J5dGVPZmZzZXQ9MF0gV2hlcmUgdG8gYmVnaW4gc2VhcmNoaW5nIGluIGJ1Zi4gSWYgbmVnYXRpdmUsIHRoZW4gb2Zmc2V0IGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZW5kIG9mIGJ1ZlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIElmIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIHRvIGRldGVybWluZSB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHNlYXJjaGVkIGZvciBpbiBidWZcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdmFsdWUgaW4gYnVmLCBvciAtMSBpZiBidWYgZG9lcyBub3QgY29udGFpbiB2YWx1ZS5cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHZhbHVlLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBlbXB0eSBidWZmZXI/IGNhbid0IGZpbmQgYW55dGhpbmchXG4gICAgcmV0dXJuIC0xO1xuICB9IC8vIGlmIGJ5dGVPZmZzZXQgaXMgdW5kZWZpbmVkLCBtYWtlIGl0IDBcblxuXG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZiBpdCdzIGEgc3RyaW5nLCB0aGF0J3MgYWN0dWFsbHkgZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH0gLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbiBlbmNvZGluZyB5ZXQsIHVzZSB1dGY4XG5cblxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgLy8gY29udmVydCBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgYnl0ZU9mZnNldCA9IHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldDtcblxuICAgIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgICAgLy8gc3RpbGwgbmVnYXRpdmU/IHN0YXJ0IGF0IDBcbiAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBjYW4ndCBmaW5kIHBhc3QgZW5kIG9mIGJ1ZmZlciFcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdmFsdWUgJj0gMHhGRjsgLy8gY2xhbXAgdG8gMjU1XG4gICAgLy8gVGhpcyBpcyBhIHNpbXBsZXIgY2FzZSwgd2UgaGF2ZSBhIHNpbmdsZSBieXRlIHdlIG5lZWQgdG8gc2VhcmNoIGZvclxuICAgIC8vIHNvIGp1c3QgbG9vcCB0aHJvdWdoIGFuZCB0cnkgdG8gZmluZCBpdFxuXG4gICAgcmV0dXJuIGluZGV4T2YodGhpcywgdmFsdWUsIGJ5dGVPZmZzZXQpO1xuICB9IC8vIGNvZXJjZSBhIHN0cmluZyB0byBhIEJ1ZmZlclxuXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nKTtcbiAgfSAvLyB2YWx1ZSBpcyBub3cgYSBCdWZmZXIuLi5cblxuXG4gIGNvbnN0IG1hdGNoTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gIGlmIChtYXRjaExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTsgLy8gbmV2ZXIgZmluZCBlbXB0eSB2YWx1ZSFcbiAgfVxuXG4gIGlmIChtYXRjaExlbmd0aCA9PT0gMSkge1xuICAgIC8vIHNpbXBsZSBjYXNlLCBtYXRjaCBvbmUgYnl0ZSFcbiAgICByZXR1cm4gaW5kZXhPZih0aGlzLCB2YWx1ZVswXSwgYnl0ZU9mZnNldCk7XG4gIH1cblxuICBsZXQgY3VycmVudEluZGV4ID0gYnl0ZU9mZnNldDtcbiAgY29uc3QgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChtYXRjaExlbmd0aCA+IHRoaXNMZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7IC8vIGNhbid0IG1hdGNoIGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhbiB0aGlzIEJ1ZmZlciFcbiAgfSAvLyBGSVhNRTogQ2FuIHdlIHJld3JpdGUgdGhpcyBpbiBhIGxlc3MgZnVua3kgd2F5P1xuICAvLyBGSVhNRTogQ2FuIHN0b3AgZWFybGllciBiYXNlZCBvbiBtYXRjaExlbmd0aCFcblxuXG4gIGZpcnN0TWF0Y2g6IHdoaWxlIChjdXJyZW50SW5kZXggPCB0aGlzTGVuZ3RoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sYWJlbHNcbiAgICAvLyBtYXRjaCBmaXJzdCBieXRlIVxuICAgIGxldCBmaXJzdEJ5dGVNYXRjaCA9IGluZGV4T2YodGhpcywgdmFsdWVbMF0sIGN1cnJlbnRJbmRleCk7XG5cbiAgICBpZiAoZmlyc3RCeXRlTWF0Y2ggPT09IC0xKSB7XG4gICAgICAvLyBjb3VsZG4ndCBldmVuIG1hdGNoIHRoZSB2ZXJ5IGZpcnN0IGJ5dGUsIHNvIG5vIG1hdGNoIG92ZXJhbGwhXG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAvLyBvaywgd2UgZm91bmQgdGhlIGZpcnN0IGJ5dGUsIG5vdyB3ZSBuZWVkIHRvIHNlZSBpZiB0aGUgbmV4dCBjb25zZWN1dGl2ZSBieXRlcyBtYXRjaCFcblxuXG4gICAgZm9yIChsZXQgeCA9IDE7IHggPCBtYXRjaExlbmd0aDsgeCsrKSB7XG4gICAgICBpZiAoZmlyc3RCeXRlTWF0Y2ggKyB4ID49IHRoaXNMZW5ndGgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gZmlyc3RCeXRlTWF0Y2ggKyAxOyAvLyBtb3ZlIHBhc3Qgb3VyIGZpcnN0IG1hdGNoXG5cbiAgICAgICAgY29udGludWUgZmlyc3RNYXRjaDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sYWJlbHNcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbZmlyc3RCeXRlTWF0Y2ggKyB4XSAhPT0gdmFsdWVbeF0pIHtcbiAgICAgICAgLy8gZGlkbid0IG1hdGNoIVxuICAgICAgICBjdXJyZW50SW5kZXggPSBmaXJzdEJ5dGVNYXRjaCArIDE7IC8vIG1vdmUgcGFzdCBvdXIgZmlyc3QgbWF0Y2hcblxuICAgICAgICBjb250aW51ZSBmaXJzdE1hdGNoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaXJzdEJ5dGVNYXRjaDsgLy8gdGhlIHJlc3QgbWF0Y2hlZCwgaHVycmF5IVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICBjb25zdCBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgY29uc3QgbXlJdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobmV4dEluZGV4IDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICB2YWx1ZTogbmV4dEluZGV4LFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG15SXRlcmF0b3I7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gOFxuICogQHJldHVybnMge2RvdWJsZX0gUmVhZHMgYSA2NC1iaXQgZG91YmxlIGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpOyAvLyBOb2RlIGNoZWF0cyBhbmQgdXNlcyBhIEZsb2F0NjRBcnJheSBhbmQgVUludDhBcnJheSBiYWNrZWQgYnkgdGhlIHNhbWUgYnVmZmVyXG4gIC8vIHNvIGJhc2ljYWxseSBpdCByZWFkcyBpbiB0aGUgYnl0ZXMgc3R1ZmZpbmcgdGhlbSBpbnRvIFVpbnQ4QXJyYXksIHRoZW4gcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgRmxvYXQ2NEFycmF5XG4gIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgTEUgc3lzdGVtIGJ5dGVPcmRlclxuXG4gIHVpbnQ4RG91YmxlQXJyYXlbN10gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs2XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzVdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNF0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVszXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzJdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVswXSA9IHRoaXNbb2Zmc2V0KytdO1xuICByZXR1cm4gZG91YmxlQXJyYXlbMF07XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gOFxuICogQHJldHVybnMge2RvdWJsZX0gUmVhZHMgYSA2NC1iaXQgZG91YmxlIGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpOyAvLyBOb2RlIGNoZWF0cyBhbmQgdXNlcyBhIEZsb2F0NjRBcnJheSBhbmQgVUludDhBcnJheSBiYWNrZWQgYnkgdGhlIHNhbWUgYnVmZmVyXG4gIC8vIHNvIGJhc2ljYWxseSBpdCByZWFkcyBpbiB0aGUgYnl0ZXMgc3R1ZmZpbmcgdGhlbSBpbnRvIFVpbnQ4QXJyYXksIHRoZW4gcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgRmxvYXQ2NEFycmF5XG4gIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgTEUgc3lzdGVtIGJ5dGVPcmRlclxuXG4gIHVpbnQ4RG91YmxlQXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVsxXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzJdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs0XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzVdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs3XSA9IHRoaXNbb2Zmc2V0KytdO1xuICByZXR1cm4gZG91YmxlQXJyYXlbMF07XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNFxuICogQHJldHVybnMge2Zsb2F0fSBSZWFkcyBhIDMyLWJpdCBmbG9hdCBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCB3aXRoIHNwZWNpZmllZCBlbmRpYW4gZm9ybWF0XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpOyAvLyBOb2RlIGNoZWF0cyBhbmQgdXNlcyBhIEZsb2F0MzJBcnJheSBhbmQgVUludDhBcnJheSBiYWNrZWQgYnkgdGhlIHNhbWUgYnVmZmVyXG4gIC8vIHNvIGJhc2ljYWxseSBpdCByZWFkcyBpbiB0aGUgYnl0ZXMgc3R1ZmZpbmcgdGhlbSBpbnRvIFVpbnQ4QXJyYXksIHRoZW4gcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgRmxvYXQzMkFycmF5XG4gIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgTEUgc3lzdGVtIGJ5dGVPcmRlclxuXG4gIHVpbnQ4RmxvYXRBcnJheVszXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVswXSA9IHRoaXNbb2Zmc2V0KytdO1xuICByZXR1cm4gZmxvYXRBcnJheVswXTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0XG4gKiBAcmV0dXJucyB7ZmxvYXR9IFJlYWRzIGEgMzItYml0IGZsb2F0IGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQzMkFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDMyQXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgdWludDhGbG9hdEFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVsxXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBmbG9hdEFycmF5WzBdO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDEuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50OChvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCAyKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjb25zdCB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDE2TEUob2Zmc2V0KTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgMik7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDQpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCA0KTtcbn07XG4vKipcbiAqIFJlYWRzIGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzIGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IGFuZCBpbnRlcnByZXRzIHRoZSByZXN1bHQgYXMgYSB0d28ncyBjb21wbGVtZW50IHNpZ25lZCB2YWx1ZS4gU3VwcG9ydHMgdXAgdG8gNDggYml0cyBvZiBhY2N1cmFjeS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCk7XG59O1xuLyoqXG4gKiBSZWFkcyBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlcyBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCBhbmQgaW50ZXJwcmV0cyB0aGUgcmVzdWx0IGFzIGEgdHdvJ3MgY29tcGxlbWVudCBzaWduZWQgdmFsdWUuIFN1cHBvcnRzIHVwIHRvIDQ4IGJpdHMgb2YgYWNjdXJhY3kuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIHVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBjb25zdCB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIGJ5dGVMZW5ndGgpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDEuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDEpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpOyAvLyBmaXJzdCBieXRlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBzZWNvbmQgYnl0ZVxuXG4gIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7IC8vIGZpcnN0IGJ5dGUgT1InZCB3aXRoIHNlY29uZCBieXRlIHNoaWZ0ZWRcblxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdICogMHgxMDAwMDAwICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTsgLy8gcmF0aGVyIHRoYW4gc2hpZnRpbmcgYnkgPDwgMjQsIG11bHRpcGx5IHRoZSBmaXJzdCBieXRlIGFuZCBhZGQgaXQgaW4gc28gd2UgZG9uJ3QgcmV0YWluIHRoZSBcInNpZ24gYml0XCJcbiAgLy8gKGJlY2F1c2UgYml0LXdpc2Ugb3BlcmF0b3JzIGFzc3VtZSBhIDMyLWJpdCBudW1iZXIpXG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgKyB0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwOyAvLyByYXRoZXIgdGhhbiBzaGlmdGluZyBieSA8PCAyNCwgbXVsdGlwbHkgdGhlIGxhc3QgYnl0ZSBhbmQgYWRkIGl0IGluIHNvIHdlIGRvbid0IHJldGFpbiB0aGUgXCJzaWduIGJpdFwiXG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBsZXQgcmVzdWx0ID0gMDtcbiAgbGV0IG11bHRpcGxpZXIgPSAxOyAvLyB3ZSB1c2UgYSBtdWx0aXBsZXIgZm9yIGVhY2ggYnl0ZVxuICAvLyB3ZSdyZSBkb2luZyB0aGUgc2FtZSBsb29wIGFzICNyZWFkVUludExFLCBqdXN0IGJhY2t3YXJkcyFcblxuICBmb3IgKGxldCBpID0gYnl0ZUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyBpKSAqIG11bHRpcGxpZXI7XG4gICAgbXVsdGlwbGllciAqPSAweDEwMDsgLy8gbW92ZSBtdWx0aXBsaWVyIHRvIG5leHQgYnl0ZVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGxldCByZXN1bHQgPSAwO1xuICBsZXQgbXVsdGlwbGllciA9IDE7IC8vIHdlIHVzZSBhIG11bHRpcGxlciBmb3IgZWFjaCBieXRlXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGkpICogbXVsdGlwbGllcjtcbiAgICBtdWx0aXBsaWVyICo9IDB4MTAwOyAvLyBtb3ZlIG11bHRpcGxpZXIgdG8gbmV4dCBieXRlXG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gV2hlcmUgdGhlIG5ldyBgQnVmZmVyYCB3aWxsIHN0YXJ0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kPXRoaXMubGVuZ3RoXSBXaGVyZSB0aGUgbmV3IEJ1ZmZlciB3aWxsIGVuZCAobm90IGluY2x1c2l2ZSkuIERlZmF1bHQ6IGBidWYubGVuZ3RoYC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICBjb25zdCB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzTGVuZ3RoICsgc3RhcnQ7XG5cbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAvLyBpZiB0aGlzIGlzIHN0aWxsIG5lZ2F0aXZlLCB1c2UgMCAodGhhdCBtYXRjaGVzIE5vZGUpXG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5kID0gdGhpc0xlbmd0aDtcbiAgfSBlbHNlIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kID0gdGhpc0xlbmd0aCArIGVuZDtcbiAgfSAvLyBTcGVjaWZ5aW5nIGVuZCBncmVhdGVyIHRoYW4gYnVmLmxlbmd0aCB3aWxsIHJldHVybiB0aGUgc2FtZSByZXN1bHQgYXMgdGhhdCBvZiBlbmQgZXF1YWwgdG8gYnVmLmxlbmd0aC5cblxuXG4gIGlmIChlbmQgPiB0aGlzTGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpc0xlbmd0aDtcbiAgfSAvLyBXaGF0IGlmIGVuZCBpcyBsZXNzIHRoYW4gc3RhcnQ/XG5cblxuICBsZXQgbGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG5cbiAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgbGVuZ3RoID0gMDsgLy8gcmV0dXJuIGVtcHR5IHZpZXcgb2YgQnVmZmVyISByZXRhaW4gYnl0ZSBvZmZzZXQsIHNldCBsZW5ndGggdG8gMFxuICB9IC8vIFdyYXAgdGhlIHNhbWUgQXJyYXlCdWZmZXIgb2JqZWN0IGJ1dCBzcGVjaWZ5IHRoZSBzdGFydC9lbmQgdG8gXCJjcm9wXCIgd2l0aFxuXG5cbiAgcmV0dXJuIHRoaXMuX3NsaWNlKHRoaXMuYnl0ZU9mZnNldCArIHN0YXJ0LCBsZW5ndGgpO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLl9zbGljZSA9IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIodGhpcy5idWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIFdoZXJlIHRoZSBuZXcgYEJ1ZmZlcmAgd2lsbCBzdGFydC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZD10aGlzLmxlbmd0aF0gV2hlcmUgdGhlIG5ldyBCdWZmZXIgd2lsbCBlbmQgKG5vdCBpbmNsdXNpdmUpLiBEZWZhdWx0OiBgYnVmLmxlbmd0aGAuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnN1YmFycmF5ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMuc2xpY2Uoc3RhcnQsIGVuZCk7XG59O1xuLyoqXG4gKiBJbnRlcnByZXRzIGJ1ZiBhcyBhbiBhcnJheSBvZiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlcnMgYW5kIHN3YXBzIHRoZSBieXRlIG9yZGVyIGluLXBsYWNlLlxuICogVGhyb3dzIEVSUl9JTlZBTElEX0JVRkZFUl9TSVpFIGlmIGJ1Zi5sZW5ndGggaXMgbm90IGEgbXVsdGlwbGUgb2YgMi5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpO1xuICAgIGNvbnN0IHNlY29uZCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgMSk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGksIHNlY29uZCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyAxLCBmaXJzdCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEludGVycHJldHMgYnVmIGFzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyBhbmQgc3dhcHMgdGhlIGJ5dGUgb3JkZXIgaW4tcGxhY2UuXG4gKiBUaHJvd3MgRVJSX0lOVkFMSURfQlVGRkVSX1NJWkUgaWYgYnVmLmxlbmd0aCBpcyBub3QgYSBtdWx0aXBsZSBvZiA0LlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJyk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSk7XG4gICAgY29uc3Qgc2Vjb25kID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAxKTtcbiAgICBjb25zdCB0aGlyZCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgMik7XG4gICAgY29uc3QgZm91cnRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAzKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSwgZm91cnRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDEsIHRoaXJkKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDIsIHNlY29uZCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyAzLCBmaXJzdCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEludGVycHJldHMgYnVmIGFzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VycyBhbmQgc3dhcHMgdGhlIGJ5dGUgb3JkZXIgaW4tcGxhY2UuXG4gKiBUaHJvd3MgRVJSX0lOVkFMSURfQlVGRkVSX1NJWkUgaWYgYnVmLmxlbmd0aCBpcyBub3QgYSBtdWx0aXBsZSBvZiA4LlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJyk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA4KSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSk7XG4gICAgY29uc3Qgc2Vjb25kID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAxKTtcbiAgICBjb25zdCB0aGlyZCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgMik7XG4gICAgY29uc3QgZm91cnRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAzKTtcbiAgICBjb25zdCBmaWZ0aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgNCk7XG4gICAgY29uc3Qgc2l4dGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDUpO1xuICAgIGNvbnN0IHNldmVudGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDYpO1xuICAgIGNvbnN0IGVpZ2h0aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgNyk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGksIGVpZ2h0aCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyAxLCBzZXZlbnRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDIsIHNpeHRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDMsIGZpZnRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDQsIGZvdXJ0aCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyA1LCB0aGlyZCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyA2LCBzZWNvbmQpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgNywgZmlyc3QpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICAvLyBUYWtlIGFkdmFudGFnZSBvZiBzbGljZSB3b3JraW5nIG9uIFwiQXJyYXktbGlrZVwiIG9iamVjdHMgKGp1c3QgbGlrZSBgYXJndW1lbnRzYClcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zbGljZSNBcnJheS1saWtlX29iamVjdHNcbiAgICBkYXRhOiBbXS5zbGljZS5jYWxsKHRoaXMpXG4gIH07XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gVGhlIGNoYXJhY3RlciBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIFRoZSBieXRlIG9mZnNldCB0byBzdGFydCBkZWNvZGluZyBhdFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kXSBUaGUgYnl0ZSBvZmZzZXQgdG8gc3RvcCBkZWNvZGluZyBhdCAobm90IGluY2x1c2l2ZSkuIGBidWYubGVuZ3RoYCBkZWZhdWx0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIC8vIGZhc3QgY2FzZSBvZiBubyBhcmdzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMudG9UaUJ1ZmZlcigpLnRvU3RyaW5nKCk7XG4gIH1cblxuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPj0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnOyAvLyBzdGFydCBpcyBwYXN0IGVuZCBvZiBidWZmZXIsIHJldHVybiBlbXB0eSBzdHJpbmdcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgdHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChlbmQgPiBsZW5ndGggfHwgdHlwZW9mIGVuZCAhPT0gJ251bWJlcicpIHtcbiAgICAvLyBubyBlbmQgc3BlY2lmaWVkLCBvciBwYXN0IGVuZCBvZiBidWZmZXIsIHVzZSBsZW5ndGggb2YgYnVmZmVyXG4gICAgZW5kID0gbGVuZ3RoO1xuICB9IC8vIGVsc2Uga2VlcCBlbmQgYXMgcGFzc2VkIGluXG5cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnOyAvLyBpZiBlbmQgaXMgYmVmb3JlIHN0YXJ0IHJldHVybiBlbXB0eSBzdHJpbmdcbiAgfSAvLyBJZiBzdGFydCAhPT0gMCBhbmQgZW5kICE9PSBsZW5ndGgsIG1heWJlIHdlIHNob3VsZCBkbyBhIEJ1ZmZlci5zdWJhcnJheS9zbGljZSBvdmVyIHRoZSByYW5nZSBhbmQgY2FsbCB0b1N0cmluZygpIG9uIHRoYXQ/XG5cblxuICBpZiAoc3RhcnQgIT09IDAgfHwgZW5kICE9PSBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZyk7XG4gIH0gLy8gYmFzZSBjYXNlLCBzdGFydCBpcyAwLCBlbmQgaXMgbGVuZ3RoXG5cblxuICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9IGVsc2Uge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTsgLy8gVGhyb3cgaWYgYmFkIGVuY29kaW5nIVxuXG4gICAgaWYgKCFCdWZmZXIkMS5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5rbm93biBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04Jykge1xuICAgIHJldHVybiB0aGlzLnRvVGlCdWZmZXIoKS50b1N0cmluZygpOyAvLyB3ZSByZXR1cm4gdXRmLTggYnkgZGVmYXVsdCBuYXRpdmVseVxuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgIHJldHVybiBUaS5VdGlscy5iYXNlNjRlbmNvZGUodGhpcy50b1RpQnVmZmVyKCkudG9CbG9iKCkpLnRvU3RyaW5nKCk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHRoaXMuaGV4U2xpY2UoMCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2xhdGluMScgfHwgZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgbGV0IGxhdGluMVN0cmluZyA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgLy8gZWFjaCBvbmUgaXMgYSBcImJ5dGVcIlxuICAgICAgbGF0aW4xU3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF0aW4xU3RyaW5nO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgbGV0IGFzY2lpID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyB3ZSBzdG9yZSBieXRlcyAoOC1iaXQpLCBidXQgYXNjaWkgaXMgNy1iaXQuIE5vZGUgXCJtYXNrc1wiIHRoZSBsYXN0IGJpdCBvZmYsIHNvIGxldCdzIGRvIHRoZSBzYW1lXG4gICAgICBhc2NpaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKSAmIDB4N0YpO1xuICAgIH1cblxuICAgIHJldHVybiBhc2NpaTtcbiAgfSAvLyBVQ1MyL1VURjE2XG5cblxuICByZXR1cm4gdGhpcy51Y3MyU2xpY2UoMCwgbGVuZ3RoKTtcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5nZXRBZGp1c3RlZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHJldHVybiB0aGlzW2luZGV4XTtcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5zZXRBZGp1c3RlZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICByZXR1cm4gdGhpc1tpbmRleF0gPSB2YWx1ZTtcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGxldCBoZXhTdHIgPSAnJztcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIC8vIGVhY2ggb25lIGlzIGEgXCJieXRlXCJcbiAgICBsZXQgaGV4ID0gKHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKSAmIDB4ZmYpLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggPSBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICAgIGhleFN0ciArPSBoZXg7XG4gIH1cblxuICByZXR1cm4gaGV4U3RyO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnVjczJTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGxldCBvdXQgPSAnJztcbiAgbGV0IGkgPSBzdGFydDtcblxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIC8vIHV0Zi0xNi91Y3MtMiBpcyAyLWJ5dGVzIHBlciBjaGFyYWN0ZXJcbiAgICBjb25zdCBieXRlMSA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKyspO1xuICAgIGNvbnN0IGJ5dGUyID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkrKyk7XG4gICAgY29uc3QgY29kZV91bml0ID0gKGJ5dGUyIDw8IDgpICsgYnl0ZTE7IC8vIHdlIG1hc2ggdG9nZXRoZXIgdGhlIHR3byBieXRlc1xuXG4gICAgb3V0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVfdW5pdCk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG1ldGhvZCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBUaSBBUElzIHRoYXQgcmVxdWlyZSBhIFRpLkJ1ZmZlclxuICogQHJldHVybnMge1RpLkJ1ZmZlcn0gdGhlIHVuZGVybHlpbmcgVGkuQnVmZmVyIGJhY2tpbmcgdGhpcyBCdWZmZXIgaW5zdGFuY2VcbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS50b1RpQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCB0aUJ1ZmZlciA9IFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgbGVuZ3RoOiB0aGlzLmxlbmd0aFxuICB9KTtcbiAgY29weUJ1ZmZlcih0aGlzLCB0aUJ1ZmZlciwgMCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGlCdWZmZXI7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc3JjIHNvdXJjZSBCdWZmZXIgd2UncmUgY29weWluZyBmcm9tXG4gKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gZGVzdCBkZXN0aW5hdGlvbiBUaS5CdWZmZXIgd2UncmUgY29weWluZyBpbnRvXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBzdGFydCBvZmZzZXQgd2UncmUgY29weWluZyB0byBpbiBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggbnVtYmVyIG9mIGJ5dGVzIHRvIGNvcHlcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZFxuICovXG5cblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIGRlc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGNvbnN0IGRlc3RMZW5ndGggPSBkZXN0Lmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkZXN0SW5kZXggPSBpICsgb2Zmc2V0OyAvLyBhcmUgd2UgdHJ5aW5nIHRvIHdyaXRlIHBhc3QgZW5kIG9mIGRlc3RpbmF0aW9uPyBPciByZWFkIHBhc3QgZW5kIG9mIHNvdXJjZT8gU3RvcCFcblxuICAgIGlmIChkZXN0SW5kZXggPj0gZGVzdExlbmd0aCB8fCBpID49IHNyY0xlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVzdFtkZXN0SW5kZXhdID0gc3JjW2ldO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gaXRlcmF0b3IgZm9yIGJ1ZiB2YWx1ZXMgKGJ5dGVzKVxuICogQHJldHVybnMge0l0ZXJhdG9yfVxuICovXG4vLyBUT0RPOiBNb3ZlIHRvIFNsb3dCdWZmZXI/XG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYnVmZmVyID0gdGhpcztcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZCA9IHRoaXMubGVuZ3RoO1xuICBjb25zdCBteUl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiBidWZmZXIuZ2V0QWRqdXN0ZWRJbmRleChuZXh0SW5kZXgpLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG15SXRlcmF0b3I7XG59O1xuLyoqXG4gKiBDYWxsZWQgd2hlbiBidWZmZXIgaXMgdXNlZCBpbiBhIGZvci4ub2YgbG9vcC4gRGVsZWdhdGVzIHRvICN2YWx1ZXMoKVxuICogQHJldHVybnMge0l0ZXJhdG9yfVxuICovXG4vLyBUT0RPOiBNb3ZlIHRvIFNsb3dCdWZmZXI/XG5cblxuQnVmZmVyJDEucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlcygpO1xufTtcbi8qKlxuICogV3JpdGVzIHN0cmluZyB0byBidWYgYXQgb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgY2hhcmFjdGVyIGVuY29kaW5nIGluIGVuY29kaW5nLlxuICogVGhlIGxlbmd0aCBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gSWYgYnVmIGRpZCBub3QgY29udGFpbiBlbm91Z2ggc3BhY2UgdG9cbiAqIGZpdCB0aGUgZW50aXJlIHN0cmluZywgb25seSBwYXJ0IG9mIHN0cmluZyB3aWxsIGJlIHdyaXR0ZW4uIEhvd2V2ZXIsIHBhcnRpYWxseSBlbmNvZGVkXG4gKiBjaGFyYWN0ZXJzIHdpbGwgbm90IGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB3cml0ZSB0byBgYnVmYC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUgc3RyaW5nXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGg9YnVmLmxlbmd0aCAtIG9mZnNldF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBzdHJpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IDA7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBjYXAgYGxlbmd0aGAgYXQgdGhlIGxlbmd0aCBvZiBvdXIgYnVmZmVyXG4gICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG5cbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7IC8vIHNvIHdlIG5lZWQgdG8gY29udmVydCBgcmVtYWluaW5nYCBieXRlcyBvZiBvdXIgc3RyaW5nIGludG8gYSBieXRlIGFycmF5L2J1ZmZlclxuXG4gIGNvbnN0IHNyYyA9IGZyb21TdHJpbmcoc3RyaW5nLCBlbmNvZGluZyk7IC8vIEZJWE1FOiBDYW4gd2UgbGV0IGl0IGtub3cgdG8gb25seSBjb252ZXJ0IGByZW1haW5pbmdgIGJ5dGVzP1xuICAvLyB0aGVuIHN0aWNrIHRoYXQgaW50byBvdXIgYnVmZmVyIHN0YXJ0aW5nIGF0IGBvZmZzZXRgIVxuXG4gIHJldHVybiBzcmMuY29weSh0aGlzLCBvZmZzZXQsIDAsIGxlbmd0aCk7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpO1xuICBkb3VibGVBcnJheVswXSA9IHZhbHVlO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbN10pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNl0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNV0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNF0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbM10pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMl0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMV0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMF0pO1xuICByZXR1cm4gb2Zmc2V0OyAvLyBhdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGFkZGVkIDggdG8gb2Zmc2V0XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpO1xuICBkb3VibGVBcnJheVswXSA9IHZhbHVlO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMF0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMV0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMl0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbM10pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNF0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNV0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNl0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbN10pO1xuICByZXR1cm4gb2Zmc2V0OyAvLyBhdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGFkZGVkIDggdG8gb2Zmc2V0XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIGZsb2F0QXJyYXlbMF0gPSB2YWx1ZTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbM10pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVsyXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzFdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMF0pO1xuICByZXR1cm4gb2Zmc2V0OyAvLyBhdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGFkZGVkIDQgdG8gb2Zmc2V0XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIGZsb2F0QXJyYXlbMF0gPSB2YWx1ZTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMF0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVsxXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzJdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbM10pO1xuICByZXR1cm4gb2Zmc2V0OyAvLyBhdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGFkZGVkIDQgdG8gb2Zmc2V0XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDEpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtMTI4LCAxMjcpO1xuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgLy8ganVzdCB3cml0ZSBpdCBub3JtYWxseVxuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb252ZXJ0IGZyb20gc2lnbmVkIHRvIDIncyBjb21wbGVtZW50IGJpdHNcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCAweEZGICsgdmFsdWUgKyAxKTsgLy8gbWF4IHZhbHVlLCBwbHVzIHRoZSBuZWdhdGl2ZSBudW1iZXIsIGFkZCBvbmVcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyAxO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlID4+PiA4KTsgLy8ganVzdCBzaGlmdCBvdmVyIGEgYnl0ZVxuXG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSAmIDB4RkYpOyAvLyBtYXNrIHRvIGZpcnN0IGJ5dGVcblxuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSAmIDB4RkYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgPj4+IDI0KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiAxNik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gOCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAzLCB2YWx1ZSAmIDB4RkYpO1xuICByZXR1cm4gb2Zmc2V0ICsgNDtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgJiAweEZGKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDIsIHZhbHVlID4+PiAxNik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAzLCB2YWx1ZSA+Pj4gMjQpO1xuICByZXR1cm4gb2Zmc2V0ICsgNDtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgY29uc3QgbWluTWF4QmFzZSA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC1taW5NYXhCYXNlLCBtaW5NYXhCYXNlIC0gMSk7XG5cbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIHZhbHVlID0gbWluTWF4QmFzZSAqIDIgKyB2YWx1ZTtcbiAgfVxuXG4gIGxldCBtdWx0aXBsaWVyID0gMTtcblxuICBmb3IgKGxldCBpID0gYnl0ZUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgbXVsdGlwbGllciAqPSAweDEwMDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjb25zdCBtaW5NYXhCYXNlID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLW1pbk1heEJhc2UsIG1pbk1heEJhc2UgLSAxKTtcblxuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgdmFsdWUgPSBtaW5NYXhCYXNlICogMiArIHZhbHVlO1xuICB9XG5cbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgbXVsdGlwbGllciAqPSAwWDEwMDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDEuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMSk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDI1NSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlKTtcbiAgcmV0dXJuIG9mZnNldCArIDE7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgNjU1MzUpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSA+Pj4gOCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA2NTUzNSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlICYgMHhmZik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gOCk7XG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDQyOTQ5NjcyOTUpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSA+Pj4gMjQpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDIsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDQyOTQ5NjcyOTUpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSAmIDB4ZmYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlID4+PiAyNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMSk7XG4gIGxldCBtdWx0aXBsaWVyID0gMTtcblxuICBmb3IgKGxldCBpID0gYnl0ZUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgbXVsdGlwbGllciAqPSAwWDEwMDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMSk7XG4gIGxldCBtdWx0aXBsaWVyID0gMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgIGxldCBieXRlVmFsdWUgPSB2YWx1ZSAvIG11bHRpcGxpZXIgJiAweEZGO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyBpLCBieXRlVmFsdWUpO1xuICAgIG11bHRpcGxpZXIgKj0gMFgxMDA7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn07IC8vIFRPRE86IEltcGxlbWVudCByZW1haW5pbmcgaW5zdGFuY2UgbWV0aG9kczpcbi8vIGJ1Zi5sYXN0SW5kZXhPZih2YWx1ZVssIGJ5dGVPZmZzZXRdWywgZW5jb2RpbmddKVxuLy8gYnVmLnJlYWRCaWdJbnQ2NEJFKFtvZmZzZXRdKVxuLy8gYnVmLnJlYWRCaWdJbnQ2NExFKFtvZmZzZXRdKVxuLy8gYnVmLnJlYWRCaWdVSW50NjRCRShbb2Zmc2V0XSlcbi8vIGJ1Zi5yZWFkQmlnVUludDY0TEUoW29mZnNldF0pXG4vLyBidWYud3JpdGVCaWdJbnQ2NEJFKHZhbHVlWywgb2Zmc2V0XSlcbi8vIGJ1Zi53cml0ZUJpZ0ludDY0TEUodmFsdWVbLCBvZmZzZXRdKVxuLy8gYnVmLndyaXRlQmlnVUludDY0QkUodmFsdWVbLCBvZmZzZXRdKVxuLy8gYnVmLndyaXRlQmlnVUludDY0TEUodmFsdWVbLCBvZmZzZXRdKVxuLy8gRklYTUU6IFdlIG5lZWQgdG8gbWluaW1pemUgdXNpbmcgYSBiYWNraW5nIFRpLkJ1ZmZlciB3aGVuZXZlciBwb3NzaWJsZSwgYmVjYXVzZVxuLy8gZ29pbmcgYmFjayBhbmQgZm9ydGggYWNyb3NzIHRoZSBicmlkZ2UgZm9yIGV2ZXJ5IGJ5dGUgaXMgKnZlcnkqIGV4cGVuc2l2ZVxuLy8gSWRlYWxseSB3ZSBzaG91bGQgaGF2ZSBhIFwiU2xvd0J1ZmZlclwiIHRoYXQgaXMgdXNlZCB3aGVuIHdlIGV4cGxpY2l0bHkgd3JhcCBhIFRpLkJ1ZmZlclxuLy8gU28gdGhhdCB3cml0ZXMgYXJlIHBhc3NlZCB0aHJvdWdoLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGF2b2lkIHVzaW5nIG9uZSBhdCBhbGwgY29zdHNcbi8vIGkuZS4gd2hlbiB3ZSBkbyBCdWZmZXIuY29uY2F0IGFuZCBhcmUgb25seSBkb2luZyByZWFkcyAtIHdoeSBkbyB3ZSBuZWVkIGEgVGkuQnVmZmVyP1xuLy8gQ2FuIHdlIGhhdmUgVGkuQnVmZmVyIHJlYWxseSBqdXN0IHdyYXAgYSBVaW50OEFycmF5IGFuZCBhZGQgaXQncyBvd24gbWV0aG9kcz9cblxuXG5CdWZmZXIkMS5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGxlbmd0aCk7XG59O1xuXG5CdWZmZXIkMS5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIkMS5hbGxvY1Vuc2FmZShsZW5ndGgpO1xufTtcblxuQnVmZmVyJDEuYWxsb2MgPSBmdW5jdGlvbiAobGVuZ3RoLCBmaWxsID0gMCwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgYnVmID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUobGVuZ3RoKTtcblxuICBpZiAoZmlsbCAhPT0gMCkge1xuICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VHlwZWRBcnJheXxEYXRhVmlld3xBcnJheUJ1ZmZlcnxTaGFyZWRBcnJheUJ1ZmZlcn0gc3RyaW5nIG9yaWdpbmFsIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHdob3NlIGJ5dGUgbGVuZ3RoIHdlIG5lZWQgdG8gZ3JhYlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKEJ1ZmZlciQxLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoOyAvLyByZXR1cm4gQnVmZmVyJ3MgbGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoOyAvLyBUeXBlZEFycmF5LCBBcnJheUJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIsIERhdGFWaWV3XG4gIH1cblxuICBsZXQgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICBzd2l0Y2ggKGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdXRmOEJ5dGVMZW5ndGgoc3RyaW5nKTtcblxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuXG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0ZjE2LWxlJzpcbiAgICAgIHJldHVybiAyICogbGVuZ3RoO1xuXG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBsZW5ndGggLyAyO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFN1YnRyYWN0IHVwIHRvIHR3byBwYWRkaW5nIGNoYXJzIGZyb20gZW5kIG9mIHN0cmluZyFcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIHN0cmluZy5jaGFyQXQobGVuZ3RoIC0gMSkgPT09ICc9Jykge1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgc3RyaW5nLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihsZW5ndGggKiAzIC8gNCk7XG4gICAgLy8gZHJvcCBmcmFjdGlvbmFsIHZhbHVlXG4gIH1cblxuICByZXR1cm4gdXRmOEJ5dGVMZW5ndGgoc3RyaW5nKTtcbn07XG5cbkJ1ZmZlciQxLmNvbXBhcmUgPSBmdW5jdGlvbiAoYnVmMSwgYnVmMikge1xuICBpZiAoIUJ1ZmZlciQxLmlzQnVmZmVyKGJ1ZjEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiYnVmMVwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYnVmMX1gKTtcbiAgfSAvLyBUT0RPOiBXcmFwIFVJbnQ4QXJyYXkgYXJncyBpbiBidWZmZXJzP1xuXG5cbiAgcmV0dXJuIGJ1ZjEuY29tcGFyZShidWYyKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyW118VUludDhBcnJheVtdfSBsaXN0IGxpc3Qgb2YgQnVmZmVycyB0byBjb25jYXRlbmF0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWxMZW5ndGhdIFRvdGFsIGxlbmd0aCBvZiB0aGUgQnVmZmVyIGluc3RhbmNlcyBpbiBsaXN0IHdoZW4gY29uY2F0ZW5hdGVkLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXknKTtcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcigpOyAvLyBvbmUgZW1wdHkgQnVmZmVyIVxuICB9IC8vIGFsbG9jYXRlIG9uZSBCdWZmZXIgb2YgYHRvdGFsTGVuZ3RoYD8gQ2FwIGF0IHRvdGFsTGVuZ3RoP1xuXG5cbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7IC8vIGdlbmVyYXRlIHRoZSB0b3RhbCBsZW5ndGggZnJvbSBlYWNoIGJ1ZmZlcidzIGxlbmd0aD9cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgcG9zaXRpb24gPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkocmVzdWx0LCBwb3NpdGlvbik7XG4gICAgcG9zaXRpb24gKz0gYnVmLmxlbmd0aDtcblxuICAgIGlmIChwb3NpdGlvbiA+PSB0b3RhbExlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBwb3NzaWJsZSBlbmNvZGluZyBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbkJ1ZmZlciQxLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gVkFMSURfRU5DT0RJTkdTLmluY2x1ZGVzKGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpO1xufTtcbi8qKlxuICogQHBhcmFtIHsqfSBvYmogcG9zc2libGUgQnVmZmVyIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbkJ1ZmZlciQxLmlzQnVmZmVyID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkICYmIChvYmogaW5zdGFuY2VvZiBCdWZmZXIkMSB8fCBvYmpbaXNCdWZmZXJdID09PSB0cnVlKTtcbn07XG5cbmxldCBJTlNQRUNUX01BWF9CWVRFUyA9IDUwOyAvLyBPdmVycmlkZSBob3cgYnVmZmVycyBhcmUgcHJlc2VudGVkIGJ5IHV0aWwuaW5zcGVjdCgpLlxuXG5CdWZmZXIkMS5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBmdW5jdGlvbiAocmVjdXJzZVRpbWVzLCBjdHgpIHtcbiAgY29uc3QgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG4gIGNvbnN0IGFjdHVhbE1heCA9IE1hdGgubWluKG1heCwgdGhpcy5sZW5ndGgpO1xuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG1heDtcbiAgbGV0IHN0ciA9IHRoaXMuc2xpY2UoMCwgYWN0dWFsTWF4KS50b1N0cmluZygnaGV4JykucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKCk7XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBzdHIgKz0gYCAuLi4gJHtyZW1haW5pbmd9IG1vcmUgYnl0ZSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWA7XG4gIH0gLy8gSW5zcGVjdCBzcGVjaWFsIHByb3BlcnRpZXMgYXMgd2VsbCwgaWYgcG9zc2libGUuXG5cblxuICBpZiAoY3R4KSB7XG4gICAgbGV0IGV4dHJhcyA9IGZhbHNlO1xuICAgIGNvbnN0IGZpbHRlciA9IGN0eC5zaG93SGlkZGVuID8gQUxMX1BST1BFUlRJRVMkMSA6IE9OTFlfRU5VTUVSQUJMRSQxO1xuICAgIGNvbnN0IG9iaiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh0aGlzLCBmaWx0ZXIpLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgIGV4dHJhcyA9IHRydWU7XG4gICAgICBvYmpba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgc3RyICs9ICcsICc7XG4gICAgICB9IC8vICdbT2JqZWN0OiBudWxsIHByb3RvdHlwZV0geycubGVuZ3RoID09PSAyNlxuICAgICAgLy8gVGhpcyBpcyBndWFyZGVkIHdpdGggYSB0ZXN0LlxuXG5cbiAgICAgIHN0ciArPSBpbnNwZWN0KG9iaiwgeyAuLi5jdHgsXG4gICAgICAgIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSxcbiAgICAgICAgY29tcGFjdDogdHJ1ZVxuICAgICAgfSkuc2xpY2UoMjcsIC0yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYDwke3RoaXMuY29uc3RydWN0b3IubmFtZX0gJHtzdHJ9PmA7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuaW5zcGVjdCA9IEJ1ZmZlciQxLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXTsgLy8gSEFDSzogQXJyYXlCdWZmZXIuaXNWaWV3IHJldHVybnMgdHJ1ZSBmb3IgTm9kZSBCdWZmZXIsIGJ1dCBmYWxzZSBmb3IgdXMuIFVudGlsIHdlIGNhbiBleHRlbmQgVWludDhBcnJheSwgd2UgbmVlZCB0byBoYWNrIHRoaXMgc25pZmZpbmcgbWV0aG9kXG5cbmNvbnN0IEFycmF5QnVmZmVySXNWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3O1xuXG5BcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAodGhpbmcpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVySXNWaWV3KHRoaW5nKSB8fCB0aGluZyBpbnN0YW5jZW9mIEJ1ZmZlciQxO1xufTtcblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNsb3dCdWZmZXIucHJvdG90eXBlLCBCdWZmZXIkMS5wcm90b3R5cGUpO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNsb3dCdWZmZXIsIEJ1ZmZlciQxKTtcbnZhciBCdWZmZXJNb2R1bGUgPSB7XG4gIEJ1ZmZlcjogQnVmZmVyJDEsXG4gIC8vIFRPRE86IEltcGxlbWVudCB0cmFuc2NvZGUoKSFcbiAgdHJhbnNjb2RlOiAoX3NvdXJjZSwgX2Zyb21FbmNvZGluZywgX3RvRW5jb2RpbmcpID0+IHt9LFxuICBJTlNQRUNUX01BWF9CWVRFUzogNTAsXG4gIGtNYXhMZW5ndGg6IDIxNDc0ODM2NDcsXG4gIGtTdHJpbmdNYXhMZW5ndGg6IDEwNzM3NDE3OTksXG4gIGNvbnN0YW50czoge1xuICAgIE1BWF9MRU5HVEg6IDIxNDc0ODM2NDcsXG4gICAgTUFYX1NUUklOR19MRU5HVEg6IDEwNzM3NDE3OTlcbiAgfVxufTtcbi8qKlxuICogU2VhcmNoZXMgYSBCdWZmZXIgZm9yIHRoZSBpbmRleCBvZiBhIHNpbmdsZSBieXRlLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBidWZmZXIgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHNpbmdsZUJ5dGUgYnl0ZSB3ZSdyZSBsb29raW5nIGZvclxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgc3RhcnQgb2Zmc2V0IHdlIHNlYXJjaCBhdFxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZihidWZmZXIsIHNpbmdsZUJ5dGUsIG9mZnNldCkge1xuICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChidWZmZXIuZ2V0QWRqdXN0ZWRJbmRleChpKSA9PT0gc2luZ2xlQnl0ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHkgYXZvaWRzIGJpdHdpc2Ugb3BlcmF0aW9ucyBiZWNhdXNlIEpTIGFzc3VtZXMgMzItYml0IHNlcXVlbmNlcyBmb3IgdGhvc2UuXG4gKiBJdCdzIHBvc3NpYmxlIHdlIG1heSBiZSBhYmxlIHRvIHVzZSB0aGVtIHdoZW4gYnl0ZUxlbmd0aCA8IDQgaWYgdGhhdCdzIGZhc3Rlci5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHVuc2lnbmVkVmFsdWUgdmFsdWUgYmVmb3JlIGNvbnZlcnRpbmcgYmFjayB0byBzaWduZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXNcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSB0aGUgc2lnbmVkIHZhbHVlIHRoYXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIHVuc2lnbmVkIHZhbHVlJ3MgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCkge1xuICBjb25zdCBiaXRMZW5ndGggPSBieXRlTGVuZ3RoICogODtcbiAgY29uc3QgbWF4UG9zaXRpdmVWYWx1ZSA9IE1hdGgucG93KDIsIGJpdExlbmd0aCAtIDEpO1xuXG4gIGlmICh1bnNpZ25lZFZhbHVlIDwgbWF4UG9zaXRpdmVWYWx1ZSkge1xuICAgIHJldHVybiB1bnNpZ25lZFZhbHVlO1xuICB9XG5cbiAgY29uc3QgbWF4VW5zaWduZWRWYWx1ZSA9IE1hdGgucG93KDIsIGJpdExlbmd0aCk7XG4gIHVuc2lnbmVkVmFsdWUgLT0gbWF4VW5zaWduZWRWYWx1ZTtcbiAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdXRmLTggc3RyaW5nXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHV0ZjhCeXRlTGVuZ3RoKHN0cmluZykge1xuICAvLyBKdXN0IGNvbnZlcnQgdG8gYSBUaS5CdWZmZXIgYW5kIGxldCBpdCB0ZWxsIHVzIHRoZSBsZW5ndGhcbiAgY29uc3QgYnVmID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIHR5cGU6IFRpLkNvZGVjLkNIQVJTRVRfVVRGOFxuICB9KTtcbiAgY29uc3QgbGVuZ3RoID0gYnVmLmxlbmd0aDtcbiAgYnVmLnJlbGVhc2UoKTsgLy8gcmVsZWFzZSB0aGUgYnVmZmVyIHNpbmNlIHdlIGp1c3QgbmVlZGVkIHRoZSBsZW5ndGhcblxuICByZXR1cm4gbGVuZ3RoO1xufVxuLyoqXG4gKiBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB3ZSdyZSBvcGVyYXRpbmcgb25cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHVzZXIgc3VwcGxpZWQgb2Zmc2V0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBpbiByYW5nZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0KGJ1ZmZlciwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IGVuZE9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSBieXRlTGVuZ3RoO1xuXG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGVuZE9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgdmFsdWUgb2YgXCJvZmZzZXRcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgPj0gMCBhbmQgPD0gJHtlbmRPZmZzZXR9LiBSZWNlaXZlZCAke29mZnNldH1gKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIHVzZXItc3VwcGxpZWQgdmFsdWVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbWluIG1pbmltdW0gdmFsaWQgdmFsdWVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbWF4IG1heGltdW0gdmFsaWQgdmFsdWVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gKi9cblxuXG5mdW5jdGlvbiBjaGVja1ZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIHZhbHVlIG9mIFwidmFsdWVcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgPj0gJHttaW59IGFuZCA8PSAke21heH0uIFJlY2VpdmVkICR7dmFsdWV9YCk7XG4gIH1cbn1cblxubGV0IGJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCA9IGZhbHNlO1xubGV0IG5vZGVNb2R1bGVzQ2hlY2tDb3VudGVyID0gMDtcbmNvbnN0IGJ1ZmZlcldhcm5pbmcgPSAnQnVmZmVyKCkgaXMgZGVwcmVjYXRlZCBkdWUgdG8gc2VjdXJpdHkgYW5kIHVzYWJpbGl0eSAnICsgJ2lzc3Vlcy4gUGxlYXNlIHVzZSB0aGUgQnVmZmVyLmFsbG9jKCksICcgKyAnQnVmZmVyLmFsbG9jVW5zYWZlKCksIG9yIEJ1ZmZlci5mcm9tKCkgbWV0aG9kcyBpbnN0ZWFkLic7XG5cbmZ1bmN0aW9uIHNob3dGbGFnZ2VkRGVwcmVjYXRpb24oKSB7XG4gIGlmIChidWZmZXJXYXJuaW5nQWxyZWFkeUVtaXR0ZWQgfHwgKytub2RlTW9kdWxlc0NoZWNrQ291bnRlciA+IDEwMDAwIHx8IGlzSW5zaWRlTm9kZU1vZHVsZXMoKSkge1xuICAgIC8vIFdlIGRvbid0IGVtaXQgYSB3YXJuaW5nLCBiZWNhdXNlIHdlIGVpdGhlcjpcbiAgICAvLyAtIEFscmVhZHkgZGlkIHNvLCBvclxuICAgIC8vIC0gQWxyZWFkeSBjaGVja2VkIHRvbyBtYW55IHRpbWVzIHdoZXRoZXIgYSBjYWxsIGlzIGNvbWluZ1xuICAgIC8vICAgZnJvbSBub2RlX21vZHVsZXMgYW5kIHdhbnQgdG8gc3RvcCBzbG93aW5nIGRvd24gdGhpbmdzLCBvclxuICAgIC8vIC0gVGhlIGNvZGUgaXMgaW5zaWRlIGBub2RlX21vZHVsZXNgLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb2Nlc3MuZW1pdFdhcm5pbmcoYnVmZmVyV2FybmluZywgJ0RlcHJlY2F0aW9uV2FybmluZycsICdERVAwMDA1Jyk7XG4gIGJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCA9IHRydWU7XG59XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvbnN0IHtcbiAgQUxMX1BST1BFUlRJRVMsXG4gIE9OTFlfRU5VTUVSQUJMRVxufSA9IHByb3BlcnR5RmlsdGVyO1xuY29uc3QgQm9vbGVhblByb3RvdHlwZSA9IEJvb2xlYW4ucHJvdG90eXBlO1xuY29uc3QgRGF0ZVByb3RvdHlwZSA9IERhdGUucHJvdG90eXBlO1xuY29uc3QgRXJyb3JQcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5jb25zdCBOdW1iZXJQcm90b3R5cGUgPSBOdW1iZXIucHJvdG90eXBlO1xuY29uc3QgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbmNvbnN0IFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5jb25zdCBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xuY29uc3QgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcbmNvbnN0IFN5bWJvbFByb3RvdHlwZSA9IFN5bWJvbC5wcm90b3R5cGU7XG5jb25zdCBpc0lvcyA9IFsnaXBhZCcsICdpcGhvbmUnXS5pbmNsdWRlcyhcImFuZHJvaWRcIik7XG5jb25zdCB7XG4gIEVSUl9JTlZBTElEX0FSR19UWVBFXG59ID0gY29kZXM7XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuY29uc3QgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbmxldCBoZXhTbGljZSA9IHVuY3VycnlUaGlzKEJ1ZmZlck1vZHVsZS5CdWZmZXIucHJvdG90eXBlLmhleFNsaWNlKTtcbmNvbnN0IGJ1aWx0SW5PYmplY3RzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnbG9iYWwpLmZpbHRlcihlID0+IC9eKFtBLVpdW2Etel0rKSskLy50ZXN0KGUpKSk7XG5jb25zdCBpbnNwZWN0RGVmYXVsdE9wdGlvbnMgPSBPYmplY3Quc2VhbCh7XG4gIHNob3dIaWRkZW46IGZhbHNlLFxuICBkZXB0aDogMixcbiAgY29sb3JzOiBmYWxzZSxcbiAgY3VzdG9tSW5zcGVjdDogdHJ1ZSxcbiAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgbWF4QXJyYXlMZW5ndGg6IDEwMCxcbiAgYnJlYWtMZW5ndGg6IDgwLFxuICBjb21wYWN0OiAzLFxuICBzb3J0ZWQ6IGZhbHNlLFxuICBnZXR0ZXJzOiBmYWxzZVxufSk7XG5jb25zdCBrT2JqZWN0VHlwZSA9IDA7XG5jb25zdCBrQXJyYXlUeXBlID0gMTtcbmNvbnN0IGtBcnJheUV4dHJhc1R5cGUgPSAyO1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5jb25zdCBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xceDAwLVxceDFmXFx4MjdcXHg1Y10vO1xuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIgPSAvW1xceDAwLVxceDFmXFx4MjdcXHg1Y10vZztcbmNvbnN0IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZSA9IC9bXFx4MDAtXFx4MWZcXHg1Y10vO1xuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXJTaW5nbGUgPSAvW1xceDAwLVxceDFmXFx4NWNdL2c7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuY29uc3Qga2V5U3RyUmVnRXhwID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC87XG5jb25zdCBudW1iZXJSZWdFeHAgPSAvXigwfFsxLTldWzAtOV0qKSQvO1xuY29uc3Qgbm9kZU1vZHVsZXNSZWdFeHAgPSAvWy9cXFxcXW5vZGVfbW9kdWxlc1svXFxcXF0oLis/KSg/PVsvXFxcXF0pL2c7XG5jb25zdCBrTWluTGluZUxlbmd0aCA9IDE2OyAvLyBDb25zdGFudHMgdG8gbWFwIHRoZSBpdGVyYXRvciBzdGF0ZS5cblxuY29uc3Qga1dlYWsgPSAwO1xuY29uc3Qga0l0ZXJhdG9yID0gMTtcbmNvbnN0IGtNYXBFbnRyaWVzID0gMjsgLy8gRXNjYXBlZCBzcGVjaWFsIGNoYXJhY3RlcnMuIFVzZSBlbXB0eSBzdHJpbmdzIHRvIGZpbGwgdXAgdW51c2VkIGVudHJpZXMuXG5cbi8qIGVzbGludC1kaXNhYmxlIHF1b3RlcyAqL1xuXG5jb25zdCBtZXRhID0gWydcXFxcdTAwMDAnLCAnXFxcXHUwMDAxJywgJ1xcXFx1MDAwMicsICdcXFxcdTAwMDMnLCAnXFxcXHUwMDA0JywgJ1xcXFx1MDAwNScsICdcXFxcdTAwMDYnLCAnXFxcXHUwMDA3JywgJ1xcXFxiJywgJ1xcXFx0JywgJ1xcXFxuJywgJ1xcXFx1MDAwYicsICdcXFxcZicsICdcXFxccicsICdcXFxcdTAwMGUnLCAnXFxcXHUwMDBmJywgJ1xcXFx1MDAxMCcsICdcXFxcdTAwMTEnLCAnXFxcXHUwMDEyJywgJ1xcXFx1MDAxMycsICdcXFxcdTAwMTQnLCAnXFxcXHUwMDE1JywgJ1xcXFx1MDAxNicsICdcXFxcdTAwMTcnLCAnXFxcXHUwMDE4JywgJ1xcXFx1MDAxOScsICdcXFxcdTAwMWEnLCAnXFxcXHUwMDFiJywgJ1xcXFx1MDAxYycsICdcXFxcdTAwMWQnLCAnXFxcXHUwMDFlJywgJ1xcXFx1MDAxZicsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCBcIlxcXFwnXCIsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnXFxcXFxcXFwnXTtcbi8qIGVzbGludC1lbmFibGUgcXVvdGVzICovXG5cbmZ1bmN0aW9uIGdldFVzZXJPcHRpb25zKGN0eCkge1xuICBjb25zdCBvYmogPSB7XG4gICAgc3R5bGl6ZTogY3R4LnN0eWxpemVcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnNwZWN0RGVmYXVsdE9wdGlvbnMpKSB7XG4gICAgb2JqW2tleV0gPSBjdHhba2V5XTtcbiAgfVxuXG4gIGlmIChjdHgudXNlck9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4geyAuLi5vYmosXG4gICAgLi4uY3R4LnVzZXJPcHRpb25zXG4gIH07XG59XG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhbnkgaW5wdXQuIFRyaWVzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgdmFsdWVgXG4gKi9cblxuXG5mdW5jdGlvbiBpbnNwZWN0KHZhbHVlLCBvcHRzKSB7XG4gIC8vIERlZmF1bHQgb3B0aW9uc1xuICBjb25zdCBjdHggPSB7XG4gICAgYnVkZ2V0OiB7fSxcbiAgICBpbmRlbnRhdGlvbkx2bDogMCxcbiAgICBzZWVuOiBbXSxcbiAgICBjdXJyZW50RGVwdGg6IDAsXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3IsXG4gICAgc2hvd0hpZGRlbjogaW5zcGVjdERlZmF1bHRPcHRpb25zLnNob3dIaWRkZW4sXG4gICAgZGVwdGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5kZXB0aCxcbiAgICBjb2xvcnM6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5jb2xvcnMsXG4gICAgY3VzdG9tSW5zcGVjdDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmN1c3RvbUluc3BlY3QsXG4gICAgc2hvd1Byb3h5OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuc2hvd1Byb3h5LFxuICAgIG1heEFycmF5TGVuZ3RoOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMubWF4QXJyYXlMZW5ndGgsXG4gICAgYnJlYWtMZW5ndGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5icmVha0xlbmd0aCxcbiAgICBjb21wYWN0OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuY29tcGFjdCxcbiAgICBzb3J0ZWQ6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5zb3J0ZWQsXG4gICAgZ2V0dGVyczogaW5zcGVjdERlZmF1bHRPcHRpb25zLmdldHRlcnNcbiAgfTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBMZWdhY3kuLi5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICAgICAgfVxuICAgIH0gLy8gU2V0IHVzZXItc3BlY2lmaWVkIG9wdGlvbnNcblxuXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAgIGNvbnN0IG9wdEtleXMgPSBPYmplY3Qua2V5cyhvcHRzKTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb3B0S2V5cykge1xuICAgICAgICAvLyBUT0RPKEJyaWRnZUFSKTogRmluZCBhIHNvbHV0aW9uIHdoYXQgdG8gZG8gYWJvdXQgc3R5bGl6ZS4gRWl0aGVyIG1ha2VcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBwdWJsaWMgb3IgYWRkIGEgbmV3IEFQSSB3aXRoIGEgc2ltaWxhciBvciBiZXR0ZXJcbiAgICAgICAgLy8gZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KGluc3BlY3REZWZhdWx0T3B0aW9ucywga2V5KSB8fCBrZXkgPT09ICdzdHlsaXplJykge1xuICAgICAgICAgIGN0eFtrZXldID0gb3B0c1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC51c2VyT3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCB0byBwYXNzIHRocm91Z2ggdGhlIGFjdHVhbCB1c2VyIGlucHV0LlxuICAgICAgICAgIGN0eC51c2VyT3B0aW9ucyA9IG9wdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY3R4LmNvbG9ycykge1xuICAgIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgfVxuXG4gIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPT09IG51bGwpIHtcbiAgICBjdHgubWF4QXJyYXlMZW5ndGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCAwKTtcbn1cbmluc3BlY3QuY3VzdG9tID0gY3VzdG9tSW5zcGVjdFN5bWJvbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnNwZWN0LCAnZGVmYXVsdE9wdGlvbnMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gaW5zcGVjdERlZmF1bHRPcHRpb25zO1xuICB9LFxuXG4gIHNldChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihpbnNwZWN0RGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbn0pOyAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcblxuaW5zcGVjdC5jb2xvcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgYm9sZDogWzEsIDIyXSxcbiAgaXRhbGljOiBbMywgMjNdLFxuICB1bmRlcmxpbmU6IFs0LCAyNF0sXG4gIGludmVyc2U6IFs3LCAyN10sXG4gIHdoaXRlOiBbMzcsIDM5XSxcbiAgZ3JleTogWzkwLCAzOV0sXG4gIGJsYWNrOiBbMzAsIDM5XSxcbiAgYmx1ZTogWzM0LCAzOV0sXG4gIGN5YW46IFszNiwgMzldLFxuICBncmVlbjogWzMyLCAzOV0sXG4gIG1hZ2VudGE6IFszNSwgMzldLFxuICByZWQ6IFszMSwgMzldLFxuICB5ZWxsb3c6IFszMywgMzldXG59KTsgLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5cbmluc3BlY3Quc3R5bGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIHNwZWNpYWw6ICdjeWFuJyxcbiAgbnVtYmVyOiAneWVsbG93JyxcbiAgYmlnaW50OiAneWVsbG93JyxcbiAgYm9vbGVhbjogJ3llbGxvdycsXG4gIHVuZGVmaW5lZDogJ2dyZXknLFxuICBudWxsOiAnYm9sZCcsXG4gIHN0cmluZzogJ2dyZWVuJyxcbiAgc3ltYm9sOiAnZ3JlZW4nLFxuICBkYXRlOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gIHJlZ2V4cDogJ3JlZCcsXG4gIG1vZHVsZTogJ3VuZGVybGluZSdcbn0pO1xuXG5mdW5jdGlvbiBhZGRRdW90ZXMoc3RyLCBxdW90ZXMpIHtcbiAgaWYgKHF1b3RlcyA9PT0gLTEpIHtcbiAgICByZXR1cm4gYFwiJHtzdHJ9XCJgO1xuICB9XG5cbiAgaWYgKHF1b3RlcyA9PT0gLTIpIHtcbiAgICByZXR1cm4gYFxcYCR7c3RyfVxcYGA7XG4gIH1cblxuICByZXR1cm4gYCcke3N0cn0nYDtcbn1cblxuY29uc3QgZXNjYXBlRm4gPSBzdHIgPT4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07IC8vIEVzY2FwZSBjb250cm9sIGNoYXJhY3RlcnMsIHNpbmdsZSBxdW90ZXMgYW5kIHRoZSBiYWNrc2xhc2guXG4vLyBUaGlzIGlzIHNpbWlsYXIgdG8gSlNPTiBzdHJpbmdpZnkgZXNjYXBpbmcuXG5cblxuZnVuY3Rpb24gc3RyRXNjYXBlKHN0cikge1xuICBsZXQgZXNjYXBlVGVzdCA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cDtcbiAgbGV0IGVzY2FwZVJlcGxhY2UgPSBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlcjtcbiAgbGV0IHNpbmdsZVF1b3RlID0gMzk7IC8vIENoZWNrIGZvciBkb3VibGUgcXVvdGVzLiBJZiBub3QgcHJlc2VudCwgZG8gbm90IGVzY2FwZSBzaW5nbGUgcXVvdGVzIGFuZFxuICAvLyBpbnN0ZWFkIHdyYXAgdGhlIHRleHQgaW4gZG91YmxlIHF1b3Rlcy4gSWYgZG91YmxlIHF1b3RlcyBleGlzdCwgY2hlY2sgZm9yXG4gIC8vIGJhY2t0aWNrcy4gSWYgdGhleSBkbyBub3QgZXhpc3QsIHVzZSB0aG9zZSBhcyBmYWxsYmFjayBpbnN0ZWFkIG9mIHRoZVxuICAvLyBkb3VibGUgcXVvdGVzLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcXVvdGVzXG5cbiAgaWYgKHN0ci5pbmNsdWRlcyhcIidcIikpIHtcbiAgICAvLyBUaGlzIGludmFsaWRhdGVzIHRoZSBjaGFyQ29kZSBhbmQgdGhlcmVmb3JlIGNhbiBub3QgYmUgbWF0Y2hlZCBmb3JcbiAgICAvLyBhbnltb3JlLlxuICAgIGlmICghc3RyLmluY2x1ZGVzKCdcIicpKSB7XG4gICAgICBzaW5nbGVRdW90ZSA9IC0xO1xuICAgIH0gZWxzZSBpZiAoIXN0ci5pbmNsdWRlcygnYCcpICYmICFzdHIuaW5jbHVkZXMoJyR7JykpIHtcbiAgICAgIHNpbmdsZVF1b3RlID0gLTI7XG4gICAgfVxuXG4gICAgaWYgKHNpbmdsZVF1b3RlICE9PSAzOSkge1xuICAgICAgZXNjYXBlVGVzdCA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZTtcbiAgICAgIGVzY2FwZVJlcGxhY2UgPSBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlclNpbmdsZTtcbiAgICB9XG4gIH0gLy8gU29tZSBtYWdpYyBudW1iZXJzIHRoYXQgd29ya2VkIG91dCBmaW5lIHdoaWxlIGJlbmNobWFya2luZyB3aXRoIHY4IDYuMFxuXG5cbiAgaWYgKHN0ci5sZW5ndGggPCA1MDAwICYmICFlc2NhcGVUZXN0LnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBhZGRRdW90ZXMoc3RyLCBzaW5nbGVRdW90ZSk7XG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGVzY2FwZUZuKTtcbiAgICByZXR1cm4gYWRkUXVvdGVzKHN0ciwgc2luZ2xlUXVvdGUpO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBsZXQgbGFzdCA9IDA7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgIGNvbnN0IHBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAocG9pbnQgPT09IHNpbmdsZVF1b3RlIHx8IHBvaW50ID09PSA5MiB8fCBwb2ludCA8IDMyKSB7XG4gICAgICBpZiAobGFzdCA9PT0gaSkge1xuICAgICAgICByZXN1bHQgKz0gbWV0YVtwb2ludF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gYCR7c3RyLnNsaWNlKGxhc3QsIGkpfSR7bWV0YVtwb2ludF19YDtcbiAgICAgIH1cblxuICAgICAgbGFzdCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsYXN0ICE9PSBsYXN0SW5kZXgpIHtcbiAgICByZXN1bHQgKz0gc3RyLnNsaWNlKGxhc3QpO1xuICB9XG5cbiAgcmV0dXJuIGFkZFF1b3RlcyhyZXN1bHQsIHNpbmdsZVF1b3RlKTtcbn1cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICBjb25zdCBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb2xvciA9IGluc3BlY3QuY29sb3JzW3N0eWxlXTtcbiAgICByZXR1cm4gYFxcdTAwMWJbJHtjb2xvclswXX1tJHtzdHJ9XFx1MDAxYlske2NvbG9yWzFdfW1gO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyKSB7XG4gIHJldHVybiBzdHI7XG59IC8vIFJldHVybiBhIG5ldyBlbXB0eSBhcnJheSB0byBwdXNoIGluIHRoZSByZXN1bHRzIG9mIHRoZSBkZWZhdWx0IGZvcm1hdHRlci5cblxuXG5mdW5jdGlvbiBnZXRFbXB0eUZvcm1hdEFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZShvYmosIF9jdHgpIHtcbiAgbGV0IGZpcnN0UHJvdG87IC8vIGNvbnN0IHRtcCA9IG9iajtcblxuICB3aGlsZSAob2JqKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCAnY29uc3RydWN0b3InKTtcblxuICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicgJiYgZGVzY3JpcHRvci52YWx1ZS5uYW1lICE9PSAnJykge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWUubmFtZTtcbiAgICB9XG5cbiAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcblxuICAgIGlmIChmaXJzdFByb3RvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpcnN0UHJvdG8gPSBvYmo7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpcnN0UHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKlxuICAgQHRvZG8gdGhpcyBjYWxscyBpbnRvIG5hdGl2ZSwgY2FuIHdlIHJlcGxhY2UgdGhpcyBzb21laG93P1xuICByZXR1cm4gYCR7aW50ZXJuYWxHZXRDb25zdHJ1Y3Rvck5hbWUodG1wKX0gPCR7aW5zcGVjdChmaXJzdFByb3RvLCB7XG4gIFx0Li4uY3R4LFxuICBcdGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gIH0pfT5gO1xuICAqL1xuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjaykge1xuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICBpZiAodGFnICE9PSAnJykge1xuICAgICAgcmV0dXJuIGBbJHtmYWxsYmFja306IG51bGwgcHJvdG90eXBlXSBbJHt0YWd9XSBgO1xuICAgIH1cblxuICAgIHJldHVybiBgWyR7ZmFsbGJhY2t9OiBudWxsIHByb3RvdHlwZV0gYDtcbiAgfVxuXG4gIGlmICh0YWcgIT09ICcnICYmIGNvbnN0cnVjdG9yICE9PSB0YWcpIHtcbiAgICByZXR1cm4gYCR7Y29uc3RydWN0b3J9IFske3RhZ31dIGA7XG4gIH1cblxuICByZXR1cm4gYCR7Y29uc3RydWN0b3J9IGA7XG59IC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cblxuXG5mdW5jdGlvbiBnZXRLZXlzKHZhbHVlLCBzaG93SGlkZGVuKSB7XG4gIGxldCBrZXlzO1xuICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XG5cbiAgaWYgKHNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuXG4gICAgaWYgKHN5bWJvbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBrZXlzLnB1c2goLi4uc3ltYm9scyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbWlnaHQgdGhyb3cgaWYgYHZhbHVlYCBpcyBhIE1vZHVsZSBOYW1lc3BhY2UgT2JqZWN0IGZyb20gYW5cbiAgICAvLyB1bmV2YWx1YXRlZCBtb2R1bGUsIGJ1dCB3ZSBkb24ndCB3YW50IHRvIHBlcmZvcm0gdGhlIGFjdHVhbCB0eXBlXG4gICAgLy8gY2hlY2sgYmVjYXVzZSBpdCdzIGV4cGVuc2l2ZS5cbiAgICAvLyBUT0RPKGRldnNuZWspOiB0cmFjayBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hMjYyL2lzc3Vlcy8xMjA5XG4gICAgLy8gYW5kIG1vZGlmeSB0aGlzIGxvZ2ljIGFzIG5lZWRlZC5cbiAgICB0cnkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEBmaXhtZSBob3cgdG8gZHUgaXNNb2R1bGVOYW1lc3BhY2VPYmplY3Q/XG5cbiAgICAgIC8qXG4gICAgICBhc3NlcnQoaXNOYXRpdmVFcnJvcihlcnIpICYmIGVyci5uYW1lID09PSAnUmVmZXJlbmNlRXJyb3InICYmXG4gICAgICBcdFx0XHQgaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QodmFsdWUpKTtcbiAgICAgICovXG4gICAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChzeW1ib2xzLmxlbmd0aCAhPT0gMCkge1xuICAgICAga2V5cy5wdXNoKC4uLnN5bWJvbHMuZmlsdGVyKGtleSA9PiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWx1ZSwga2V5KSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykge1xuICBsZXQgZmFsbGJhY2sgPSAnJztcblxuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICBmYWxsYmFjayA9ICdPYmplY3QnO1xuICB9XG5cbiAgcmV0dXJuIGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKSB7XG4gIGZvciAoY29uc3QgW2NoZWNrLCBjbGF6el0gb2YgW1tpc1VpbnQ4QXJyYXksIFVpbnQ4QXJyYXldLCBbaXNVaW50OENsYW1wZWRBcnJheSwgVWludDhDbGFtcGVkQXJyYXldLCBbaXNVaW50MTZBcnJheSwgVWludDE2QXJyYXldLCBbaXNVaW50MzJBcnJheSwgVWludDMyQXJyYXldLCBbaXNJbnQ4QXJyYXksIEludDhBcnJheV0sIFtpc0ludDE2QXJyYXksIEludDE2QXJyYXldLCBbaXNJbnQzMkFycmF5LCBJbnQzMkFycmF5XSwgW2lzRmxvYXQzMkFycmF5LCBGbG9hdDMyQXJyYXldLCBbaXNGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheV1dKSB7XG4gICAgaWYgKGNoZWNrKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsYXp6O1xuICAgIH1cbiAgfVxufVxuXG5sZXQgbGF6eU51bGxQcm90b3R5cGVDYWNoZTsgLy8gQ3JlYXRlcyBhIHN1YmNsYXNzIGFuZCBuYW1lXG4vLyB0aGUgY29uc3RydWN0b3IgYXMgYCR7Y2xhenp9IDogbnVsbCBwcm90b3R5cGVgXG5cbmZ1bmN0aW9uIGNsYXp6V2l0aE51bGxQcm90b3R5cGUoY2xhenosIG5hbWUpIHtcbiAgaWYgKGxhenlOdWxsUHJvdG90eXBlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGxhenlOdWxsUHJvdG90eXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FjaGVkQ2xhc3MgPSBsYXp5TnVsbFByb3RvdHlwZUNhY2hlLmdldChjbGF6eik7XG5cbiAgICBpZiAoY2FjaGVkQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZENsYXNzO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIE51bGxQcm90b3R5cGUgZXh0ZW5kcyBjbGF6eiB7XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bGxQcm90b3R5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yLCAnbmFtZScsIHtcbiAgICB2YWx1ZTogYFske25hbWV9OiBudWxsIHByb3RvdHlwZV1gXG4gIH0pO1xuICBsYXp5TnVsbFByb3RvdHlwZUNhY2hlLnNldChjbGF6eiwgTnVsbFByb3RvdHlwZSk7XG4gIHJldHVybiBOdWxsUHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBub1Byb3RvdHlwZUl0ZXJhdG9yKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBsZXQgbmV3VmFsO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoU2V0LCAnU2V0Jyk7XG4gICAgbmV3VmFsID0gbmV3IGNsYXp6KFNldFByb3RvdHlwZS52YWx1ZXModmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoTWFwLCAnTWFwJyk7XG4gICAgbmV3VmFsID0gbmV3IGNsYXp6KE1hcFByb3RvdHlwZS5lbnRyaWVzKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoQXJyYXksICdBcnJheScpO1xuICAgIG5ld1ZhbCA9IG5ldyBjbGF6eih2YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKTtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoY29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIG5ld1ZhbCA9IG5ldyBjbGF6eih2YWx1ZSk7XG4gIH1cblxuICBpZiAobmV3VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuZXdWYWwsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHZhbHVlKSk7XG4gICAgcmV0dXJuIGZvcm1hdFJhdyhjdHgsIG5ld1ZhbCwgcmVjdXJzZVRpbWVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHR5cGVkQXJyYXkpIHtcbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXMuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmb3JtYXRQcmltaXRpdmUoY3R4LnN0eWxpemUsIHZhbHVlLCBjdHgpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfSAvLyBNZW1vcml6ZSB0aGUgY29udGV4dCBmb3IgY3VzdG9tIGluc3BlY3Rpb24gb24gcHJveGllcy5cblxuXG4gIGNvbnN0IGNvbnRleHQgPSB2YWx1ZTtcbiAgLypcbiAgQGZpeG1lIGNoZWNrIGZvciBwcm94aWVzXG4gIC8vIEFsd2F5cyBjaGVjayBmb3IgcHJveGllcyB0byBwcmV2ZW50IHNpZGUgZWZmZWN0cyBhbmQgdG8gcHJldmVudCB0cmlnZ2VyaW5nXG4gIC8vIGFueSBwcm94eSBoYW5kbGVycy5cbiAgY29uc3QgcHJveHkgPSBnZXRQcm94eURldGFpbHModmFsdWUpO1xuICBpZiAocHJveHkgIT09IHVuZGVmaW5lZCkge1xuICBcdGlmIChjdHguc2hvd1Byb3h5KSB7XG4gIFx0XHRyZXR1cm4gZm9ybWF0UHJveHkoY3R4LCBwcm94eSwgcmVjdXJzZVRpbWVzKTtcbiAgXHR9XG4gIFx0dmFsdWUgPSBwcm94eVswXTtcbiAgfVxuICAqL1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdC5cblxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QpIHtcbiAgICBjb25zdCBtYXliZUN1c3RvbSA9IHZhbHVlW2N1c3RvbUluc3BlY3RTeW1ib2xdO1xuXG4gICAgaWYgKHR5cGVvZiBtYXliZUN1c3RvbSA9PT0gJ2Z1bmN0aW9uJyAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXRzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbC5cbiAgICAmJiBtYXliZUN1c3RvbSAhPT0gaW5zcGVjdCAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAmJiAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhlIHJlY3Vyc2VUaW1lcyBhcmUgcmVwb3J0ZWQgYXMgYmVmb3JlIHdoaWxlIHVzaW5nXG4gICAgICAvLyBhIGNvdW50ZXIgaW50ZXJuYWxseS5cbiAgICAgIGNvbnN0IGRlcHRoID0gY3R4LmRlcHRoID09PSBudWxsID8gbnVsbCA6IGN0eC5kZXB0aCAtIHJlY3Vyc2VUaW1lcztcbiAgICAgIGNvbnN0IHJldCA9IG1heWJlQ3VzdG9tLmNhbGwoY29udGV4dCwgZGVwdGgsIGdldFVzZXJPcHRpb25zKGN0eCkpOyAvLyBJZiB0aGUgY3VzdG9tIGluc3BlY3Rpb24gbWV0aG9kIHJldHVybmVkIGB0aGlzYCwgZG9uJ3QgZ28gaW50b1xuICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uLlxuXG4gICAgICBpZiAocmV0ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQucmVwbGFjZSgvXFxuL2csIGBcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVXNpbmcgYW4gYXJyYXkgaGVyZSBpcyBhY3R1YWxseSBiZXR0ZXIgZm9yIHRoZSBhdmVyYWdlIGNhc2UgdGhhbiB1c2luZ1xuICAvLyBhIFNldC4gYHNlZW5gIHdpbGwgb25seSBjaGVjayBmb3IgdGhlIGRlcHRoIGFuZCB3aWxsIG5ldmVyIGdyb3cgdG9vIGxhcmdlLlxuXG5cbiAgaWYgKGN0eC5zZWVuLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgIGxldCBpbmRleCA9IDE7XG5cbiAgICBpZiAoY3R4LmNpcmN1bGFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5jaXJjdWxhciA9IG5ldyBNYXAoW1t2YWx1ZSwgaW5kZXhdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gY3R4LmNpcmN1bGFyLmdldCh2YWx1ZSk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gY3R4LmNpcmN1bGFyLnNpemUgKyAxO1xuICAgICAgICBjdHguY2lyY3VsYXIuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKGBbQ2lyY3VsYXIgKiR7aW5kZXh9XWAsICdzcGVjaWFsJyk7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0UmF3KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdHlwZWRBcnJheSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJhdyhjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHR5cGVkQXJyYXkpIHtcbiAgbGV0IGtleXM7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKTtcbiAgbGV0IHRhZyA9IHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ107IC8vIE9ubHkgbGlzdCB0aGUgdGFnIGluIGNhc2UgaXQncyBub24tZW51bWVyYWJsZSAvIG5vdCBhbiBvd24gcHJvcGVydHkuXG4gIC8vIE90aGVyd2lzZSB3ZSdkIHByaW50IHRoaXMgdHdpY2UuXG5cbiAgaWYgKHR5cGVvZiB0YWcgIT09ICdzdHJpbmcnIHx8IHRhZyAhPT0gJycgJiYgKGN0eC5zaG93SGlkZGVuID8gaGFzT3duUHJvcGVydHkgOiBwcm9wZXJ0eUlzRW51bWVyYWJsZSkodmFsdWUsIFN5bWJvbC50b1N0cmluZ1RhZykpIHtcbiAgICB0YWcgPSAnJztcbiAgfVxuXG4gIGxldCBiYXNlID0gJyc7XG4gIGxldCBmb3JtYXR0ZXIgPSBnZXRFbXB0eUZvcm1hdEFycmF5O1xuICBsZXQgYnJhY2VzO1xuICBsZXQgbm9JdGVyYXRvciA9IHRydWU7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgZmlsdGVyID0gY3R4LnNob3dIaWRkZW4gPyBBTExfUFJPUEVSVElFUyA6IE9OTFlfRU5VTUVSQUJMRTtcbiAgbGV0IGV4dHJhc1R5cGUgPSBrT2JqZWN0VHlwZTsgLy8gSXRlcmF0b3JzIGFuZCB0aGUgcmVzdCBhcmUgc3BsaXQgdG8gcmVkdWNlIGNoZWNrcy5cblxuICBpZiAodmFsdWVbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgIG5vSXRlcmF0b3IgPSBmYWxzZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSwgZmlsdGVyKTsgLy8gT25seSBzZXQgdGhlIGNvbnN0cnVjdG9yIGZvciBub24gb3JkaW5hcnkgKFwiQXJyYXkgWy4uLl1cIikgYXJyYXlzLlxuXG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ0FycmF5Jyk7XG4gICAgICBicmFjZXMgPSBbYCR7cHJlZml4ID09PSAnQXJyYXkgJyA/ICcnIDogcHJlZml4fVtgLCAnXSddO1xuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHticmFjZXNbMF19XWA7XG4gICAgICB9XG5cbiAgICAgIGV4dHJhc1R5cGUgPSBrQXJyYXlFeHRyYXNUeXBlO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0QXJyYXk7XG4gICAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1NldCcpO1xuXG4gICAgICBpZiAodmFsdWUuc2l6ZSA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fXt9YDtcbiAgICAgIH1cblxuICAgICAgYnJhY2VzID0gW2Ake3ByZWZpeH17YCwgJ30nXTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdFNldDtcbiAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnTWFwJyk7XG5cbiAgICAgIGlmICh2YWx1ZS5zaXplID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9e31gO1xuICAgICAgfVxuXG4gICAgICBicmFjZXMgPSBbYCR7cHJlZml4fXtgLCAnfSddO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0TWFwO1xuICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGNvbnN0cnVjdG9yICE9PSBudWxsID8gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcpIDogZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKS5uYW1lKTtcbiAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXh9W2AsICddJ107XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDAgJiYgIWN0eC5zaG93SGlkZGVuKSB7XG4gICAgICAgIHJldHVybiBgJHticmFjZXNbMF19XWA7XG4gICAgICB9XG5cbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdFR5cGVkQXJyYXk7XG4gICAgICBleHRyYXNUeXBlID0ga0FycmF5RXh0cmFzVHlwZTtcbiAgICB9IGVsc2UgaWYgKGlzTWFwSXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgICAgYnJhY2VzID0gZ2V0SXRlcmF0b3JCcmFjZXMoJ01hcCcsIHRhZyk7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRJdGVyYXRvcjtcbiAgICB9IGVsc2UgaWYgKGlzU2V0SXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgICAgYnJhY2VzID0gZ2V0SXRlcmF0b3JCcmFjZXMoJ1NldCcsIHRhZyk7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRJdGVyYXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9JdGVyYXRvciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vSXRlcmF0b3IpIHtcbiAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgICBpZiAoY29uc3RydWN0b3IgPT09ICdPYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcmd1bWVudHNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGJyYWNlc1swXSA9ICdbQXJndW1lbnRzXSB7JztcbiAgICAgIH0gZWxzZSBpZiAodGFnICE9PSAnJykge1xuICAgICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ09iamVjdCcpfXtgO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGAke2JyYWNlc1swXX19YDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmFzZSA9IGdldEZ1bmN0aW9uQmFzZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZyk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoYmFzZSwgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtbm9uLWxpdGVyYWwtcmVnZXhwXG4gICAgICBjb25zdCByZWdFeHAgPSBjb25zdHJ1Y3RvciAhPT0gbnVsbCA/IHZhbHVlIDogbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgICBiYXNlID0gUmVnRXhwUHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVnRXhwKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnUmVnRXhwJyk7XG5cbiAgICAgIGlmIChwcmVmaXggIT09ICdSZWdFeHAgJykge1xuICAgICAgICBiYXNlID0gYCR7cHJlZml4fSR7YmFzZX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDAgfHwgcmVjdXJzZVRpbWVzID4gY3R4LmRlcHRoICYmIGN0eC5kZXB0aCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoYmFzZSwgJ3JlZ2V4cCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgICBiYXNlID0gTnVtYmVyLmlzTmFOKERhdGVQcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbHVlKSkgPyBEYXRlUHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpIDogRGF0ZVByb3RvdHlwZS50b0lTT1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnRGF0ZScpO1xuXG4gICAgICBpZiAocHJlZml4ICE9PSAnRGF0ZSAnKSB7XG4gICAgICAgIGJhc2UgPSBgJHtwcmVmaXh9JHtiYXNlfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoYmFzZSwgJ2RhdGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICBiYXNlID0gZm9ybWF0RXJyb3IodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcsIGN0eCk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJb3MpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRXJyb3JQcm9wcyA9IFsnbGluZScsICdjb2x1bW4nLCAnc291cmNlVVJMJ107XG5cbiAgICAgICAgaWYgKGtleXMuZXZlcnkoa2V5ID0+IG5hdGl2ZUVycm9yUHJvcHMuaW5jbHVkZXMoa2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3IgQXJyYXlCdWZmZXIgYW5kIFNoYXJlZEFycmF5QnVmZmVyLlxuICAgICAgLy8gQ2FuJ3QgZG8gdGhlIHNhbWUgZm9yIERhdGFWaWV3IGJlY2F1c2UgaXQgaGFzIGEgbm9uLXByaW1pdGl2ZVxuICAgICAgLy8gLmJ1ZmZlciBwcm9wZXJ0eSB0aGF0IHdlIG5lZWQgdG8gcmVjdXJzZSBmb3IuXG4gICAgICBjb25zdCBhcnJheVR5cGUgPSBpc0FycmF5QnVmZmVyKHZhbHVlKSA/ICdBcnJheUJ1ZmZlcicgOiAnU2hhcmVkQXJyYXlCdWZmZXInO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGFycmF5VHlwZSk7XG5cbiAgICAgIGlmICh0eXBlZEFycmF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gZm9ybWF0QXJyYXlCdWZmZXI7XG4gICAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9eyBieXRlTGVuZ3RoOiAke2Zvcm1hdE51bWJlcihjdHguc3R5bGl6ZSwgdmFsdWUuYnl0ZUxlbmd0aCl9IH1gO1xuICAgICAgfVxuXG4gICAgICBicmFjZXNbMF0gPSBgJHtwcmVmaXh9e2A7XG4gICAgICBrZXlzLnVuc2hpZnQoJ2J5dGVMZW5ndGgnKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0YVZpZXcodmFsdWUpKSB7XG4gICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ0RhdGFWaWV3Jyl9e2A7IC8vIC5idWZmZXIgZ29lcyBsYXN0LCBpdCdzIG5vdCBhIHByaW1pdGl2ZSBsaWtlIHRoZSBvdGhlcnMuXG5cbiAgICAgIGtleXMudW5zaGlmdCgnYnl0ZUxlbmd0aCcsICdieXRlT2Zmc2V0JywgJ2J1ZmZlcicpO1xuICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdQcm9taXNlJyl9e2A7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAoaXNXZWFrU2V0KHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdXZWFrU2V0Jyl9e2A7XG4gICAgICBmb3JtYXR0ZXIgPSBjdHguc2hvd0hpZGRlbiA/IGZvcm1hdFdlYWtTZXQgOiBmb3JtYXRXZWFrQ29sbGVjdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzV2Vha01hcCh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnV2Vha01hcCcpfXtgO1xuICAgICAgZm9ybWF0dGVyID0gY3R4LnNob3dIaWRkZW4gPyBmb3JtYXRXZWFrTWFwIDogZm9ybWF0V2Vha0NvbGxlY3Rpb247XG4gICAgICAvKlxuICAgICAgICogQGZpeG1lIGhvdyB0byBkbyBpc01vZHVsZU5hbWVzcGFjZU9iamVjdD9cbiAgICAgIH0gZWxzZSBpZiAoaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QodmFsdWUpKSB7XG4gICAgICBcdGJyYWNlc1swXSA9IGBbJHt0YWd9XSB7YDtcbiAgICAgIFx0Zm9ybWF0dGVyID0gZm9ybWF0TmFtZXNwYWNlT2JqZWN0O1xuICAgICAgKi9cbiAgICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICBiYXNlID0gZ2V0Qm94ZWRCYXNlKHZhbHVlLCBjdHgsIGtleXMsIGNvbnN0cnVjdG9yLCB0YWcpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBpbnB1dCBwcm90b3R5cGUgZ290IG1hbmlwdWxhdGVkLiBTcGVjaWFsIGhhbmRsZSB0aGVzZS4gV2UgaGF2ZSB0b1xuICAgICAgLy8gcmVidWlsZCB0aGUgaW5mb3JtYXRpb24gc28gd2UgYXJlIGFibGUgdG8gZGlzcGxheSBldmVyeXRoaW5nLlxuICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHNwZWNpYWxJdGVyYXRvciA9IG5vUHJvdG90eXBlSXRlcmF0b3IoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKTtcblxuICAgICAgICBpZiAoc3BlY2lhbEl0ZXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHNwZWNpYWxJdGVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNNYXBJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgYnJhY2VzID0gZ2V0SXRlcmF0b3JCcmFjZXMoJ01hcCcsIHRhZyk7XG4gICAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEl0ZXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChpc1NldEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnU2V0JywgdGFnKTtcbiAgICAgICAgZm9ybWF0dGVyID0gZm9ybWF0SXRlcmF0b3I7IC8vIEhhbmRsZSBvdGhlciByZWd1bGFyIG9iamVjdHMgYWdhaW4uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYCR7Z2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpfXt9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyYWNlc1swXSA9IGAke2dldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKX17YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzID4gY3R4LmRlcHRoICYmIGN0eC5kZXB0aCAhPT0gbnVsbCkge1xuICAgIGxldCBjb25zdHJ1Y3Rvck5hbWUgPSBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykuc2xpY2UoMCwgLTEpO1xuXG4gICAgaWYgKGNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG4gICAgICBjb25zdHJ1Y3Rvck5hbWUgPSBgWyR7Y29uc3RydWN0b3JOYW1lfV1gO1xuICAgIH1cblxuICAgIHJldHVybiBjdHguc3R5bGl6ZShjb25zdHJ1Y3Rvck5hbWUsICdzcGVjaWFsJyk7XG4gIH1cblxuICByZWN1cnNlVGltZXMgKz0gMTtcbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG4gIGN0eC5jdXJyZW50RGVwdGggPSByZWN1cnNlVGltZXM7XG4gIGxldCBvdXRwdXQ7XG4gIGNvbnN0IGluZGVudGF0aW9uTHZsID0gY3R4LmluZGVudGF0aW9uTHZsO1xuXG4gIHRyeSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0dGVyKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5cywgYnJhY2VzKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleXNbaV0sIGV4dHJhc1R5cGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IGdldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKS5zbGljZSgwLCAtMSk7XG4gICAgcmV0dXJuIGhhbmRsZU1heENhbGxTdGFja1NpemUoY3R4LCBlcnIsIGNvbnN0cnVjdG9yTmFtZSwgaW5kZW50YXRpb25MdmwpO1xuICB9XG5cbiAgaWYgKGN0eC5jaXJjdWxhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgaW5kZXggPSBjdHguY2lyY3VsYXIuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2UgPSBjdHguc3R5bGl6ZShgPHJlZiAqJHtpbmRleH0+YCwgJ3NwZWNpYWwnKTsgLy8gQWRkIHJlZmVyZW5jZSBhbHdheXMgdG8gdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSBvdXRwdXQuXG5cbiAgICAgIGlmIChjdHguY29tcGFjdCAhPT0gdHJ1ZSkge1xuICAgICAgICBiYXNlID0gYmFzZSA9PT0gJycgPyByZWZlcmVuY2UgOiBgJHtyZWZlcmVuY2V9ICR7YmFzZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJhY2VzWzBdID0gYCR7cmVmZXJlbmNlfSAke2JyYWNlc1swXX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIGlmIChjdHguc29ydGVkKSB7XG4gICAgY29uc3QgY29tcGFyYXRvciA9IGN0eC5zb3J0ZWQgPT09IHRydWUgPyB1bmRlZmluZWQgOiBjdHguc29ydGVkO1xuXG4gICAgaWYgKGV4dHJhc1R5cGUgPT09IGtPYmplY3RUeXBlKSB7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQuc29ydChjb21wYXJhdG9yKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3Qgc29ydGVkID0gb3V0cHV0LnNsaWNlKG91dHB1dC5sZW5ndGggLSBrZXlzLmxlbmd0aCkuc29ydChjb21wYXJhdG9yKTtcbiAgICAgIG91dHB1dC5zcGxpY2Uob3V0cHV0Lmxlbmd0aCAtIGtleXMubGVuZ3RoLCBrZXlzLmxlbmd0aCwgLi4uc29ydGVkKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXMgPSByZWR1Y2VUb1NpbmdsZVN0cmluZyhjdHgsIG91dHB1dCwgYmFzZSwgYnJhY2VzLCBleHRyYXNUeXBlLCByZWN1cnNlVGltZXMsIHZhbHVlKTtcbiAgY29uc3QgYnVkZ2V0ID0gY3R4LmJ1ZGdldFtjdHguaW5kZW50YXRpb25MdmxdIHx8IDA7XG4gIGNvbnN0IG5ld0xlbmd0aCA9IGJ1ZGdldCArIHJlcy5sZW5ndGg7XG4gIGN0eC5idWRnZXRbY3R4LmluZGVudGF0aW9uTHZsXSA9IG5ld0xlbmd0aDsgLy8gSWYgYW55IGluZGVudGF0aW9uTHZsIGV4Y2VlZHMgdGhpcyBsaW1pdCwgbGltaXQgZnVydGhlciBpbnNwZWN0aW5nIHRvIHRoZVxuICAvLyBtaW5pbXVtLiBPdGhlcndpc2UgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG0gbWlnaHQgY29udGludWUgaW5zcGVjdGluZyB0aGVcbiAgLy8gb2JqZWN0IGV2ZW4gdGhvdWdoIHRoZSBtYXhpbXVtIHN0cmluZyBzaXplICh+MiAqKiAyOCBvbiAzMiBiaXQgc3lzdGVtcyBhbmRcbiAgLy8gfjIgKiogMzAgb24gNjQgYml0IHN5c3RlbXMpIGV4Y2VlZGVkLiBUaGUgYWN0dWFsIG91dHB1dCBpcyBub3QgbGltaXRlZCBhdFxuICAvLyBleGFjdGx5IDIgKiogMjcgYnV0IGEgYml0IGhpZ2hlci4gVGhpcyBkZXBlbmRzIG9uIHRoZSBvYmplY3Qgc2hhcGUuXG4gIC8vIFRoaXMgbGltaXQgYWxzbyBtYWtlcyBzdXJlIHRoYXQgaHVnZSBvYmplY3RzIGRvbid0IGJsb2NrIHRoZSBldmVudCBsb29wXG4gIC8vIHNpZ25pZmljYW50bHkuXG5cbiAgaWYgKG5ld0xlbmd0aCA+IDIgKiogMjcpIHtcbiAgICBjdHguZGVwdGggPSAtMTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yQnJhY2VzKHR5cGUsIHRhZykge1xuICBpZiAodGFnICE9PSBgJHt0eXBlfSBJdGVyYXRvcmApIHtcbiAgICBpZiAodGFnICE9PSAnJykge1xuICAgICAgdGFnICs9ICddIFsnO1xuICAgIH1cblxuICAgIHRhZyArPSBgJHt0eXBlfSBJdGVyYXRvcmA7XG4gIH1cblxuICByZXR1cm4gW2BbJHt0YWd9XSB7YCwgJ30nXTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm94ZWRCYXNlKHZhbHVlLCBjdHgsIGtleXMsIGNvbnN0cnVjdG9yLCB0YWcpIHtcbiAgbGV0IGZuO1xuICBsZXQgdHlwZTtcblxuICBpZiAoaXNOdW1iZXJPYmplY3QodmFsdWUpKSB7XG4gICAgZm4gPSBOdW1iZXJQcm90b3R5cGU7XG4gICAgdHlwZSA9ICdOdW1iZXInO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbHVlKSkge1xuICAgIGZuID0gU3RyaW5nUHJvdG90eXBlO1xuICAgIHR5cGUgPSAnU3RyaW5nJzsgLy8gRm9yIGJveGVkIFN0cmluZ3MsIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSAwLW4gaW5kZXhlZCBlbnRyaWVzLFxuICAgIC8vIHNpbmNlIHRoZXkganVzdCBub2lzeSB1cCB0aGUgb3V0cHV0IGFuZCBhcmUgcmVkdW5kYW50XG4gICAgLy8gTWFrZSBib3hlZCBwcmltaXRpdmUgU3RyaW5ncyBsb29rIGxpa2Ugc3VjaFxuXG4gICAga2V5cy5zcGxpY2UoMCwgdmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5PYmplY3QodmFsdWUpKSB7XG4gICAgZm4gPSBCb29sZWFuUHJvdG90eXBlO1xuICAgIHR5cGUgPSAnQm9vbGVhbic7XG4gIH0gZWxzZSB7XG4gICAgZm4gPSBTeW1ib2xQcm90b3R5cGU7XG4gICAgdHlwZSA9ICdTeW1ib2wnO1xuICB9XG5cbiAgbGV0IGJhc2UgPSBgWyR7dHlwZX1gO1xuXG4gIGlmICh0eXBlICE9PSBjb25zdHJ1Y3Rvcikge1xuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgYmFzZSArPSAnIChudWxsIHByb3RvdHlwZSknO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlICs9IGAgKCR7Y29uc3RydWN0b3J9KWA7XG4gICAgfVxuICB9XG5cbiAgYmFzZSArPSBgOiAke2Zvcm1hdFByaW1pdGl2ZShzdHlsaXplTm9Db2xvciwgZm4udmFsdWVPZih2YWx1ZSksIGN0eCl9XWA7XG5cbiAgaWYgKHRhZyAhPT0gJycgJiYgdGFnICE9PSBjb25zdHJ1Y3Rvcikge1xuICAgIGJhc2UgKz0gYCBbJHt0YWd9XWA7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggIT09IDAgfHwgY3R4LnN0eWxpemUgPT09IHN0eWxpemVOb0NvbG9yKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICByZXR1cm4gY3R4LnN0eWxpemUoYmFzZSwgdHlwZS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25CYXNlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKSB7XG4gIGxldCB0eXBlID0gJ0Z1bmN0aW9uJztcblxuICBpZiAoaXNHZW5lcmF0b3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB0eXBlID0gYEdlbmVyYXRvciR7dHlwZX1gO1xuICB9XG5cbiAgaWYgKGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB0eXBlID0gYEFzeW5jJHt0eXBlfWA7XG4gIH1cblxuICBsZXQgYmFzZSA9IGBbJHt0eXBlfWA7XG5cbiAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgYmFzZSArPSAnIChudWxsIHByb3RvdHlwZSknO1xuICB9XG5cbiAgaWYgKHZhbHVlLm5hbWUgPT09ICcnKSB7XG4gICAgYmFzZSArPSAnIChhbm9ueW1vdXMpJztcbiAgfSBlbHNlIHtcbiAgICBiYXNlICs9IGA6ICR7dmFsdWUubmFtZX1gO1xuICB9XG5cbiAgYmFzZSArPSAnXSc7XG5cbiAgaWYgKGNvbnN0cnVjdG9yICE9PSB0eXBlICYmIGNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG4gICAgYmFzZSArPSBgICR7Y29uc3RydWN0b3J9YDtcbiAgfVxuXG4gIGlmICh0YWcgIT09ICcnICYmIGNvbnN0cnVjdG9yICE9PSB0YWcpIHtcbiAgICBiYXNlICs9IGAgWyR7dGFnfV1gO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGVyciwgY29uc3RydWN0b3IsIHRhZywgY3R4KSB7XG4gIGxldCBzdGFjayA9IGVyci5zdGFjayB8fCBFcnJvclByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycik7IC8vIHRyeSB0byBub3JtYWxpemUgSmF2YVNjcmlwdENvcmUgc3RhY2sgdG8gbWF0Y2ggdjhcblxuICBpZiAoaXNJb3MpIHtcbiAgICBjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICBzdGFjayA9IGAke2Vyci5uYW1lfTogJHtlcnIubWVzc2FnZX1gO1xuXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrICs9IGxpbmVzLm1hcChzdGFja0xpbmUgPT4ge1xuICAgICAgICBjb25zdCBhdFN5bWJvbEluZGV4ID0gc3RhY2tMaW5lLmluZGV4T2YoJ0AnKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gc3RhY2tMaW5lLnNsaWNlKGF0U3ltYm9sSW5kZXggKyAxKTtcbiAgICAgICAgY29uc3Qgc291cmNlUGF0dGVybiA9IC8oLiopOihcXGQrKTooXFxkKykvO1xuICAgICAgICBsZXQgc3ltYm9sTmFtZSA9ICd1bmtub3duJztcblxuICAgICAgICBpZiAoYXRTeW1ib2xJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzeW1ib2xOYW1lID0gc3RhY2tMaW5lLnNsaWNlKDAsIGF0U3ltYm9sSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc291cmNlTWF0Y2ggPSBzb3VyY2UubWF0Y2goc291cmNlUGF0dGVybik7XG5cbiAgICAgICAgaWYgKHNvdXJjZU1hdGNoKSB7XG4gICAgICAgICAgbGV0IGZpbGVQYXRoID0gc291cmNlTWF0Y2hbMV07XG4gICAgICAgICAgY29uc3QgbGluZU51bWJlciA9IHNvdXJjZU1hdGNoWzJdO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHNvdXJjZU1hdGNoWzNdO1xuXG4gICAgICAgICAgaWYgKGZpbGVQYXRoLnN0YXJ0c1dpdGgoJ2ZpbGU6JykpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGgucmVwbGFjZShgZmlsZTovLyR7VGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3Rvcnl9YCwgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBgXFxuICAgIGF0ICR7c3ltYm9sTmFtZX0gKCR7ZmlsZVBhdGh9OiR7bGluZU51bWJlcn06JHtjb2x1bW59KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGBcXG4gICAgYXQgJHtzeW1ib2xOYW1lfSAoJHtzb3VyY2V9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfSAvLyBBIHN0YWNrIHRyYWNlIG1heSBjb250YWluIGFyYml0cmFyeSBkYXRhLiBPbmx5IG1hbmlwdWxhdGUgdGhlIG91dHB1dFxuICAvLyBmb3IgXCJyZWd1bGFyIGVycm9yc1wiIChlcnJvcnMgdGhhdCBcImxvb2sgbm9ybWFsXCIpIGZvciBub3cuXG5cblxuICBjb25zdCBuYW1lID0gZXJyLm5hbWUgfHwgJ0Vycm9yJztcbiAgbGV0IGxlbiA9IG5hbWUubGVuZ3RoO1xuXG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCB8fCBuYW1lLmVuZHNXaXRoKCdFcnJvcicpICYmIHN0YWNrLnN0YXJ0c1dpdGgobmFtZSkgJiYgKHN0YWNrLmxlbmd0aCA9PT0gbGVuIHx8IHN0YWNrW2xlbl0gPT09ICc6JyB8fCBzdGFja1tsZW5dID09PSAnXFxuJykpIHtcbiAgICBsZXQgZmFsbGJhY2sgPSAnRXJyb3InO1xuXG4gICAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICBjb25zdCBzdGFydCA9IHN0YWNrLm1hdGNoKC9eKFtBLVpdW2Etel8gQS1aMC05W1xcXSgpLV0rKSg/Ojp8XFxuIHs0fWF0KS8pIHx8IHN0YWNrLm1hdGNoKC9eKFthLXpfQS1aMC05LV0qRXJyb3IpJC8pO1xuICAgICAgZmFsbGJhY2sgPSBzdGFydCAmJiBzdGFydFsxXSB8fCAnJztcbiAgICAgIGxlbiA9IGZhbGxiYWNrLmxlbmd0aDtcbiAgICAgIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgJ0Vycm9yJztcbiAgICB9XG5cbiAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgZmFsbGJhY2spLnNsaWNlKDAsIC0xKTtcblxuICAgIGlmIChuYW1lICE9PSBwcmVmaXgpIHtcbiAgICAgIGlmIChwcmVmaXguaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgIHN0YWNrID0gYCR7cHJlZml4fTogJHtzdGFja31gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrID0gYCR7cHJlZml4fSR7c3RhY2suc2xpY2UobGVuKX1gO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFjayA9IGAke3ByZWZpeH0gWyR7bmFtZX1dJHtzdGFjay5zbGljZShsZW4pfWA7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIElnbm9yZSB0aGUgZXJyb3IgbWVzc2FnZSBpZiBpdCdzIGNvbnRhaW5lZCBpbiB0aGUgc3RhY2suXG5cblxuICBsZXQgcG9zID0gZXJyLm1lc3NhZ2UgJiYgc3RhY2suaW5kZXhPZihlcnIubWVzc2FnZSkgfHwgLTE7XG5cbiAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICBwb3MgKz0gZXJyLm1lc3NhZ2UubGVuZ3RoO1xuICB9IC8vIFdyYXAgdGhlIGVycm9yIGluIGJyYWNrZXRzIGluIGNhc2UgaXQgaGFzIG5vIHN0YWNrIHRyYWNlLlxuXG5cbiAgbGV0IHN0YWNrU3RhcnQgPSBzdGFjay5pbmRleE9mKCdcXG4gICAgYXQnLCBwb3MpO1xuXG4gIGlmIChzdGFja1N0YXJ0ID09PSAtMSkge1xuICAgIHN0YWNrID0gYFske3N0YWNrfV1gO1xuICB9IGVsc2UgaWYgKGN0eC5jb2xvcnMpIHtcbiAgICAvLyBIaWdobGlnaHQgdXNlcmxhbmQgY29kZSBhbmQgbm9kZSBtb2R1bGVzLlxuICAgIGxldCBuZXdTdGFjayA9IHN0YWNrLnNsaWNlKDAsIHN0YWNrU3RhcnQpO1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc2xpY2Uoc3RhY2tTdGFydCArIDEpLnNwbGl0KCdcXG4nKTtcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgLy8gVGhpcyBhZGRzIHVuZGVyc2NvcmVzIHRvIGFsbCBub2RlX21vZHVsZXMgdG8gcXVpY2tseSBpZGVudGlmeSB0aGVtLlxuICAgICAgbGV0IG5vZGVNb2R1bGU7XG4gICAgICBuZXdTdGFjayArPSAnXFxuJztcbiAgICAgIGxldCBwb3MgPSAwO1xuXG4gICAgICB3aGlsZSAobm9kZU1vZHVsZSA9IG5vZGVNb2R1bGVzUmVnRXhwLmV4ZWMobGluZSkpIHtcbiAgICAgICAgLy8gJy9ub2RlX21vZHVsZXMvJy5sZW5ndGggPT09IDE0XG4gICAgICAgIG5ld1N0YWNrICs9IGxpbmUuc2xpY2UocG9zLCBub2RlTW9kdWxlLmluZGV4ICsgMTQpO1xuICAgICAgICBuZXdTdGFjayArPSBjdHguc3R5bGl6ZShub2RlTW9kdWxlWzFdLCAnbW9kdWxlJyk7XG4gICAgICAgIHBvcyA9IG5vZGVNb2R1bGUuaW5kZXggKyBub2RlTW9kdWxlWzBdLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbmV3U3RhY2sgKz0gcG9zID09PSAwID8gbGluZSA6IGxpbmUuc2xpY2UocG9zKTtcbiAgICB9XG5cbiAgICBzdGFjayA9IG5ld1N0YWNrO1xuICB9IC8vIFRoZSBtZXNzYWdlIGFuZCB0aGUgc3RhY2sgaGF2ZSB0byBiZSBpbmRlbnRlZCBhcyB3ZWxsIVxuXG5cbiAgaWYgKGN0eC5pbmRlbnRhdGlvbkx2bCAhPT0gMCkge1xuICAgIGNvbnN0IGluZGVudGF0aW9uID0gJyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpO1xuICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXFxuL2csIGBcXG4ke2luZGVudGF0aW9ufWApO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRQcm9taXNlKGN0eCwgX3ZhbHVlLCBfcmVjdXJzZVRpbWVzKSB7XG4gIC8vIE5vZGUgY2FsbHMgaW50byBuYXRpdmUgdG8gZ2V0IHByb21pc2UgZGV0YWlscyB3aGljaCB3ZSBjYW4ndCBkb1xuICByZXR1cm4gW2N0eC5zdHlsaXplKCc8dW5rbm93bj4nLCAnc3BlY2lhbCcpXTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBrZXksIHR5cGUpIHtcbiAgbGV0IG5hbWUsIHN0cjtcbiAgbGV0IGV4dHJhID0gJyAnO1xuICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7XG4gICAgdmFsdWU6IHZhbHVlW2tleV0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9O1xuXG4gIGlmIChkZXNjLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkaWZmID0gdHlwZSAhPT0ga09iamVjdFR5cGUgfHwgY3R4LmNvbXBhY3QgIT09IHRydWUgPyAyIDogMztcbiAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gZGlmZjtcbiAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyk7XG5cbiAgICBpZiAoZGlmZiA9PT0gMykge1xuICAgICAgY29uc3QgbGVuID0gY3R4LmNvbG9ycyA/IHJlbW92ZUNvbG9ycyhzdHIpLmxlbmd0aCA6IHN0ci5sZW5ndGg7XG5cbiAgICAgIGlmIChjdHguYnJlYWtMZW5ndGggPCBsZW4pIHtcbiAgICAgICAgZXh0cmEgPSBgXFxuJHsnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCl9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguaW5kZW50YXRpb25MdmwgLT0gZGlmZjtcbiAgfSBlbHNlIGlmIChkZXNjLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbGFiZWwgPSBkZXNjLnNldCAhPT0gdW5kZWZpbmVkID8gJ0dldHRlci9TZXR0ZXInIDogJ0dldHRlcic7XG4gICAgY29uc3QgcyA9IGN0eC5zdHlsaXplO1xuICAgIGNvbnN0IHNwID0gJ3NwZWNpYWwnO1xuXG4gICAgaWYgKGN0eC5nZXR0ZXJzICYmIChjdHguZ2V0dGVycyA9PT0gdHJ1ZSB8fCBjdHguZ2V0dGVycyA9PT0gJ2dldCcgJiYgZGVzYy5zZXQgPT09IHVuZGVmaW5lZCB8fCBjdHguZ2V0dGVycyA9PT0gJ3NldCcgJiYgZGVzYy5zZXQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHZhbHVlW2tleV07XG4gICAgICAgIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gICAgICAgIGlmICh0bXAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdHIgPSBgJHtzKGBbJHtsYWJlbH06YCwgc3ApfSAke3MoJ251bGwnLCAnbnVsbCcpfSR7cygnXScsIHNwKX1gO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0bXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9XWAsIHNwKX0gJHtmb3JtYXRWYWx1ZShjdHgsIHRtcCwgcmVjdXJzZVRpbWVzKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShzLCB0bXAsIGN0eCk7XG4gICAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9OmAsIHNwKX0gJHtwcmltaXRpdmV9JHtzKCddJywgc3ApfWA7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYDxJbnNwZWN0aW9uIHRocmV3ICgke2Vyci5tZXNzYWdlfSk+YDtcbiAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9OmAsIHNwKX0gJHttZXNzYWdlfSR7cygnXScsIHNwKX1gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZShgWyR7bGFiZWx9XWAsIHNwKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVzYy5zZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBrQXJyYXlUeXBlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuICAgIGNvbnN0IHRtcCA9IGtleS50b1N0cmluZygpLnJlcGxhY2Uoc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIsIGVzY2FwZUZuKTtcbiAgICBuYW1lID0gYFske2N0eC5zdHlsaXplKHRtcCwgJ3N5bWJvbCcpfV1gO1xuICB9IGVsc2UgaWYgKGRlc2MuZW51bWVyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICBuYW1lID0gYFske2tleS5yZXBsYWNlKHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyLCBlc2NhcGVGbil9XWA7XG4gIH0gZWxzZSBpZiAoa2V5U3RyUmVnRXhwLnRlc3Qoa2V5KSkge1xuICAgIG5hbWUgPSBjdHguc3R5bGl6ZShrZXksICduYW1lJyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IGN0eC5zdHlsaXplKHN0ckVzY2FwZShrZXkpLCAnc3RyaW5nJyk7XG4gIH1cblxuICByZXR1cm4gYCR7bmFtZX06JHtleHRyYX0ke3N0cn1gO1xufVxuXG5mdW5jdGlvbiBncm91cEFycmF5RWxlbWVudHMoY3R4LCBvdXRwdXQsIHZhbHVlKSB7XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIGxldCBtYXhMZW5ndGggPSAwO1xuICBsZXQgaSA9IDA7XG4gIGxldCBvdXRwdXRMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG4gIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPCBvdXRwdXQubGVuZ3RoKSB7XG4gICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoZSBcIi4uLiBuIG1vcmUgaXRlbXNcIiBwYXJ0IGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgb3V0cHV0TGVuZ3RoLS07XG4gIH1cblxuICBjb25zdCBzZXBhcmF0b3JTcGFjZSA9IDI7IC8vIEFkZCAxIGZvciB0aGUgc3BhY2UgYW5kIDEgZm9yIHRoZSBzZXBhcmF0b3IuXG5cbiAgY29uc3QgZGF0YUxlbiA9IG5ldyBBcnJheShvdXRwdXRMZW5ndGgpOyAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiBhbGwgb3V0cHV0IGVudHJpZXMgYW5kIHRoZSBpbmRpdmlkdWFsIG1heFxuICAvLyBlbnRyaWVzIGxlbmd0aCBvZiBhbGwgb3V0cHV0IGVudHJpZXMuIFdlIGhhdmUgdG8gcmVtb3ZlIGNvbG9ycyBmaXJzdCxcbiAgLy8gb3RoZXJ3aXNlIHRoZSBsZW5ndGggd291bGQgbm90IGJlIGNhbGN1bGF0ZWQgcHJvcGVybHkuXG5cbiAgZm9yICg7IGkgPCBvdXRwdXRMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxlbiA9IGN0eC5jb2xvcnMgPyByZW1vdmVDb2xvcnMob3V0cHV0W2ldKS5sZW5ndGggOiBvdXRwdXRbaV0ubGVuZ3RoO1xuICAgIGRhdGFMZW5baV0gPSBsZW47XG4gICAgdG90YWxMZW5ndGggKz0gbGVuICsgc2VwYXJhdG9yU3BhY2U7XG5cbiAgICBpZiAobWF4TGVuZ3RoIDwgbGVuKSB7XG4gICAgICBtYXhMZW5ndGggPSBsZW47XG4gICAgfVxuICB9IC8vIEFkZCB0d28gdG8gYG1heExlbmd0aGAgYXMgd2UgYWRkIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyIHBsdXMgYSBjb21tYVxuICAvLyBpbi1iZXR3ZWVuIHR3byBlbnRyaWVzLlxuXG5cbiAgY29uc3QgYWN0dWFsTWF4ID0gbWF4TGVuZ3RoICsgc2VwYXJhdG9yU3BhY2U7IC8vIENoZWNrIGlmIGF0IGxlYXN0IHRocmVlIGVudHJpZXMgZml0IG5leHQgdG8gZWFjaCBvdGhlciBhbmQgcHJldmVudCBncm91cGluZ1xuICAvLyBvZiBhcnJheXMgdGhhdCBjb250YWlucyBlbnRyaWVzIG9mIHZlcnkgZGlmZmVyZW50IGxlbmd0aCAoaS5lLiwgaWYgYSBzaW5nbGVcbiAgLy8gZW50cnkgaXMgbG9uZ2VyIHRoYW4gMS81IG9mIGFsbCBvdGhlciBlbnRyaWVzIGNvbWJpbmVkKS4gT3RoZXJ3aXNlIHRoZVxuICAvLyBzcGFjZSBpbi1iZXR3ZWVuIHNtYWxsIGVudHJpZXMgd291bGQgYmUgZW5vcm1vdXMuXG5cbiAgaWYgKGFjdHVhbE1heCAqIDMgKyBjdHguaW5kZW50YXRpb25MdmwgPCBjdHguYnJlYWtMZW5ndGggJiYgKHRvdGFsTGVuZ3RoIC8gYWN0dWFsTWF4ID4gNSB8fCBtYXhMZW5ndGggPD0gNikpIHtcbiAgICBjb25zdCBhcHByb3hDaGFySGVpZ2h0cyA9IDIuNTtcbiAgICBjb25zdCBhdmVyYWdlQmlhcyA9IE1hdGguc3FydChhY3R1YWxNYXggLSB0b3RhbExlbmd0aCAvIG91dHB1dC5sZW5ndGgpO1xuICAgIGNvbnN0IGJpYXNlZE1heCA9IE1hdGgubWF4KGFjdHVhbE1heCAtIDMgLSBhdmVyYWdlQmlhcywgMSk7IC8vIER5bmFtaWNhbGx5IGNoZWNrIGhvdyBtYW55IGNvbHVtbnMgc2VlbSBwb3NzaWJsZS5cblxuICAgIGNvbnN0IGNvbHVtbnMgPSBNYXRoLm1pbiggLy8gSWRlYWxseSBhIHNxdWFyZSBzaG91bGQgYmUgZHJhd24uIFdlIGV4cGVjdCBhIGNoYXJhY3RlciB0byBiZSBhYm91dCAyLjVcbiAgICAvLyB0aW1lcyBhcyBoaWdoIGFzIHdpZGUuIFRoaXMgaXMgdGhlIGFyZWEgZm9ybXVsYSB0byBjYWxjdWxhdGUgYSBzcXVhcmVcbiAgICAvLyB3aGljaCBjb250YWlucyBuIHJlY3RhbmdsZXMgb2Ygc2l6ZSBgYWN0dWFsTWF4ICogYXBwcm94Q2hhckhlaWdodHNgLlxuICAgIC8vIERpdmlkZSB0aGF0IGJ5IGBhY3R1YWxNYXhgIHRvIHJlY2VpdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgLy8gVGhlIGFkZGVkIGJpYXMgaW5jcmVhc2VzIHRoZSBjb2x1bW5zIGZvciBzaG9ydCBlbnRyaWVzLlxuICAgIE1hdGgucm91bmQoTWF0aC5zcXJ0KGFwcHJveENoYXJIZWlnaHRzICogYmlhc2VkTWF4ICogb3V0cHV0TGVuZ3RoKSAvIGJpYXNlZE1heCksIC8vIERvIG5vdCBleGNlZWQgdGhlIGJyZWFrTGVuZ3RoLlxuICAgIE1hdGguZmxvb3IoKGN0eC5icmVha0xlbmd0aCAtIGN0eC5pbmRlbnRhdGlvbkx2bCkgLyBhY3R1YWxNYXgpLCAvLyBMaW1pdCBhcnJheSBncm91cGluZyBmb3Igc21hbGwgYGNvbXBhY3RgIG1vZGVzIGFzIHRoZSB1c2VyIHJlcXVlc3RlZFxuICAgIC8vIG1pbmltYWwgZ3JvdXBpbmcuXG4gICAgY3R4LmNvbXBhY3QgKiA0LCAvLyBMaW1pdCB0aGUgY29sdW1ucyB0byBhIG1heGltdW0gb2YgZmlmdGVlbi5cbiAgICAxNSk7IC8vIFJldHVybiB3aXRoIHRoZSBvcmlnaW5hbCBvdXRwdXQgaWYgbm8gZ3JvdXBpbmcgc2hvdWxkIGhhcHBlbi5cblxuICAgIGlmIChjb2x1bW5zIDw9IDEpIHtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgY29uc3QgdG1wID0gW107XG4gICAgY29uc3QgbWF4TGluZUxlbmd0aCA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zOyBpKyspIHtcbiAgICAgIGxldCBsaW5lTWF4TGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBvdXRwdXQubGVuZ3RoOyBqICs9IGNvbHVtbnMpIHtcbiAgICAgICAgaWYgKGRhdGFMZW5bal0gPiBsaW5lTWF4TGVuZ3RoKSB7XG4gICAgICAgICAgbGluZU1heExlbmd0aCA9IGRhdGFMZW5bal07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZU1heExlbmd0aCArPSBzZXBhcmF0b3JTcGFjZTtcbiAgICAgIG1heExpbmVMZW5ndGhbaV0gPSBsaW5lTWF4TGVuZ3RoO1xuICAgIH1cblxuICAgIGxldCBvcmRlciA9ICdwYWRTdGFydCc7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmRlciA9ICdwYWRFbmQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBFYWNoIGl0ZXJhdGlvbiBjcmVhdGVzIGEgc2luZ2xlIGxpbmUgb2YgZ3JvdXBlZCBlbnRyaWVzLlxuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dExlbmd0aDsgaSArPSBjb2x1bW5zKSB7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lcyBtYXkgY29udGFpbiBsZXNzIGVudHJpZXMgdGhhbiBjb2x1bW5zLlxuICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4oaSArIGNvbHVtbnMsIG91dHB1dExlbmd0aCk7XG4gICAgICBsZXQgc3RyID0gJyc7XG4gICAgICBsZXQgaiA9IGk7XG5cbiAgICAgIGZvciAoOyBqIDwgbWF4IC0gMTsgaisrKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBleHRyYSBjb2xvciBwYWRkaW5nIGluIGNhc2UgaXQncyBhY3RpdmUuIFRoaXMgaGFzIHRvIGJlXG4gICAgICAgIC8vIGRvbmUgbGluZSBieSBsaW5lIGFzIHNvbWUgbGluZXMgbWlnaHQgY29udGFpbiBtb3JlIGNvbG9ycyB0aGFuXG4gICAgICAgIC8vIG90aGVycy5cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IG1heExpbmVMZW5ndGhbaiAtIGldICsgb3V0cHV0W2pdLmxlbmd0aCAtIGRhdGFMZW5bal07XG4gICAgICAgIHN0ciArPSBgJHtvdXRwdXRbal19LCBgW29yZGVyXShwYWRkaW5nLCAnICcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JkZXIgPT09ICdwYWRTdGFydCcpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IG1heExpbmVMZW5ndGhbaiAtIGldICsgb3V0cHV0W2pdLmxlbmd0aCAtIGRhdGFMZW5bal0gLSBzZXBhcmF0b3JTcGFjZTtcbiAgICAgICAgc3RyICs9IG91dHB1dFtqXS5wYWRTdGFydChwYWRkaW5nLCAnICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IG91dHB1dFtqXTtcbiAgICAgIH1cblxuICAgICAgdG1wLnB1c2goc3RyKTtcbiAgICB9XG5cbiAgICBpZiAoY3R4Lm1heEFycmF5TGVuZ3RoIDwgb3V0cHV0Lmxlbmd0aCkge1xuICAgICAgdG1wLnB1c2gob3V0cHV0W291dHB1dExlbmd0aF0pO1xuICAgIH1cblxuICAgIG91dHB1dCA9IHRtcDtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heENhbGxTdGFja1NpemUoY3R4LCBlcnIsIGNvbnN0cnVjdG9yTmFtZSwgaW5kZW50YXRpb25MdmwpIHtcbiAgaWYgKGlzU3RhY2tPdmVyZmxvd0Vycm9yKGVycikpIHtcbiAgICBjdHguc2Vlbi5wb3AoKTtcbiAgICBjdHguaW5kZW50YXRpb25MdmwgPSBpbmRlbnRhdGlvbkx2bDtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoYFske2NvbnN0cnVjdG9yTmFtZX06IEluc3BlY3Rpb24gaW50ZXJydXB0ZWQgJ3ByZW1hdHVyZWx5LiBNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZC5dYCwgJ3NwZWNpYWwnKTtcbiAgfVxuXG4gIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKGZuLCB2YWx1ZSkge1xuICAvLyBGb3JtYXQgLTAgYXMgJy0wJy4gQ2hlY2tpbmcgYHZhbHVlID09PSAtMGAgd29uJ3QgZGlzdGluZ3Vpc2ggMCBmcm9tIC0wLlxuICByZXR1cm4gZm4oT2JqZWN0LmlzKHZhbHVlLCAtMCkgPyAnLTAnIDogYCR7dmFsdWV9YCwgJ251bWJlcicpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRCaWdJbnQoZm4sIHZhbHVlKSB7XG4gIHJldHVybiBmbihgJHt2YWx1ZX1uYCwgJ2JpZ2ludCcpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoZm4sIHZhbHVlLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoY3R4LmNvbXBhY3QgIT09IHRydWUgJiYgdmFsdWUubGVuZ3RoID4ga01pbkxpbmVMZW5ndGggJiYgdmFsdWUubGVuZ3RoID4gY3R4LmJyZWFrTGVuZ3RoIC0gY3R4LmluZGVudGF0aW9uTHZsIC0gNCkge1xuICAgICAgcmV0dXJuIHZhbHVlLnNwbGl0KC9cXG4vKS5tYXAobGluZSA9PiBmbihzdHJFc2NhcGUobGluZSksICdzdHJpbmcnKSkuam9pbihgICtcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsICsgMil9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKHN0ckVzY2FwZSh2YWx1ZSksICdzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcihmbiwgdmFsdWUpO1xuICB9XG4gIC8qXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gIFx0cmV0dXJuIGZvcm1hdEJpZ0ludChmbiwgdmFsdWUpO1xuICB9XG4gICovXG5cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gZm4oYCR7dmFsdWV9YCwgJ2Jvb2xlYW4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZuKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIH0gLy8gZXM2IHN5bWJvbCBwcmltaXRpdmVcblxuXG4gIHJldHVybiBmbihTeW1ib2xQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdzeW1ib2wnKTtcbn0gLy8gVGhlIGFycmF5IGlzIHNwYXJzZSBhbmQvb3IgaGFzIGV4dHJhIGtleXNcblxuXG5mdW5jdGlvbiBmb3JtYXRTcGVjaWFsQXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBtYXhMZW5ndGgsIG91dHB1dCwgaSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICBsZXQgaW5kZXggPSBpO1xuXG4gIGZvciAoOyBpIDwga2V5cy5sZW5ndGggJiYgb3V0cHV0Lmxlbmd0aCA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB0bXAgPSAra2V5OyAvLyBBcnJheXMgY2FuIG9ubHkgaGF2ZSB1cCB0byAyXjMyIC0gMSBlbnRyaWVzXG5cbiAgICBpZiAodG1wID4gMiAqKiAzMiAtIDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChgJHtpbmRleH1gICE9PSBrZXkpIHtcbiAgICAgIGlmICghbnVtYmVyUmVnRXhwLnRlc3Qoa2V5KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW1wdHlJdGVtcyA9IHRtcCAtIGluZGV4O1xuICAgICAgY29uc3QgZW5kaW5nID0gZW1wdHlJdGVtcyA+IDEgPyAncycgOiAnJztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgPCR7ZW1wdHlJdGVtc30gZW1wdHkgaXRlbSR7ZW5kaW5nfT5gO1xuICAgICAgb3V0cHV0LnB1c2goY3R4LnN0eWxpemUobWVzc2FnZSwgJ3VuZGVmaW5lZCcpKTtcbiAgICAgIGluZGV4ID0gdG1wO1xuXG4gICAgICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gbWF4TGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5LCBrQXJyYXlUeXBlKSk7XG4gICAgaW5kZXgrKztcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHZhbHVlLmxlbmd0aCAtIGluZGV4O1xuXG4gIGlmIChvdXRwdXQubGVuZ3RoICE9PSBtYXhMZW5ndGgpIHtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgY29uc3QgZW5kaW5nID0gcmVtYWluaW5nID4gMSA/ICdzJyA6ICcnO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGA8JHtyZW1haW5pbmd9IGVtcHR5IGl0ZW0ke2VuZGluZ30+YDtcbiAgICAgIG91dHB1dC5wdXNoKGN0eC5zdHlsaXplKG1lc3NhZ2UsICd1bmRlZmluZWQnKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5QnVmZmVyKGN0eCwgdmFsdWUpIHtcbiAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAvKlxuICAvLyBAZml4bWUgcm9sbHVwIGNhbm5vdCBoYW5kbGUgbGF6eSBsb2FkZWQgbW9kdWxlcywgbWF5YmUgbW92ZSB0byB3ZWJwYWNrP1xuICBpZiAoaGV4U2xpY2UgPT09IHVuZGVmaW5lZCkge1xuICBcdGhleFNsaWNlID0gdW5jdXJyeVRoaXMocmVxdWlyZSgnLi4vLi4vYnVmZmVyJykuZGVmYXVsdC5CdWZmZXIucHJvdG90eXBlLmhleFNsaWNlKTtcbiAgfVxuICAqL1xuXG4gIGxldCBzdHIgPSBoZXhTbGljZShidWZmZXIsIDAsIE1hdGgubWluKGN0eC5tYXhBcnJheUxlbmd0aCwgYnVmZmVyLmxlbmd0aCkpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpO1xuICBjb25zdCByZW1haW5pbmcgPSBidWZmZXIubGVuZ3RoIC0gY3R4Lm1heEFycmF5TGVuZ3RoO1xuXG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgc3RyICs9IGAgLi4uICR7cmVtYWluaW5nfSBtb3JlIGJ5dGUke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gO1xuICB9XG5cbiAgcmV0dXJuIFtgJHtjdHguc3R5bGl6ZSgnW1VpbnQ4Q29udGVudHNdJywgJ3NwZWNpYWwnKX06IDwke3N0cn0+YF07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBjb25zdCB2YWxMZW4gPSB2YWx1ZS5sZW5ndGg7XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGN0eC5tYXhBcnJheUxlbmd0aCksIHZhbExlbik7XG4gIGNvbnN0IHJlbWFpbmluZyA9IHZhbExlbiAtIGxlbjtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIFNwZWNpYWwgaGFuZGxlIHNwYXJzZSBhcnJheXMuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgaSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRTcGVjaWFsQXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBsZW4sIG91dHB1dCwgaSk7XG4gICAgfVxuXG4gICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBpLCBrQXJyYXlUeXBlKSk7XG4gIH1cblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VHlwZWRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgY3R4Lm1heEFycmF5TGVuZ3RoKSwgdmFsdWUubGVuZ3RoKTtcbiAgY29uc3QgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICBjb25zdCBvdXRwdXQgPSBuZXcgQXJyYXkobWF4TGVuZ3RoKTtcbiAgY29uc3QgZWxlbWVudEZvcm1hdHRlciA9IHZhbHVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyA/IGZvcm1hdE51bWJlciA6IGZvcm1hdEJpZ0ludDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0W2ldID0gZWxlbWVudEZvcm1hdHRlcihjdHguc3R5bGl6ZSwgdmFsdWVbaV0pO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXRbbWF4TGVuZ3RoXSA9IGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWA7XG4gIH1cblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICAvLyAuYnVmZmVyIGdvZXMgbGFzdCwgaXQncyBub3QgYSBwcmltaXRpdmUgbGlrZSB0aGUgb3RoZXJzLlxuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydCWVRFU19QRVJfRUxFTUVOVCcsICdsZW5ndGgnLCAnYnl0ZUxlbmd0aCcsICdieXRlT2Zmc2V0JywgJ2J1ZmZlciddKSB7XG4gICAgICBjb25zdCBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcywgdHJ1ZSk7XG4gICAgICBvdXRwdXQucHVzaChgWyR7a2V5fV06ICR7c3RyfWApO1xuICAgIH1cblxuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2V0KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cbiAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgb3V0cHV0LnB1c2goZm9ybWF0VmFsdWUoY3R4LCB2LCByZWN1cnNlVGltZXMpKTtcbiAgfVxuXG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyOyAvLyBXaXRoIGBzaG93SGlkZGVuYCwgYGxlbmd0aGAgd2lsbCBkaXNwbGF5IGFzIGEgaGlkZGVuIHByb3BlcnR5IGZvclxuICAvLyBhcnJheXMuIEZvciBjb25zaXN0ZW5jeSdzIHNha2UsIGRvIHRoZSBzYW1lIGZvciBgc2l6ZWAsIGV2ZW4gdGhvdWdoIHRoaXNcbiAgLy8gcHJvcGVydHkgaXNuJ3Qgc2VsZWN0ZWQgYnkgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKS5cblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBvdXRwdXQucHVzaChgW3NpemVdOiAke2N0eC5zdHlsaXplKGAke3ZhbHVlLnNpemV9YCwgJ251bWJlcicpfWApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWFwKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cbiAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUpIHtcbiAgICBvdXRwdXQucHVzaChgJHtmb3JtYXRWYWx1ZShjdHgsIGssIHJlY3Vyc2VUaW1lcyl9ID0+ICR7Zm9ybWF0VmFsdWUoY3R4LCB2LCByZWN1cnNlVGltZXMpfWApO1xuICB9XG5cbiAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7IC8vIFNlZSBjb21tZW50IGluIGZvcm1hdFNldFxuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIG91dHB1dC5wdXNoKGBbc2l6ZV06ICR7Y3R4LnN0eWxpemUoYCR7dmFsdWUuc2l6ZX1gLCAnbnVtYmVyJyl9YCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTZXRJdGVySW5uZXIoY3R4LCByZWN1cnNlVGltZXMsIGVudHJpZXMsIHN0YXRlKSB7XG4gIGNvbnN0IG1heEFycmF5TGVuZ3RoID0gTWF0aC5tYXgoY3R4Lm1heEFycmF5TGVuZ3RoLCAwKTtcbiAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5taW4obWF4QXJyYXlMZW5ndGgsIGVudHJpZXMubGVuZ3RoKTtcbiAgbGV0IG91dHB1dCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W2ldID0gZm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW2ldLCByZWN1cnNlVGltZXMpO1xuICB9XG5cbiAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG5cbiAgaWYgKHN0YXRlID09PSBrV2VhayAmJiAhY3R4LnNvcnRlZCkge1xuICAgIC8vIFNvcnQgYWxsIGVudHJpZXMgdG8gaGF2ZSBhIGhhbGZ3YXkgcmVsaWFibGUgb3V0cHV0IChpZiBtb3JlIGVudHJpZXMgdGhhblxuICAgIC8vIHJldHJpZXZlZCBvbmVzIGV4aXN0LCB3ZSBjYW4gbm90IHJlbGlhYmx5IHJldHVybiB0aGUgc2FtZSBvdXRwdXQpIGlmIHRoZVxuICAgIC8vIG91dHB1dCBpcyBub3Qgc29ydGVkIGFueXdheS5cbiAgICBvdXRwdXQgPSBvdXRwdXQuc29ydCgpO1xuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gZW50cmllcy5sZW5ndGggLSBtYXhMZW5ndGg7XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1hcEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywgc3RhdGUpIHtcbiAgY29uc3QgbWF4QXJyYXlMZW5ndGggPSBNYXRoLm1heChjdHgubWF4QXJyYXlMZW5ndGgsIDApOyAvLyBFbnRyaWVzIGV4aXN0IGFzIFtrZXkxLCB2YWwxLCBrZXkyLCB2YWwyLCAuLi5dXG5cbiAgY29uc3QgbGVuID0gZW50cmllcy5sZW5ndGggLyAyO1xuICBjb25zdCByZW1haW5pbmcgPSBsZW4gLSBtYXhBcnJheUxlbmd0aDtcbiAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5taW4obWF4QXJyYXlMZW5ndGgsIGxlbik7XG4gIGxldCBvdXRwdXQgPSBuZXcgQXJyYXkobWF4TGVuZ3RoKTtcbiAgbGV0IGkgPSAwO1xuICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblxuICBpZiAoc3RhdGUgPT09IGtXZWFrKSB7XG4gICAgZm9yICg7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9zID0gaSAqIDI7XG4gICAgICBvdXRwdXRbaV0gPSBgJHtmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zXSwgcmVjdXJzZVRpbWVzKX1gICsgYCA9PiAke2Zvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3MgKyAxXSwgcmVjdXJzZVRpbWVzKX1gO1xuICAgIH0gLy8gU29ydCBhbGwgZW50cmllcyB0byBoYXZlIGEgaGFsZndheSByZWxpYWJsZSBvdXRwdXQgKGlmIG1vcmUgZW50cmllcyB0aGFuXG4gICAgLy8gcmV0cmlldmVkIG9uZXMgZXhpc3QsIHdlIGNhbiBub3QgcmVsaWFibHkgcmV0dXJuIHRoZSBzYW1lIG91dHB1dCkgaWYgdGhlXG4gICAgLy8gb3V0cHV0IGlzIG5vdCBzb3J0ZWQgYW55d2F5LlxuXG5cbiAgICBpZiAoIWN0eC5zb3J0ZWQpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5zb3J0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvcyA9IGkgKiAyO1xuICAgICAgY29uc3QgcmVzID0gW2Zvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3NdLCByZWN1cnNlVGltZXMpLCBmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zICsgMV0sIHJlY3Vyc2VUaW1lcyldO1xuICAgICAgb3V0cHV0W2ldID0gcmVkdWNlVG9TaW5nbGVTdHJpbmcoY3R4LCByZXMsICcnLCBbJ1snLCAnXSddLCBrQXJyYXlFeHRyYXNUeXBlLCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuXG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWFrQ29sbGVjdGlvbihjdHgpIHtcbiAgcmV0dXJuIFtjdHguc3R5bGl6ZSgnPGl0ZW1zIHVua25vd24+JywgJ3NwZWNpYWwnKV07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlYWtTZXQoY3R4LCBfdmFsdWUsIF9yZWN1cnNlVGltZXMpIHtcbiAgLy8gTm9kZSBjYWxscyBpbnRvIG5hdGl2ZSB0byBnZXQgYSBwcmV2aWV3IG9mIGFjdHVhbCB2YWx1ZXMgd2hpY2ggd2UgY2FuJ3QgZG9cbiAgcmV0dXJuIGZvcm1hdFdlYWtDb2xsZWN0aW9uKGN0eCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlYWtNYXAoY3R4LCBfdmFsdWUsIF9yZWN1cnNlVGltZXMpIHtcbiAgLy8gTm9kZSBjYWxscyBpbnRvIG5hdGl2ZSB0byBnZXQgYSBwcmV2aWV3IG9mIGFjdHVhbCB2YWx1ZXMgd2hpY2ggd2UgY2FuJ3QgZG9cbiAgcmV0dXJuIGZvcm1hdFdlYWtDb2xsZWN0aW9uKGN0eCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEl0ZXJhdG9yKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgX2tleXMsIGJyYWNlcykge1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGxldCBpc0tleVZhbHVlID0gZmFsc2U7XG4gIGxldCByZXN1bHQgPSB2YWx1ZS5uZXh0KCk7XG5cbiAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgIGNvbnN0IGN1cnJlbnRFbnRyeSA9IHJlc3VsdC52YWx1ZTtcbiAgICBlbnRyaWVzLnB1c2goY3VycmVudEVudHJ5KTtcblxuICAgIGlmIChjdXJyZW50RW50cnlbMF0gIT09IGN1cnJlbnRFbnRyeVsxXSkge1xuICAgICAgaXNLZXlWYWx1ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gdmFsdWUubmV4dCgpO1xuICB9XG5cbiAgaWYgKGlzS2V5VmFsdWUpIHtcbiAgICAvLyBNYXJrIGVudHJ5IGl0ZXJhdG9ycyBhcyBzdWNoLlxuICAgIGJyYWNlc1swXSA9IGJyYWNlc1swXS5yZXBsYWNlKC8gSXRlcmF0b3JdIHskLywgJyBFbnRyaWVzXSB7Jyk7XG4gICAgcmV0dXJuIGZvcm1hdE1hcEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywga01hcEVudHJpZXMpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFNldEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywga0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gaXNCZWxvd0JyZWFrTGVuZ3RoKGN0eCwgb3V0cHV0LCBzdGFydCwgYmFzZSkge1xuICAvLyBFYWNoIGVudHJ5IGlzIHNlcGFyYXRlZCBieSBhdCBsZWFzdCBhIGNvbW1hLiBUaHVzLCB3ZSBzdGFydCB3aXRoIGEgdG90YWxcbiAgLy8gbGVuZ3RoIG9mIGF0IGxlYXN0IGBvdXRwdXQubGVuZ3RoYC4gSW4gYWRkaXRpb24sIHNvbWUgY2FzZXMgaGF2ZSBhXG4gIC8vIHdoaXRlc3BhY2UgaW4tYmV0d2VlbiBlYWNoIG90aGVyIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRvdGFsIGFzIHdlbGwuXG4gIGxldCB0b3RhbExlbmd0aCA9IG91dHB1dC5sZW5ndGggKyBzdGFydDtcblxuICBpZiAodG90YWxMZW5ndGggKyBvdXRwdXQubGVuZ3RoID4gY3R4LmJyZWFrTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3R4LmNvbG9ycykge1xuICAgICAgdG90YWxMZW5ndGggKz0gcmVtb3ZlQ29sb3JzKG91dHB1dFtpXSkubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBvdXRwdXRbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0b3RhbExlbmd0aCA+IGN0eC5icmVha0xlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBEbyBub3QgbGluZSB1cCBwcm9wZXJ0aWVzIG9uIHRoZSBzYW1lIGxpbmUgaWYgYGJhc2VgIGNvbnRhaW5zIGxpbmUgYnJlYWtzLlxuXG5cbiAgcmV0dXJuIGJhc2UgPT09ICcnIHx8ICFiYXNlLmluY2x1ZGVzKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcoY3R4LCBvdXRwdXQsIGJhc2UsIGJyYWNlcywgZXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzLCB2YWx1ZSkge1xuICBpZiAoY3R4LmNvbXBhY3QgIT09IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIGN0eC5jb21wYWN0ID09PSAnbnVtYmVyJyAmJiBjdHguY29tcGFjdCA+PSAxKSB7XG4gICAgICAvLyBNZW1vcml6ZSB0aGUgb3JpZ2luYWwgb3V0cHV0IGxlbmd0aC4gSW4gY2FzZSB0aGUgdGhlIG91dHB1dCBpcyBncm91cGVkLFxuICAgICAgLy8gcHJldmVudCBsaW5pbmcgdXAgdGhlIGVudHJpZXMgb24gYSBzaW5nbGUgbGluZS5cbiAgICAgIGNvbnN0IGVudHJpZXMgPSBvdXRwdXQubGVuZ3RoOyAvLyBHcm91cCBhcnJheSBlbGVtZW50cyB0b2dldGhlciBpZiB0aGUgYXJyYXkgY29udGFpbnMgYXQgbGVhc3Qgc2l4XG4gICAgICAvLyBzZXBhcmF0ZSBlbnRyaWVzLlxuXG4gICAgICBpZiAoZXh0cmFzVHlwZSA9PT0ga0FycmF5RXh0cmFzVHlwZSAmJiBlbnRyaWVzID4gNikge1xuICAgICAgICBvdXRwdXQgPSBncm91cEFycmF5RWxlbWVudHMoY3R4LCBvdXRwdXQsIHZhbHVlKTtcbiAgICAgIH0gLy8gYGN0eC5jdXJyZW50RGVwdGhgIGlzIHNldCB0byB0aGUgbW9zdCBpbm5lciBkZXB0aCBvZiB0aGUgY3VycmVudGx5XG4gICAgICAvLyBpbnNwZWN0ZWQgb2JqZWN0IHBhcnQgd2hpbGUgYHJlY3Vyc2VUaW1lc2AgaXMgdGhlIGFjdHVhbCBjdXJyZW50IGRlcHRoXG4gICAgICAvLyB0aGF0IGlzIGluc3BlY3RlZC5cbiAgICAgIC8vXG4gICAgICAvLyBFeGFtcGxlOlxuICAgICAgLy9cbiAgICAgIC8vIGNvbnN0IGEgPSB7IGZpcnN0OiBbIDEsIDIsIDMgXSwgc2Vjb25kOiB7IGlubmVyOiBbIDEsIDIsIDMgXSB9IH1cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgZGVlcGVzdCBkZXB0aCBvZiBgYWAgaXMgMiAoYS5zZWNvbmQuaW5uZXIpIGFuZCBgYS5maXJzdGAgaGFzIGEgbWF4XG4gICAgICAvLyBkZXB0aCBvZiAxLlxuICAgICAgLy9cbiAgICAgIC8vIENvbnNvbGlkYXRlIGFsbCBlbnRyaWVzIG9mIHRoZSBsb2NhbCBtb3N0IGlubmVyIGRlcHRoIHVwIHRvXG4gICAgICAvLyBgY3R4LmNvbXBhY3RgLCBhcyBsb25nIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZSBzbWFsbGVyIHRoYW5cbiAgICAgIC8vIGBjdHguYnJlYWtMZW5ndGhgLlxuXG5cbiAgICAgIGlmIChjdHguY3VycmVudERlcHRoIC0gcmVjdXJzZVRpbWVzIDwgY3R4LmNvbXBhY3QgJiYgZW50cmllcyA9PT0gb3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAvLyBMaW5lIHVwIGFsbCBlbnRyaWVzIG9uIGEgc2luZ2xlIGxpbmUgaW4gY2FzZSB0aGUgZW50cmllcyBkbyBub3RcbiAgICAgICAgLy8gZXhjZWVkIGBicmVha0xlbmd0aGAuIEFkZCAxMCBhcyBjb25zdGFudCB0byBzdGFydCBuZXh0IHRvIGFsbCBvdGhlclxuICAgICAgICAvLyBmYWN0b3JzIHRoYXQgbWF5IHJlZHVjZSBgYnJlYWtMZW5ndGhgLlxuICAgICAgICBjb25zdCBzdGFydCA9IG91dHB1dC5sZW5ndGggKyBjdHguaW5kZW50YXRpb25MdmwgKyBicmFjZXNbMF0ubGVuZ3RoICsgYmFzZS5sZW5ndGggKyAxMDtcblxuICAgICAgICBpZiAoaXNCZWxvd0JyZWFrTGVuZ3RoKGN0eCwgb3V0cHV0LCBzdGFydCwgYmFzZSkpIHtcbiAgICAgICAgICByZXR1cm4gYCR7YmFzZSA/IGAke2Jhc2V9IGAgOiAnJ30ke2JyYWNlc1swXX0gJHtqb2luJDEob3V0cHV0LCAnLCAnKX0gJHticmFjZXNbMV19YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gTGluZSB1cCBlYWNoIGVudHJ5IG9uIGFuIGluZGl2aWR1YWwgbGluZS5cblxuXG4gICAgY29uc3QgaW5kZW50YXRpb24gPSBgXFxuJHsnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCl9YDtcbiAgICByZXR1cm4gYCR7YmFzZSA/IGAke2Jhc2V9IGAgOiAnJ30ke2JyYWNlc1swXX0ke2luZGVudGF0aW9ufSAgYCArIGAke2pvaW4kMShvdXRwdXQsIGAsJHtpbmRlbnRhdGlvbn0gIGApfSR7aW5kZW50YXRpb259JHticmFjZXNbMV19YDtcbiAgfSAvLyBMaW5lIHVwIGFsbCBlbnRyaWVzIG9uIGEgc2luZ2xlIGxpbmUgaW4gY2FzZSB0aGUgZW50cmllcyBkbyBub3QgZXhjZWVkXG4gIC8vIGBicmVha0xlbmd0aGAuXG5cblxuICBpZiAoaXNCZWxvd0JyZWFrTGVuZ3RoKGN0eCwgb3V0cHV0LCAwLCBiYXNlKSkge1xuICAgIHJldHVybiBgJHticmFjZXNbMF19JHtiYXNlID8gYCAke2Jhc2V9YCA6ICcnfSAke2pvaW4kMShvdXRwdXQsICcsICcpfSBgICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgY29uc3QgaW5kZW50YXRpb24gPSAnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCk7IC8vIElmIHRoZSBvcGVuaW5nIFwiYnJhY2VcIiBpcyB0b28gbGFyZ2UsIGxpa2UgaW4gdGhlIGNhc2Ugb2YgXCJTZXQge1wiLFxuICAvLyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBmaXJzdCBpdGVtIHRvIGJlIG9uIHRoZSBuZXh0IGxpbmUgb3IgdGhlXG4gIC8vIGl0ZW1zIHdpbGwgbm90IGxpbmUgdXAgY29ycmVjdGx5LlxuXG4gIGNvbnN0IGxuID0gYmFzZSA9PT0gJycgJiYgYnJhY2VzWzBdLmxlbmd0aCA9PT0gMSA/ICcgJyA6IGAke2Jhc2UgPyBgICR7YmFzZX1gIDogJyd9XFxuJHtpbmRlbnRhdGlvbn0gIGA7IC8vIExpbmUgdXAgZWFjaCBlbnRyeSBvbiBhbiBpbmRpdmlkdWFsIGxpbmUuXG5cbiAgcmV0dXJuIGAke2JyYWNlc1swXX0ke2xufSR7am9pbiQxKG91dHB1dCwgYCxcXG4ke2luZGVudGF0aW9ufSAgYCl9ICR7YnJhY2VzWzFdfWA7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdCQxKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGZvcm1hdFdpdGhPcHRpb25zKHVuZGVmaW5lZCwgLi4uYXJncyk7XG59XG5cbmNvbnN0IGZpcnN0RXJyb3JMaW5lID0gZXJyb3IgPT4gZXJyb3IubWVzc2FnZS5zcGxpdCgnXFxuJylbMF07XG5cbmxldCBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFO1xuXG5mdW5jdGlvbiB0cnlTdHJpbmdpZnkoYXJnKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFBvcHVsYXRlIHRoZSBjaXJjdWxhciBlcnJvciBtZXNzYWdlIGxhemlseVxuICAgIGlmICghQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYSA9IHt9O1xuICAgICAgICBhLmEgPSBhO1xuICAgICAgICBKU09OLnN0cmluZ2lmeShhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSA9IGZpcnN0RXJyb3JMaW5lKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnIubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgZmlyc3RFcnJvckxpbmUoZXJyKSA9PT0gQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSkge1xuICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFdpdGhPcHRpb25zKGluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgbGV0IGEgPSAwO1xuICBsZXQgc3RyID0gJyc7XG4gIGxldCBqb2luID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG5cbiAgICBsZXQgdGVtcFN0cjtcbiAgICBsZXQgbGFzdFBvcyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGZpcnN0LmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgIC8vICclJ1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGZpcnN0LmNoYXJDb2RlQXQoKytpKTtcblxuICAgICAgICBpZiAoYSArIDEgIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXh0Q2hhcikge1xuICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgIC8vICdzJ1xuICAgICAgICAgICAgICBjb25zdCB0ZW1wQXJnID0gYXJnc1srK2FdO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCB0ZW1wQXJnKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRlbXBBcmcgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgXHR0ZW1wU3RyID0gYCR7dGVtcEFyZ31uYDtcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjb25zdHI7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBBcmcgIT09ICdvYmplY3QnIHx8IHRlbXBBcmcgPT09IG51bGwgfHwgdHlwZW9mIHRlbXBBcmcudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgKGhhc093blByb3BlcnR5KHRlbXBBcmcsICd0b1N0cmluZycpIC8vIEEgZGlyZWN0IG93biBwcm9wZXJ0eSBvbiB0aGUgY29uc3RydWN0b3IgcHJvdG90eXBlIGluXG4gICAgICAgICAgICAgICAgLy8gY2FzZSB0aGUgY29uc3RydWN0b3IgaXMgbm90IGFuIGJ1aWx0LWluIG9iamVjdC5cbiAgICAgICAgICAgICAgICB8fCAoY29uc3RyID0gdGVtcEFyZy5jb25zdHJ1Y3RvcikgJiYgIWJ1aWx0SW5PYmplY3RzLmhhcyhjb25zdHIubmFtZSkgJiYgY29uc3RyLnByb3RvdHlwZSAmJiBoYXNPd25Qcm9wZXJ0eShjb25zdHIucHJvdG90eXBlLCAndG9TdHJpbmcnKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBTdHJpbmcodGVtcEFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KHRlbXBBcmcsIHsgLi4uaW5zcGVjdE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3Q6IDMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoOiAwXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMDY6XG4gICAgICAgICAgICAgIC8vICdqJ1xuICAgICAgICAgICAgICB0ZW1wU3RyID0gdHJ5U3RyaW5naWZ5KGFyZ3NbKythXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgLy8gJ2QnXG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBOdW0gPSBhcmdzWysrYV07XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcE51bSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgXHR0ZW1wU3RyID0gYCR7dGVtcE51bX1uYDtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wTnVtID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBOdW1iZXIodGVtcE51bSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzk6XG4gICAgICAgICAgICAgIC8vICdPJ1xuICAgICAgICAgICAgICB0ZW1wU3RyID0gaW5zcGVjdChhcmdzWysrYV0sIGluc3BlY3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgICAvLyAnbydcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KGFyZ3NbKythXSwgeyAuLi5pbnNwZWN0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIHNob3dIaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICBzaG93UHJveHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICBkZXB0aDogNFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgICAgICAvLyAnaSdcbiAgICAgICAgICAgICAgY29uc3QgdGVtcEludGVnZXIgPSBhcmdzWysrYV07XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEludGVnZXIgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgIFx0dGVtcFN0ciA9IGAke3RlbXBJbnRlZ2VyfW5gO1xuICAgICAgICAgICAgICB9IGVsc2UgKi9cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBJbnRlZ2VyID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBwYXJzZUludCh0ZW1wSW50ZWdlcikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgICAgICAvLyAnZidcbiAgICAgICAgICAgICAgY29uc3QgdGVtcEZsb2F0ID0gYXJnc1srK2FdO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEZsb2F0ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBwYXJzZUZsb2F0KHRlbXBGbG9hdCkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgIC8vICclJ1xuICAgICAgICAgICAgICBzdHIgKz0gZmlyc3Quc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEFueSBvdGhlciBjaGFyYWN0ZXIgaXMgbm90IGEgY29ycmVjdCBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGFzdFBvcyAhPT0gaSAtIDEpIHtcbiAgICAgICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zLCBpIC0gMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyICs9IHRlbXBTdHI7XG4gICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID09PSAzNykge1xuICAgICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFzdFBvcyAhPT0gMCkge1xuICAgICAgYSsrO1xuICAgICAgam9pbiA9ICcgJztcblxuICAgICAgaWYgKGxhc3RQb3MgPCBmaXJzdC5sZW5ndGgpIHtcbiAgICAgICAgc3RyICs9IGZpcnN0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChhIDwgYXJncy5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbYV07XG4gICAgc3RyICs9IGpvaW47XG4gICAgc3RyICs9IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgPyBpbnNwZWN0KHZhbHVlLCBpbnNwZWN0T3B0aW9ucykgOiB2YWx1ZTtcbiAgICBqb2luID0gJyAnO1xuICAgIGErKztcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1kZXB0aCAqL1xuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuXG5mdW5jdGlvbiBsb2dUaW1lKHNlbGYsIGxhYmVsLCBsb2dEYXRhKSB7XG4gIGxhYmVsID0gYCR7bGFiZWx9YDtcblxuICBjb25zdCBzdGFydFRpbWUgPSBzZWxmLl90aW1lcy5nZXQobGFiZWwpO1xuXG4gIGlmICghc3RhcnRUaW1lKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgTGFiZWwgXCIke2xhYmVsfVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgaWYgKGxvZ0RhdGEpIHtcbiAgICBzZWxmLmxvZyhgJHtsYWJlbH06ICR7ZHVyYXRpb259bXNgLCAuLi5sb2dEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmxvZyhgJHtsYWJlbH06ICR7ZHVyYXRpb259bXNgKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3Qga0NvbG9ySW5zcGVjdE9wdGlvbnMgPSB7XG4gIGNvbG9yczogdHJ1ZVxufTtcbmNvbnN0IGtOb0NvbG9ySW5zcGVjdE9wdGlvbnMgPSB7fTtcbmxldCB0YWJsZVdhcm5lZDsgLy8gYm9vbGVhbiBmbGFnIGZvciBvbmUtdGltZSB3YXJuaW5nIGFib3V0IGNvbnNvbGUudGFibGUgbm90IGJlaW5nIGltcGxlbWVudGVkXG4vLyBNYWtlIGEgZnVuY3Rpb24gdGhhdCBjYW4gc2VydmUgYXMgdGhlIGNhbGxiYWNrIHBhc3NlZCB0byBgc3RyZWFtLndyaXRlKClgLlxuXG5mdW5jdGlvbiBjcmVhdGVXcml0ZUVycm9ySGFuZGxlcihzdHJlYW0pIHtcbiAgcmV0dXJuIGVyciA9PiB7XG4gICAgLy8gVGhpcyBjb25kaXRpb25hbCBldmFsdWF0ZXMgdG8gdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAvLyB0aGF0IHdhcyBub3QgYWxyZWFkeSBlbWl0dGVkICh3aGljaCBoYXBwZW5zIHdoZW4gdGhlIF93cml0ZSBjYWxsYmFja1xuICAgIC8vIGlzIGludm9rZWQgYXN5bmNocm9ub3VzbHkpLlxuICAgIGlmIChlcnIgIT09IG51bGwgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgaXQgd2lsbCBiZSBlbWl0dGVkIG9uIGBzdHJlYW1gIGFzXG4gICAgICAvLyBhbiBgZXJyb3JgIGV2ZW50LiBBZGRpbmcgYSBgb25jZWAgbGlzdGVuZXIgd2lsbCBrZWVwIHRoYXQgZXJyb3JcbiAgICAgIC8vIGZyb20gYmVjb21pbmcgYW4gdW5jYXVnaHQgZXhjZXB0aW9uLCBidXQgc2luY2UgdGhlIGhhbmRsZXIgaXNcbiAgICAgIC8vIHJlbW92ZWQgYWZ0ZXIgdGhlIGV2ZW50LCBub24tY29uc29sZS4qIHdyaXRlcyB3b24ndCBiZSBhZmZlY3RlZC5cbiAgICAgIC8vIHdlIGFyZSBvbmx5IGFkZGluZyBub29wIGlmIHRoZXJlIGlzIG5vIG9uZSBlbHNlIGxpc3RlbmluZyBmb3IgJ2Vycm9yJ1xuICAgICAgaWYgKHN0cmVhbS5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIG5vb3AkMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5jbGFzcyBDb25zb2xlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgc3RkZXJyLCBpZ25vcmVFcnJvcnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFwaU5hbWUgPT09ICdUaS5BUEknKSB7XG4gICAgICAvLyBQYXNzaW5nIGluIFRpLkFQSSBtb2R1bGUgd2hlcmUgd2UgcmV0YWluIGxvZyBsZXZlbHNcbiAgICAgIHRoaXMuX2FwaU1vZHVsZSA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vZGUuSlMgc3RyZWFtc1xuICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vIGFyZ3MsIG9yIGZpcnN0IGFyZyBpcyBhIHN0cmVhbVxuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIHN0ZG91dDogb3B0aW9ucyxcbiAgICAgICAgICBzdGRlcnIsXG4gICAgICAgICAgaWdub3JlRXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0ZG91dCA9IG9wdGlvbnMuc3Rkb3V0OyAvLyBUT0RPOiBlbmZvcmNlIGhhcyB3cml0ZSBmdW5jdGlvbj9cblxuICAgICAgdGhpcy5fc3RkZXJyID0gb3B0aW9ucy5zdGRlcnIgfHwgdGhpcy5fc3Rkb3V0O1xuICAgICAgdGhpcy5faWdub3JlRXJyb3JzID0gb3B0aW9ucy5pZ25vcmVFcnJvcnMgIT09IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5faWdub3JlRXJyb3JzKSB7XG4gICAgICAgIHRoaXMuX3N0ZG91dEVycm9ySGFuZGxlciA9IGNyZWF0ZVdyaXRlRXJyb3JIYW5kbGVyKHRoaXMuX3N0ZG91dCk7XG4gICAgICAgIHRoaXMuX3N0ZGVyckVycm9ySGFuZGxlciA9IGNyZWF0ZVdyaXRlRXJyb3JIYW5kbGVyKHRoaXMuX3N0ZGVycik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbG9yTW9kZSA9IG9wdGlvbnMuY29sb3JNb2RlIHx8ICdhdXRvJzsgLy8gVE9ETzogZW5mb3JjZSBib29sZWFuIG9yICdhdXRvJ1xuXG4gICAgICB0aGlzLl9pbnNwZWN0T3B0aW9ucyA9IG9wdGlvbnMuaW5zcGVjdE9wdGlvbnM7IC8vIFRPRE86IGVuZm9yY2UgdW5kZWZpbmVkIG9yIHR5cGVvZiAnb2JqZWN0J1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NvdW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ncm91cEluZGVudCA9ICcnO1xuICB9XG5cbiAgX3dyaXRlVG9Db25zb2xlKGxldmVsLCBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5fZ3JvdXBJbmRlbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAoc3RyaW5nLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFxuL2csIGBcXG4ke3RoaXMuX2dyb3VwSW5kZW50fWApO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSB0aGlzLl9ncm91cEluZGVudCArIHN0cmluZztcbiAgICB9IC8vIFN1cHBvcnQgd3JhcHBpbmcgVGkuQVBJICh3aGljaCByZXRhaW5zIGxvZyBsZXZlbClcblxuXG4gICAgaWYgKHRoaXMuX2FwaU1vZHVsZSkge1xuICAgICAgdGhpcy5fYXBpTW9kdWxlW2xldmVsXShzdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXBwb3J0IE5vZGUuSlMgc3RyZWFtcyBsaWtlIHN0ZG91dC9zdGRlcnIgd2hpY2ggZG9uJ3QgaGF2ZSBsb2cgbGV2ZWxzXG4gICAgICBjb25zdCB1c2VTdGRFcnIgPSBsZXZlbCA9PT0gJ3dhcm4nIHx8IGxldmVsID09PSAnZXJyb3InIHx8IGxldmVsID09PSAndHJhY2UnO1xuICAgICAgY29uc3Qgc3RyZWFtID0gdXNlU3RkRXJyID8gdGhpcy5fc3RkZXJyIDogdGhpcy5fc3Rkb3V0O1xuXG4gICAgICBpZiAodGhpcy5faWdub3JlRXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLndyaXRlKHN0cmluZyk7XG4gICAgICB9IC8vIFRoZXJlIG1heSBiZSBhbiBlcnJvciBvY2N1cnJpbmcgc3luY2hyb25vdXNseSAoZS5nLiBmb3IgZmlsZXMgb3IgVFRZc1xuICAgICAgLy8gb24gUE9TSVggc3lzdGVtcykgb3IgYXN5bmNocm9ub3VzbHkgKGUuZy4gcGlwZXMgb24gUE9TSVggc3lzdGVtcyksIHNvXG4gICAgICAvLyBoYW5kbGUgYm90aCBzaXR1YXRpb25zLlxuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEFkZCBhbmQgbGF0ZXIgcmVtb3ZlIGEgbm9vcCBlcnJvciBoYW5kbGVyIHRvIGNhdGNoIHN5bmNocm9ub3VzIGVycm9ycy5cbiAgICAgICAgaWYgKHN0cmVhbS5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICAgICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgbm9vcCQxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IHVzZVN0ZEVyciA/IHRoaXMuX3N0ZGVyckVycm9ySGFuZGxlciA6IHRoaXMuX3N0ZG91dEVycm9ySGFuZGxlcjtcbiAgICAgICAgc3RyZWFtLndyaXRlKHN0cmluZywgZXJyb3JIYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ29uc29sZSBpcyBhIGRlYnVnZ2luZyB1dGlsaXR5LCBzbyBpdCBzd2FsbG93aW5nIGVycm9ycyBpcyBub3QgZGVzaXJhYmxlXG4gICAgICAgIC8vIGV2ZW4gaW4gZWRnZSBjYXNlcyBzdWNoIGFzIGxvdyBzdGFjayBzcGFjZS5cbiAgICAgICAgaWYgKGlzU3RhY2tPdmVyZmxvd0Vycm9yKGUpKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSAvLyBTb3JyeSwgdGhlcmUncyBubyBwcm9wZXIgd2F5IHRvIHBhc3MgYWxvbmcgdGhlIGVycm9yIGhlcmUuXG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lciAmJiBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgbm9vcCQxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbmZvKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnaW5mbycsIGZvcm1hdFdpdGhPcHRpb25zKGtDb2xvckluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSk7XG4gIH1cblxuICB3YXJuKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnd2FybicsIGZvcm1hdFdpdGhPcHRpb25zKGtOb0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbiAgfVxuXG4gIGVycm9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnZXJyb3InLCBmb3JtYXRXaXRoT3B0aW9ucyhrTm9Db2xvckluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSk7XG4gIH1cblxuICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ2RlYnVnJywgZm9ybWF0V2l0aE9wdGlvbnMoa0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbiAgfVxuXG4gIHRyYWNlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgndHJhY2UnLCBmb3JtYXRXaXRoT3B0aW9ucyhrQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG5cbiAgY2xlYXIoKSB7fSAvLyBuby1vcFxuXG5cbiAgZ3JvdXAoLi4uZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMubG9nKC4uLmRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2dyb3VwSW5kZW50ICs9ICcgICc7XG4gIH1cblxuICBncm91cEVuZCgpIHtcbiAgICB0aGlzLl9ncm91cEluZGVudCA9IHRoaXMuX2dyb3VwSW5kZW50LnNsaWNlKDAsIHRoaXMuX2dyb3VwSW5kZW50Lmxlbmd0aCAtIDIpO1xuICB9XG5cbiAgZGlyKG9iaiwgb3B0aW9ucykge1xuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCdpbmZvJywgaW5zcGVjdChvYmosIHtcbiAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pKTtcbiAgfVxuXG4gIGFzc2VydCh2YWx1ZSwgLi4uYXJncykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGFyZ3NbMF0gPSBgQXNzZXJ0aW9uIGZhaWxlZCR7YXJncy5sZW5ndGggPT09IDAgPyAnJyA6IGA6ICR7YXJnc1swXX1gfWA7XG4gICAgICB0aGlzLndhcm4oLi4uYXJncyk7IC8vIFRoZSBhcmd1bWVudHMgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gd2FybigpIGFnYWluXG4gICAgfVxuICB9XG5cbiAgY291bnQobGFiZWwgPSAnZGVmYXVsdCcpIHtcbiAgICAvLyBFbnN1cmVzIHRoYXQgbGFiZWwgaXMgYSBzdHJpbmcsIGFuZCBvbmx5IHRoaW5ncyB0aGF0IGNhbiBiZVxuICAgIC8vIGNvZXJjZWQgdG8gc3RyaW5ncy4gZS5nLiBTeW1ib2wgaXMgbm90IGFsbG93ZWRcbiAgICBsYWJlbCA9IGAke2xhYmVsfWA7XG5cbiAgICBsZXQgY291bnQgPSB0aGlzLl9jb3VudHMuZ2V0KGxhYmVsKTtcblxuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuXG4gICAgdGhpcy5fY291bnRzLnNldChsYWJlbCwgY291bnQpO1xuXG4gICAgdGhpcy5sb2coYCR7bGFiZWx9OiAke2NvdW50fWApO1xuICB9XG5cbiAgY291bnRSZXNldChsYWJlbCA9ICdkZWZhdWx0Jykge1xuICAgIGlmICghdGhpcy5fY291bnRzLmhhcyhsYWJlbCkpIHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoYENvdW50IGZvciAnJHtsYWJlbH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY291bnRzLmRlbGV0ZShgJHtsYWJlbH1gKTtcbiAgfVxuXG4gIHRpbWUobGFiZWwgPSAnZGVmYXVsdCcpIHtcbiAgICBsYWJlbCA9IGAke2xhYmVsfWA7XG5cbiAgICBpZiAodGhpcy5fdGltZXMuaGFzKGxhYmVsKSkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgTGFiZWwgJHtsYWJlbH1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWVzLnNldChsYWJlbCwgRGF0ZS5ub3coKSk7XG4gIH1cblxuICB0aW1lRW5kKGxhYmVsID0gJ2RlZmF1bHQnKSB7XG4gICAgY29uc3Qgd2FybmVkID0gbG9nVGltZSh0aGlzLCBsYWJlbCk7XG5cbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgdGhpcy5fdGltZXMuZGVsZXRlKGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICB0aW1lTG9nKGxhYmVsID0gJ2RlZmF1bHQnLCAuLi5sb2dEYXRhKSB7XG4gICAgbG9nVGltZSh0aGlzLCBsYWJlbCwgbG9nRGF0YSk7XG4gIH0gLy8gVE9ETzogaW1wbGVtZW50IGNvbnNvbGUudGFibGUoKVxuXG5cbiAgdGFibGUoKSB7XG4gICAgaWYgKCF0YWJsZVdhcm5lZCkge1xuICAgICAgdGFibGVXYXJuZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnXCJjb25zb2xlLnRhYmxlXCIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBUaXRhbml1bSEnKTtcbiAgICB9XG4gIH1cblxufVxuXG5Db25zb2xlLnByb3RvdHlwZS5sb2cgPSBDb25zb2xlLnByb3RvdHlwZS5pbmZvOyAvLyBUcmVhdCBsb2cgYXMgYWxpYXMgdG8gaW5mb1xuXG5Db25zb2xlLnByb3RvdHlwZS5kaXJ4bWwgPSBDb25zb2xlLnByb3RvdHlwZS5sb2c7IC8vIFRyZWF0IGRpcnhtbCBhcyBhbGlhcyB0byBsb2dcblxuQ29uc29sZS5wcm90b3R5cGUuZ3JvdXBDb2xsYXBzZWQgPSBDb25zb2xlLnByb3RvdHlwZS5ncm91cDtcbmNvbnN0IGdsb2JhbENvbnNvbGUgPSBuZXcgQ29uc29sZShUaS5BUEkpO1xuZ2xvYmFsQ29uc29sZS5Db25zb2xlID0gQ29uc29sZTtcbmdsb2JhbC5jb25zb2xlID0gZ2xvYmFsQ29uc29sZTtcblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIERhdGUucHJvdG90eXBlLnRvTG9jYWxlRGF0ZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gSW50bC5EYXRlVGltZUZvcm1hdC5fbWFrZVRpQ3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmd1bWVudHMpO1xuXG4gICAgY29uc3Qgb2xkT3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucztcblxuICAgIGlmICghb2xkT3B0aW9ucyB8fCAhb2xkT3B0aW9ucy5kYXRlU3R5bGUgJiYgIW9sZE9wdGlvbnMubW9udGggJiYgIW9sZE9wdGlvbnMuZGF5ICYmICFvbGRPcHRpb25zLnllYXIpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgeWVhcjogJ251bWVyaWMnXG4gICAgICB9O1xuICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb2xkT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQocHJvcGVydGllcy5sb2NhbGUsIHByb3BlcnRpZXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgRGF0ZS5wcm90b3R5cGUudG9Mb2NhbGVUaW1lU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBJbnRsLkRhdGVUaW1lRm9ybWF0Ll9tYWtlVGlDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCBvbGRPcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zO1xuXG4gICAgaWYgKCFvbGRPcHRpb25zIHx8ICFvbGRPcHRpb25zLnRpbWVTdHlsZSAmJiAhb2xkT3B0aW9ucy5ob3VyICYmICFvbGRPcHRpb25zLm1pbnV0ZSAmJiAhb2xkT3B0aW9ucy5zZWNvbmQpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgfTtcbiAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9sZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHByb3BlcnRpZXMubG9jYWxlLCBwcm9wZXJ0aWVzLm9wdGlvbnMpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuXG4gIERhdGUucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBJbnRsLkRhdGVUaW1lRm9ybWF0Ll9tYWtlVGlDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCBvbGRPcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zO1xuICAgIGxldCBoYXNPcHRpb24gPSBmYWxzZTtcblxuICAgIGlmIChvbGRPcHRpb25zKSB7XG4gICAgICBoYXNPcHRpb24gPSAhIW9sZE9wdGlvbnMuZGF0ZVN0eWxlIHx8ICEhb2xkT3B0aW9ucy50aW1lU3R5bGUgfHwgISFvbGRPcHRpb25zLndlZWtkYXkgfHwgISFvbGRPcHRpb25zLm1vbnRoIHx8ICEhb2xkT3B0aW9ucy5kYXkgfHwgISFvbGRPcHRpb25zLnllYXIgfHwgISFvbGRPcHRpb25zLmhvdXIgfHwgISFvbGRPcHRpb25zLm1pbnV0ZSB8fCAhIW9sZE9wdGlvbnMuc2Vjb25kO1xuICAgIH1cblxuICAgIGlmICghaGFzT3B0aW9uKSB7XG4gICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgbW9udGg6ICdudW1lcmljJyxcbiAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICAgICAgc2Vjb25kOiAnbnVtZXJpYydcbiAgICAgIH07XG4gICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvbGRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChwcm9wZXJ0aWVzLmxvY2FsZSwgcHJvcGVydGllcy5vcHRpb25zKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbi8vIEFkZCBhIHRvSlNPTigpIG1ldGhvZCB0byBhbGwgRXJyb3Igb2JqZWN0cyBuZWVkZWQgdG8gb3V0cHV0IG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4vLyBUaGUgSlNPTi5zdHJpbmdpZnkoKSB3aWxsIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGlzIG1ldGhvZCBpZiBpdCBleGlzdHMgdG8gcHJvdmlkZSBjdXN0b20gb3V0cHV0LlxuLy8gTm90ZXM6XG4vLyAtIEluIFY4LCBhbGwgRXJyb3IgcHJvcGVydGllcyBhcmUgbm90IGVudW1lcmFibGUuIFdlIG5lZWQgdGhpcyBvciBlbHNlIHN0cmluZ2lmeSgpIHdpbGwgcmV0dXJuIFwie31cIi5cbi8vIC0gSW4gSmF2YVNjcmlwdENvcmUsIG9ubHkgdGhlIFwic3RhY2tcIiBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZS4gV2Ugd2FudCB0byByZXZlYWwgdGhpcy5cbmlmICh0eXBlb2YgRXJyb3IucHJvdG90eXBlLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJykge1xuICBFcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcHJvcGVydGllc1tuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH07XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDIwIGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBcImNyZWF0aW9uXCIgcHJvcGVydGllcyBkaWN0aW9uYXJ5IGZvciBUaXRhbml1bSdzIENvbGxhdG9yLCBEYXRlVGltZUZvcm1hdCwgYW5kIE51bWJlckZvcm1hdCBwcm94aWVzXG4gKiBmcm9tIHRoZSBnaXZlbiBJbnRsIHR5cGUncyBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge09iamVjdFtdfSBhcmdzXG4gKiBUaGUgYXJndW1lbnRzIGFycmF5IHRoYXQgd2FzIHBhc3NlZCBpbnRvIEludGwgQ29sbGF0b3IsIERhdGVUaW1lRm9ybWF0LCBvciBOdW1iZXJGb3JtYXQgdHlwZSdzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uIFJlZmVyZW5jZSB0byBhIHN1cHBvcnRlZExvY2FsZXNPZigpIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgcHJvcGVydGllcyBkaWN0aW9uYXJ5IHRvIGJlIHBhc3NlZCBpbnRvIGEgVGl0YW5pdW0gcHJveHkncyBjb25zdHJ1Y3Rvci5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3MsIHN1cHBvcnRlZEZvcm1hdExvY2FsZXNGdW5jdGlvbikge1xuICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID49IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm9wZXJ0aWVzLmxvY2FsZSA9IGFyZ3NbMF07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBjb25zdCBzdXBwb3J0ZWRMb2NhbGVzID0gc3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAoc3VwcG9ydGVkTG9jYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMubG9jYWxlID0gc3VwcG9ydGVkTG9jYWxlc1swXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPj0gMiAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBhcmdzWzFdO1xuICB9XG5cbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59IC8vIEFkZCBcIkludGxcIiBBUElzIG1pc3Npbmcgb24gQW5kcm9pZC5cblxuXG57XG4gIC8vIFNldCB1cCBhbiBcIkludGwuQ29sbGF0b3JcIiB0eXBlIHdoaWNoIHdyYXBzIG91ciB1bmRvY3VtZW50ZWQgXCJUaS5Mb2NhbGUuQ29sbGF0b3JcIiBwcm94eS5cbiAgZnVuY3Rpb24gVGlDb2xsYXRvcigpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gbWFrZVRpRm9ybWF0Q3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmd1bWVudHMsIFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWRDb2xsYXRvckxvY2FsZXMpO1xuICAgIGNvbnN0IGNvbGxhdG9yID0gbmV3IFRpLkxvY2FsZS5Db2xsYXRvcihwcm9wZXJ0aWVzKTtcbiAgICBjb2xsYXRvci5jb21wYXJlID0gY29sbGF0b3IuY29tcGFyZS5iaW5kKGNvbGxhdG9yKTtcbiAgICByZXR1cm4gY29sbGF0b3I7XG4gIH1cblxuICBUaUNvbGxhdG9yLnN1cHBvcnRlZExvY2FsZXNPZiA9IFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWRDb2xsYXRvckxvY2FsZXM7IC8vIFNldCB1cCBhbiBcIkludGwuRGF0ZVRpbWVGb3JtYXRcIiB0eXBlIHdoaWNoIHdyYXBzIG91ciB1bmRvY3VtZW50ZWQgXCJUaS5Mb2NhbGUuRGF0ZVRpbWVGb3JtYXRcIiBwcm94eS5cblxuICBmdW5jdGlvbiBUaURhdGVUaW1lRm9ybWF0KCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3VtZW50cywgVGkuTG9jYWxlLmdldFN1cHBvcnRlZERhdGVUaW1lRm9ybWF0TG9jYWxlcyk7XG4gICAgcmV0dXJuIG5ldyBUaS5Mb2NhbGUuRGF0ZVRpbWVGb3JtYXQocHJvcGVydGllcyk7XG4gIH1cblxuICBUaURhdGVUaW1lRm9ybWF0Ll9tYWtlVGlDcmVhdGlvblByb3BlcnRpZXNGcm9tID0gYXJncyA9PiB7XG4gICAgcmV0dXJuIG1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJncywgVGkuTG9jYWxlLmdldFN1cHBvcnRlZERhdGVUaW1lRm9ybWF0TG9jYWxlcyk7XG4gIH07XG5cbiAgVGlEYXRlVGltZUZvcm1hdC5zdXBwb3J0ZWRMb2NhbGVzT2YgPSBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkRGF0ZVRpbWVGb3JtYXRMb2NhbGVzOyAvLyBTZXQgdXAgYW4gXCJJbnRsLk51bWJlckZvcm1hdFwiIHR5cGUgd2hpY2ggd3JhcHMgb3VyIHVuZG9jdW1lbnRlZCBcIlRpLkxvY2FsZS5OdW1iZXJGb3JtYXRcIiBwcm94eS5cblxuICBmdW5jdGlvbiBUaU51bWJlckZvcm1hdCgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gbWFrZVRpRm9ybWF0Q3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmd1bWVudHMsIFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWROdW1iZXJGb3JtYXRMb2NhbGVzKTtcbiAgICByZXR1cm4gbmV3IFRpLkxvY2FsZS5OdW1iZXJGb3JtYXQocHJvcGVydGllcyk7XG4gIH1cblxuICBUaU51bWJlckZvcm1hdC5zdXBwb3J0ZWRMb2NhbGVzT2YgPSBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkTnVtYmVyRm9ybWF0TG9jYWxlczsgLy8gTWFrZSBvdXIgY3VzdG9tIFwiSW50bFwiIG1vZHVsZSBhdmFpbGFibGUgZ2xvYmFsbHkuXG5cbiAgY29tbW9uanNHbG9iYWwuSW50bCA9IHtcbiAgICBDb2xsYXRvcjogVGlDb2xsYXRvcixcbiAgICBEYXRlVGltZUZvcm1hdDogVGlEYXRlVGltZUZvcm1hdCxcbiAgICBOdW1iZXJGb3JtYXQ6IFRpTnVtYmVyRm9ybWF0LFxuICAgIGdldENhbm9uaWNhbExvY2FsZXM6IFRpLkxvY2FsZS5nZXRDYW5vbmljYWxMb2NhbGVzXG4gIH07XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDIwIGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICBOdW1iZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCguLi5hcmd1bWVudHMpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMudmFsdWVPZigpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIFN0cmluZy5wcm90b3R5cGUubG9jYWxlQ29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlU3RyaW5nLCBsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcihsb2NhbGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29sbGF0b3IuY29tcGFyZSh0aGlzLCBjb21wYXJlU3RyaW5nKTtcbiAgfTtcblxuICBTdHJpbmcucHJvdG90eXBlLnRvTG9jYWxlTG93ZXJDYXNlID0gZnVuY3Rpb24gKGxvY2FsZSkge1xuICAgIHJldHVybiBUaS5Mb2NhbGUubWFrZUxvd2VyQ2FzZSh0aGlzLCBsb2NhbGUpO1xuICB9O1xuXG4gIFN0cmluZy5wcm90b3R5cGUudG9Mb2NhbGVVcHBlckNhc2UgPSBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgcmV0dXJuIFRpLkxvY2FsZS5tYWtlVXBwZXJDYXNlKHRoaXMsIGxvY2FsZSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgdG8gaGlqYWNrIHRoZSBzdGFuZGFyZCByZXF1aXJlIHRvIGFsbG93IGZvciBKU1xuICogaW1wbGVtZW50YXRpb25zIG9mIFwiY29yZVwiIG1vZHVsZXMuXG4gKlxuICogWW91IGFkZCBhIGJpbmRpbmcgZnJvbSB0aGUgXCJjb3JlXCIgbW9kdWxlIGlkIHRvIHRoZSB1bmRlciB0aGUgaG9vZCBKU1xuICogaW1wbGVtZW50YXRpb24uIFdlIHRoZW4gaW50ZXJjZXB0IHJlcXVpcmUgY2FsbHMgdG8gaGFuZGxlIHJlcXVlc3RzIGZvciB0aGVzZSBtb2R1bGVzXG4gKiBhbmQgbGF6aWx5IGxvYWQgdGhlIGZpbGUuXG4gKi9cblxuLyoqXG4gKiBVc2VkIGJ5IEBmdW5jdGlvbiBiaW5kT2JqZWN0VG9Db3JlTW9kdWxlSWRcbiAqIEB0eXBlIHttYXA8c3RyaW5nLCBvYmplY3Q+fVxuICovXG5jb25zdCBiaW5kaW5ncyA9IG5ldyBNYXAoKTtcbi8qKlxuICogVXNlZCBieSBAZnVuY3Rpb24gcmVkaXJlY3RDb3JlTW9kdWxlSWRUb1BhdGhcbiAqIEB0eXBlIHttYXA8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5cbmNvbnN0IHJlZGlyZWN0cyA9IG5ldyBNYXAoKTtcbi8qKlxuICogRG9lcyB0aGUgcmVxdWVzdCBsb29rIGxpa2UgYSB0eXBpY2FsIGNvcmUgbW9kdWxlPyAobm8gJy4nIG9yICcvJyBjaGFyYWN0ZXJzKVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggb3JpZ2luYWwgcmVxdWlyZSBwYXRoL2lkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0hpamFja2FibGVNb2R1bGVJZChwYXRoKSB7XG4gIGlmICghcGF0aCB8fCBwYXRoLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmaXJzdENoYXIgPSBwYXRoLmNoYXJBdCgwKTtcbiAgcmV0dXJuIGZpcnN0Q2hhciAhPT0gJy4nICYmIGZpcnN0Q2hhciAhPT0gJy8nO1xufSAvLyBIYWNrIHJlcXVpcmUgdG8gcG9pbnQgdG8gdGhpcyBhcyBhIGNvcmUgbW9kdWxlIFwiYmluZGluZ1wiXG5cblxuY29uc3Qgb3JpZ2luYWxSZXF1aXJlID0gZ2xvYmFsLnJlcXVpcmU7IC8vIFRoaXMgd29ya3MgZm9yIFdpbmRvd3MgYXMtaXMsIGFuZCBhbHNvIGludGVyY2VwdHMgdGhlIGNhbGwgb24gQW5kcm9pZC9pT1MgZm9yIHRpLm1haW4uanMgKHRoZSBmaXJzdCBmaWxlIGV4ZWN1dGVkKVxuXG5nbG9iYWwucmVxdWlyZSA9IGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICBpZiAoYmluZGluZ3MuaGFzKG1vZHVsZUlkKSkge1xuICAgIHJldHVybiBiaW5kaW5ncy5nZXQobW9kdWxlSWQpO1xuICB9XG5cbiAgaWYgKHJlZGlyZWN0cy5oYXMobW9kdWxlSWQpKSB7XG4gICAgbW9kdWxlSWQgPSByZWRpcmVjdHMuZ2V0KG1vZHVsZUlkKTtcbiAgfVxuXG4gIHJldHVybiBvcmlnaW5hbFJlcXVpcmUobW9kdWxlSWQpO1xufTsgLy8gLi4uIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGhhY2sgaXQgd2hlbiByZXF1aXJpbmcgZnJvbSBvdGhlciBmaWxlcyBmb3IgQW5kcm9pZC9pT1MgKGR1ZSB0byBtb2R1bGUuanMgaW1wbClcblxuXG5jb25zdCBvcmlnaW5hbE1vZHVsZVJlcXVpcmUgPSBnbG9iYWwuTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlO1xuXG5nbG9iYWwuTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gZnVuY3Rpb24gKHBhdGgsIGNvbnRleHQpIHtcbiAgaWYgKGJpbmRpbmdzLmhhcyhwYXRoKSkge1xuICAgIHJldHVybiBiaW5kaW5ncy5nZXQocGF0aCk7XG4gIH1cblxuICBpZiAocmVkaXJlY3RzLmhhcyhwYXRoKSkge1xuICAgIHBhdGggPSByZWRpcmVjdHMuZ2V0KHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIG9yaWdpbmFsTW9kdWxlUmVxdWlyZS5jYWxsKHRoaXMsIHBhdGgsIGNvbnRleHQpO1xufTtcbi8qKlxuICogUmVnaXN0ZXJzIGEgYmluZGluZyBmcm9tIGEgc2hvcnQgbW9kdWxlIGlkIHRvIGFuIGFscmVhZHkgbG9hZGVkL2NvbnN0cnVjdGVkIG9iamVjdC92YWx1ZSB0byBleHBvcnQgZm9yIHRoYXQgY29yZSBtb2R1bGUgaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgdGhlIG1vZHVsZSBpZCB0byBcImhpamFja1wiXG4gKiBAcGFyYW0geyp9IGJpbmRpbmcgYW4gYWxyZWFkeSBjb25zdHJ1Y3R1cmVkIHZhbHVlL29iamVjdCB0byByZXR1cm5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKG1vZHVsZUlkLCBiaW5kaW5nKSB7XG4gIGlmICghaXNIaWphY2thYmxlTW9kdWxlSWQobW9kdWxlSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVnaXN0ZXIgZm9yIHJlbGF0aXZlL2Fic29sdXRlIGZpbGUgcGF0aHM7IG5vIGxlYWRpbmcgJy4nIG9yICcvJyBhbGxvd2VkICh3YXMgZ2l2ZW4gJHttb2R1bGVJZH0pYCk7XG4gIH1cblxuICBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICAgIHJlZGlyZWN0cy5kZWxldGUobW9kdWxlSWQpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICB9XG5cbiAgYmluZGluZ3Muc2V0KG1vZHVsZUlkLCBiaW5kaW5nKTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgYmluZGluZyBmcm9tIGEgc2hvcnQgbW9kdWxlIGlkIHRvIHRoZSBmdWxsIHVuZGVyIHRoZSBob29kIGZpbGVwYXRoIGlmIGdpdmVuIGEgc3RyaW5nLlxuICogVGhpcyBhbGxvd3MgZm9yIGxhenkgaW5zdGFudGlhdGlvbiBvZiB0aGUgbW9kdWxlIG9uLWRlbWFuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCB0aGUgbW9kdWxlIGlkIHRvIFwiaGlqYWNrXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCB0aGUgZnVsbCBmaWxlcGF0aCB0byByZXF1aXJlIHVuZGVyIHRoZSBob29kLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIHNob3VsZCBiZSBhbiBhbHJlYWR5IHJlc29sdmVkIGFic29sdXRlIHBhdGgsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIG90aGVyd2lzZSB0aGUgY29udGV4dCBvZiB0aGUgY2FsbCBjb3VsZCBjaGFuZ2Ugd2hhdCBnZXRzIGxvYWRlZCFcbiAqL1xuXG5mdW5jdGlvbiByZWRpcmVjdChtb2R1bGVJZCwgZmlsZXBhdGgpIHtcbiAgaWYgKCFpc0hpamFja2FibGVNb2R1bGVJZChtb2R1bGVJZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWdpc3RlciBmb3IgcmVsYXRpdmUvYWJzb2x1dGUgZmlsZSBwYXRoczsgbm8gbGVhZGluZyAnLicgb3IgJy8nIGFsbG93ZWQgKHdhcyBnaXZlbiAke21vZHVsZUlkfSlgKTtcbiAgfVxuXG4gIGlmIChiaW5kaW5ncy5oYXMobW9kdWxlSWQpKSB7XG4gICAgVGkuQVBJLndhcm4oYEFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICcke21vZHVsZUlkfScsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uLi5gKTtcbiAgICBiaW5kaW5ncy5kZWxldGUobW9kdWxlSWQpO1xuICB9IGVsc2UgaWYgKHJlZGlyZWN0cy5oYXMobW9kdWxlSWQpKSB7XG4gICAgVGkuQVBJLndhcm4oYEFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICcke21vZHVsZUlkfScsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uLi5gKTtcbiAgfVxuXG4gIHJlZGlyZWN0cy5zZXQobW9kdWxlSWQsIGZpbGVwYXRoKTtcbn0gLy8gRklYTUU6IFRoZXJlJ3MgYSBjb2xsaXNpb24gaGVyZSB3aXRoIGdsb2JhbC5iaW5kaW5nIGRlY2xhcmVkIGluIEtyb2xsQnJpZGdlLm0gb24gaU9TXG5cbmlmICghZ2xvYmFsLmJpbmRpbmcpIHtcbiAgZ2xvYmFsLmJpbmRpbmcgPSB7fTtcbn1cblxuZ2xvYmFsLmJpbmRpbmcucmVnaXN0ZXIgPSByZWdpc3Rlcjtcbmdsb2JhbC5iaW5kaW5nLnJlZGlyZWN0ID0gcmVkaXJlY3Q7XG5cbi8vIExvYWQgYWxsIEphdmFTY3JpcHQgZXh0ZW5zaW9ucy9wb2x5ZmlsbHNcbnJlZ2lzdGVyKCdjb25zb2xlJywgZ2xvYmFsQ29uc29sZSk7XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICAvLyBBdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIGluIEpTT04gc3RydWN0dXJlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRhbml1bS5BY3Rpdml0eS5wcm90b3R5cGUsICd0b0pTT04nLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICAgIGNvbnN0IGtleUNvdW50ID0ga2V5cy5sZW5ndGg7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0ge307XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBrID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoayA9PT0gJ3dpbmRvdycgfHwgayA9PT0gJ2ludGVudCcgfHwgay5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWFsaXplZFtrXSA9IHRoaXNba107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICBjb25zdCBQcm9wZXJ0aWVzID0gVGl0YW5pdW0uQXBwLlByb3BlcnRpZXM7XG5cbiAgZnVuY3Rpb24gbnVsbE9yRGVmYXVsdFZhbHVlKGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BlcnR5R2V0dGVyKGRlbGVnYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgaWYgKCFQcm9wZXJ0aWVzLmhhc1Byb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxPckRlZmF1bHRWYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsZWdhdGUuY2FsbChQcm9wZXJ0aWVzLCBrZXkpO1xuICAgIH07XG4gIH1cblxuICBbJ2dldEJvb2wnLCAnZ2V0RG91YmxlJywgJ2dldEludCcsICdnZXRTdHJpbmcnXS5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHtcbiAgICBQcm9wZXJ0aWVzW2dldHRlcl0gPSBwcm9wZXJ0eUdldHRlcihQcm9wZXJ0aWVzW2dldHRlcl0pO1xuICB9KTtcblxuICBQcm9wZXJ0aWVzLmdldExpc3QgPSBQcm9wZXJ0aWVzLmdldE9iamVjdCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghUHJvcGVydGllcy5oYXNQcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gbnVsbE9yRGVmYXVsdFZhbHVlKGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoUHJvcGVydGllcy5nZXRTdHJpbmcoa2V5KSk7XG4gIH07XG5cbiAgUHJvcGVydGllcy5zZXRMaXN0ID0gUHJvcGVydGllcy5zZXRPYmplY3QgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBQcm9wZXJ0aWVzLnNldFN0cmluZyhrZXksIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuICB9O1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOS1QcmVzZW50IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCwgT1NfSU9TLCBPU19WRVJTSU9OX01BSk9SICovXG5jb25zdCBidWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICB2YWx1ZTogJydcbn0pO1xuY29uc3QgYmxvYiA9IGJ1ZmZlci50b0Jsb2IoKTtcbmNvbnN0IEJsb2JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmxvYik7XG5cbntcbiAgLy8gVGhpcyBkb2Vzbid0IFwic3RpY2tcIiBmb3IgaU9TLiBJdCBpcyBpbXBsZW1lbnRlZCBuYXRpdmVseS5cbiAgLy8gV2ViIEJsb2IgaGFzIGFuIGFycmF5QnVmZmVyKCkgbWV0aG9kIHRoYXQgcmV0dXJucyBhIFByb21pc2VcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvYXJyYXlCdWZmZXJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2JQcm90b3R5cGUsICdhcnJheUJ1ZmZlcicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGJ1ZjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGJ1ZiA9IHRoaXMudG9BcnJheUJ1ZmZlcigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGJ1Zik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xuXG57XG4gIGNvbnN0IExvY2FsZSA9IFRpdGFuaXVtLkxvY2FsZTtcbiAgY29uc3Qgd3JhcHBlZEdldFN0cmluZyA9IExvY2FsZS5nZXRTdHJpbmc7XG5cbiAgTG9jYWxlLmdldFN0cmluZyA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVR5cGUgPSB0eXBlb2YgZGVmYXVsdFZhbHVlOyAvLyBJZiB0aGUgaGludC9kZWZhdWx0IGlzIG5vdCBhIHN0cmluZywgaWdub3JlIGl0IVxuXG4gICAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gd3JhcHBlZEdldFN0cmluZy5jYWxsKExvY2FsZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlZEdldFN0cmluZy5jYWxsKExvY2FsZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9O1xuXG4gIGNvbW1vbmpzR2xvYmFsLkwgPSBMb2NhbGUuZ2V0U3RyaW5nO1xufVxuXG4vLyBLZWVwcyBhbiBvYmplY3QgYWxpdmUgdW50aWwgZGlzcG9zZSgpIGlzIGNhbGxlZC5cbi8vIFRoaXMgaXMgY3VycmVudGx5IHVzZWQgdG8ga2VlcCBcInRvcCBsZXZlbFwiIG9iamVjdHNcbi8vIChleDogd2luZG93cywgdGFiIGdyb3VwcykgYWxpdmUgdW50aWwgdGhlaXIgbGlmZWN5Y2xlIGVuZHMuXG5mdW5jdGlvbiBQZXJzaXN0ZW50SGFuZGxlKG9iamVjdCkge1xuICB0aGlzLmNlbGwgPSBQZXJzaXN0ZW50SGFuZGxlLmxhc3RJZCsrO1xuICBQZXJzaXN0ZW50SGFuZGxlLm9iamVjdHNbdGhpcy5jZWxsXSA9IG9iamVjdDtcbn0gLy8gT2JqZWN0cyByZXRhaW5lZCBieSBwZXJzaXN0ZW50IGhhbmRsZXMuXG4vLyBFYWNoIGVsZW1lbnQgaW4gdGhpcyBhcnJheSBhY3RzIGFzIGEgc3RvcmFnZSBcImNlbGxcIlxuLy8ga2VlcGluZyB0aGUgb2JqZWN0IHJlYWNoYWJsZSBhbmQgYWxpdmUgdW50aWwgaXQgaXMgcmVtb3ZlZC5cblxuXG5QZXJzaXN0ZW50SGFuZGxlLm9iamVjdHMgPSB7fTtcblBlcnNpc3RlbnRIYW5kbGUubGFzdElkID0gMDtcblxuUGVyc2lzdGVudEhhbmRsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2VsbCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIGhhbmRsZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlbGV0ZSBQZXJzaXN0ZW50SGFuZGxlLm9iamVjdHNbdGhpcy5jZWxsXTtcbiAgdGhpcy5jZWxsID0gLTE7XG59O1xuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxMy1QcmVzZW50IGJ5IEFwcGNlbGVyYXRvciwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG57XG4gIGNvbnN0IEhUVFBDbGllbnQgPSBUaXRhbml1bS5OZXR3b3JrLkhUVFBDbGllbnQ7XG4gIGNvbnN0IF9zZW5kID0gSFRUUENsaWVudC5wcm90b3R5cGUuc2VuZDtcblxuICBIVFRQQ2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBSZXRhaW4gdGhlIGh0dHBjbGllbnQgdW50aWwgdGhlIHJlcXVlc3QgaGFzIGJlZW4gZmluaXNoZWQuXG4gICAgY29uc3QgaGFuZGxlID0gbmV3IFBlcnNpc3RlbnRIYW5kbGUodGhpcyk7XG4gICAgdGhpcy5vbignZGlzcG9zZWhhbmRsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZS5kaXNwb3NlKCk7XG5cbiAgICAgIGlmIChrcm9sbC5EQkcpIHtcbiAgICAgICAga3JvbGwubG9nKCdIVFRQQ2xpZW50JywgJ1RoZSBwZXJzaXN0ZW50IGhhbmRsZSBpcyBkaXNwb3NlZC4nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9zZW5kLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH07XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDEyLVByZXNlbnQgYnkgQXBwY2VsZXJhdG9yLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICBmdW5jdGlvbiBpUGhvbmVDb25zdGFudChuYW1lKSB7XG4gICAgVGl0YW5pdW0uQVBJLmVycm9yKCchISEnKTtcbiAgICBUaXRhbml1bS5BUEkuZXJyb3IoJyEhISBXQVJOSU5HIDogVXNlIG9mIHVuc3VwcG9ydGVkIGNvbnN0YW50IFRpLlVJLmlQaG9uZS4nICsgbmFtZSArICcgISEhJyk7XG4gICAgVGl0YW5pdW0uQVBJLmVycm9yKCchISEnKTtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBUT0RPOiBSZW1vdmUgbWUuIE9ubHkgZm9yIHRlbXBvcmFyeSBjb21wYXRpYmlsaXR5XG5cblxuICBUaXRhbml1bS5VSS5pUGhvbmUgPSB7XG4gICAgQWN0aXZpdHlJbmRpY2F0b3JTdHlsZToge1xuICAgICAgZ2V0IEJJRygpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdBY3Rpdml0eUluZGljYXRvclN0eWxlLkJJRycpO1xuICAgICAgfSxcblxuICAgICAgZ2V0IERBUksoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnQWN0aXZpdHlJbmRpY2F0b3JTdHlsZS5EQVJLJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIEFuaW1hdGlvblN0eWxlOiB7XG4gICAgICBnZXQgRkxJUF9GUk9NX0xFRlQoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnQW5pbWF0aW9uU3R5bGUuRkxJUF9GUk9NX0xFRlQnKTtcbiAgICAgIH1cblxuICAgIH0sXG4gICAgUHJvZ3Jlc3NCYXJTdHlsZToge1xuICAgICAgZ2V0IFNJTVBMRSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdQcm9ncmVzc0JhclN0eWxlLlNJTVBMRScpO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBTeXN0ZW1CdXR0b246IHtcbiAgICAgIGdldCBGTEVYSUJMRV9TUEFDRSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdTeXN0ZW1CdXR0b24uRkxFWElCTEVfU1BBQ0UnKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBESVNDTE9TVVJFKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1N5c3RlbUJ1dHRvbi5ESVNDTE9TVVJFJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFN5c3RlbUJ1dHRvblN0eWxlOiB7XG4gICAgICBnZXQgQkFSKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1N5c3RlbUJ1dHRvblN0eWxlLkJBUicpO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBUYWJsZVZpZXdDZWxsU2VsZWN0aW9uU3R5bGU6IHtcbiAgICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1RhYmxlVmlld0NlbGxTZWxlY3Rpb25TdHlsZS5OT05FJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFRhYmxlVmlld1NlcGFyYXRvclN0eWxlOiB7XG4gICAgICBnZXQgTk9ORSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdUYWJsZVZpZXdTZXBhcmF0b3JTdHlsZS5OT05FJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFJvd0FuaW1hdGlvblN0eWxlOiB7XG4gICAgICBnZXQgTk9ORSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdSb3dBbmltYXRpb25TdHlsZS5OT05FJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFRhYmxlVmlld1Njcm9sbFBvc2l0aW9uOiB7XG4gICAgICBnZXQgTUlERExFKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1RhYmxlVmlld1Njcm9sbFBvc2l0aW9uLk1JRERMRScpO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBUYWJsZVZpZXdTdHlsZToge1xuICAgICAgZ2V0IEdST1VQRUQoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnVGFibGVWaWV3U3R5bGUuR1JPVVBFRCcpO1xuICAgICAgfVxuXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAyMC1QcmVzZW50IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vKiBnbG9iYWwgT1NfQU5EUk9JRCAqL1xuXG57XG4gIGNvbnN0IExpc3RWaWV3ID0gVGl0YW5pdW0uVUkuTGlzdFZpZXc7XG4gIGNvbnN0IGRlZmF1bHRUZW1wbGF0ZSA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBoZWlnaHQ6ICc0NWRwJ1xuICAgIH0sXG4gICAgY2hpbGRUZW1wbGF0ZXM6IFt7XG4gICAgICB0eXBlOiAnVGkuVUkuTGFiZWwnLFxuICAgICAgYmluZElkOiAndGl0bGUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBsZWZ0OiAnNmRwJyxcbiAgICAgICAgd2lkdGg6ICc3NSUnXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgdHlwZTogJ1RpLlVJLkltYWdlVmlldycsXG4gICAgICBiaW5kSWQ6ICdpbWFnZScsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJpZ2h0OiAnMjVkcCcsXG4gICAgICAgIHdpZHRoOiAnMTUlJ1xuICAgICAgfVxuICAgIH1dXG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlTGlzdFZpZXcob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIG9wdGlvbnMudGVtcGxhdGVzID0ge1xuICAgICAgW1RpdGFuaXVtLlVJLkxJU1RfSVRFTV9URU1QTEFURV9ERUZBVUxUXTogZGVmYXVsdFRlbXBsYXRlLFxuICAgICAgLi4ub3B0aW9ucy50ZW1wbGF0ZXNcbiAgICB9O1xuICAgIGNvbnN0IHRlbXBsYXRlcyA9IG9wdGlvbnMudGVtcGxhdGVzO1xuXG4gICAgZm9yIChjb25zdCBiaW5kaW5nIGluIHRlbXBsYXRlcykge1xuICAgICAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gdGVtcGxhdGVzW2JpbmRpbmddO1xuICAgICAgcHJvY2Vzc1RlbXBsYXRlKGN1cnJlbnRUZW1wbGF0ZSk7XG4gICAgICBwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMoY3VycmVudFRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExpc3RWaWV3KG9wdGlvbnMpO1xuICB9IC8vIENyZWF0ZSBMaXN0SXRlbVByb3h5LCBhZGQgZXZlbnRzLCB0aGVuIHN0b3JlIGl0IGluICd0aVByb3h5JyBwcm9wZXJ0eVxuXG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1RlbXBsYXRlKHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjZWxsUHJveHkgPSBUaXRhbml1bS5VSS5jcmVhdGVMaXN0SXRlbSgpO1xuICAgIGNvbnN0IGV2ZW50cyA9IHByb3BlcnRpZXMuZXZlbnRzO1xuICAgIHByb3BlcnRpZXMudGlQcm94eSA9IGNlbGxQcm94eTtcbiAgICBhZGRFdmVudExpc3RlbmVycyhldmVudHMsIGNlbGxQcm94eSk7XG4gIH0gLy8gUmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgcHJvY2VzcyBjaGlsZFRlbXBsYXRlcyBhbmQgYXBwZW5kIGNvcnJlc3BvbmRpbmcgcHJveGllcyB0b1xuICAvLyBwcm9wZXJ0eSAndGlQcm94eScuIEkuZTogdHlwZTogXCJUaXRhbml1bS5VSS5MYWJlbFwiIC0+IHRpUHJveHk6IExhYmVsUHJveHkgb2JqZWN0XG5cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMocHJvcGVydGllcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BlcnRpZXMsICdjaGlsZFRlbXBsYXRlcycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5jaGlsZFRlbXBsYXRlcztcblxuICAgIGlmICghY2hpbGRQcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRQcm9wZXJ0aWVzW2ldO1xuICAgICAgY29uc3QgcHJveHlUeXBlID0gY2hpbGQudHlwZTtcblxuICAgICAgaWYgKHByb3h5VHlwZSkge1xuICAgICAgICBjb25zdCBjcmVhdGlvblByb3BlcnRpZXMgPSBjaGlsZC5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBjcmVhdGlvbkZ1bmN0aW9uID0gbG9va3VwKHByb3h5VHlwZSk7IC8vIENyZWF0ZSBwcm94eS5cblxuICAgICAgICBsZXQgY2hpbGRQcm94eTtcblxuICAgICAgICBpZiAoY3JlYXRpb25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgY2hpbGRQcm94eSA9IGNyZWF0aW9uRnVuY3Rpb24oY3JlYXRpb25Qcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZFByb3h5ID0gY3JlYXRpb25GdW5jdGlvbigpO1xuICAgICAgICB9IC8vIEFkZCBldmVudCBsaXN0ZW5lcnMuXG5cblxuICAgICAgICBjb25zdCBldmVudHMgPSBjaGlsZC5ldmVudHM7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXJzKGV2ZW50cywgY2hpbGRQcm94eSk7IC8vIEFwcGVuZCBwcm94eSB0byB0aVByb3h5IHByb3BlcnR5LlxuXG4gICAgICAgIGNoaWxkLnRpUHJveHkgPSBjaGlsZFByb3h5O1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMoY2hpbGQpO1xuICAgIH1cbiAgfSAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzLlxuXG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoZXZlbnRzLCBwcm94eSkge1xuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgIHByb3h5LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9va3VwUHJveHlDb25zdHJ1Y3RvcihuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBuYW1lc3BhY2VJbmRleCA9IG5hbWVzcGFjZS5sYXN0SW5kZXhPZignLicpO1xuICAgIGNvbnN0IHByb3h5TmFtZSA9IG5hbWVzcGFjZS5zbGljZShuYW1lc3BhY2VJbmRleCArIDEpO1xuICAgIGNvbnN0IHBhcmVudE5hbWVzcGFjZSA9IG5hbWVzcGFjZS5zdWJzdHJpbmcoMCwgbmFtZXNwYWNlSW5kZXgpO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gcGFyZW50TmFtZXNwYWNlLnNwbGl0KCcuJyk7XG4gICAgbGV0IHBhcmVudFByb3h5ID0gY29tbW9uanNHbG9iYWw7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJlbnRQcm94eSA9IHBhcmVudFByb3h5W3NlZ21lbnRzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50UHJveHkpIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBhcmVudFByb3h5W2BjcmVhdGUke3Byb3h5TmFtZX1gXTtcblxuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGxvb2t1cCBjb25zdHJ1Y3RvciBmb3IgbmFtZXNwYWNlOiBcIiR7bmFtZXNwYWNlfVwiYCk7XG4gIH0gLy8gQ29udmVydCBuYW1lIG9mIFVJIGVsZW1lbnRzIGludG8gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgLy8gaS5lOiBsb29rdXAoXCJUaXRhbml1bS5VSS5MYWJlbFwiKSByZXR1cm5zIFRpdGFuaXVtLlVJLmNyZWF0ZUxhYmVsIGZ1bmN0aW9uLlxuXG5cbiAgZnVuY3Rpb24gbG9va3VwKG5hbWVzcGFjZSkge1xuICAgIC8vIEhhbmRsZSBUaXRhbml1bSB3aWRnZXRzLlxuICAgIGlmICgvXihUaXxUaXRhbml1bSkvLnRlc3QobmFtZXNwYWNlKSkge1xuICAgICAgcmV0dXJuIGxvb2t1cFByb3h5Q29uc3RydWN0b3IobmFtZXNwYWNlKTsgLy8gSGFuZGxlIEFsbG95IHdpZGdldHMuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB3aWRnZXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gbG9hZCBhbGxveSB3aWRnZXQuXG4gICAgICAgIHdpZGdldCA9IGNvbW1vbmpzR2xvYmFsLk1vZHVsZS5tYWluLnJlcXVpcmUoYC9hbGxveS93aWRnZXRzLyR7bmFtZXNwYWNlfS9jb250cm9sbGVycy93aWRnZXRgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBXaWRnZXQgZG9lcyBub3QgZXhpc3QsIGF0dGVtcHQgdG8gbG9hZCBuYW1lc3BhY2UuXG4gICAgICAgICAgd2lkZ2V0ID0gY29tbW9uanNHbG9iYWwuTW9kdWxlLm1haW4ucmVxdWlyZShuYW1lc3BhY2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBOYW1lc3BhY2UgZG9lcyBub3QgZXhpc3QsIGZhbGwgYmFjayB0byBsZWdhY3kgYmVoYXZpb3VyLlxuICAgICAgICAgIHJldHVybiBsb29rdXBQcm94eUNvbnN0cnVjdG9yKG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBjb25zdCBvYmogPSBuZXcgd2lkZ2V0KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIHJldHVybiBvYmouZ2V0VmlldygpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBPdmVyd3JpdGUgbGlzdCB2aWV3IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggb3VyIG93bi5cblxuXG4gIFRpdGFuaXVtLlVJLmNyZWF0ZUxpc3RWaWV3ID0gY3JlYXRlTGlzdFZpZXc7XG59XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICAvLyBBdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIGluIEpTT04gc3RydWN0dXJlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRhbml1bS5VSS5OYXZpZ2F0aW9uV2luZG93LnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrID09PSAncGFyZW50JyB8fCBrID09PSAnd2luZG93JyB8fCBrLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemVkW2tdID0gdGhpc1trXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjcmlwdCBpcyB1c2VkIGF0IHJ1bnRpbWUgZm9yIFRpLlVJLmZldGNoU2VtYW50aWNDb2xvciAtIGFzIHdlbGwgYXMgYXQgYnVpbGQgdGltZSBieSBib3RoIGlPUy9BbmRyb2lkLlxuICogSXQgcHJvdmlkZXMgYSBjb21tb24gaW50ZXJmYWNlIGZvciBoYW5kbGluZyBjb2xvcnMgYW5kIGNvbnZlcnRpbmcgdG8gbmVjZXNzYXJ5IHN0cmluZyBmb3Jtcy5cbiAqL1xuXG5jb25zdCBIRVhfM19SRUdFWCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7IC8vIGkuZS4gIzBGM1xuXG5jb25zdCBIRVhfNF9SRUdFWCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pOyAvLyBpLmUuICMwRjM4XG5cbmNvbnN0IEhFWF82X1JFR0VYID0gL14jPyhbYS1mXFxkXSl7Nn0kL2k7IC8vIGkuZS4gIzAwRkYzM1xuXG5jb25zdCBIRVhfOF9SRUdFWCA9IC9eIz8oW2EtZlxcZF0pezh9JC9pOyAvLyBpLmUuICMwMEZGMzM4OFxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlZ2VyIGluIHJhbmdlIG9mIDAtMjU1XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAyLWNoYXJhY3RlciBoZXggc3RyaW5nIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gcGFkZGVkSGV4KGludGVnZXIpIHtcbiAgY29uc3Qgc3RyID0gaW50ZWdlci50b1N0cmluZygxNik7XG5cbiAgaWYgKHN0ci5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYDAke3N0cn1gO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuY2xhc3MgQ29sb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHIgcmVkIHZhbHVlIGluIHJhbmdlIDAtMjU1XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnIGdyZWVuIHZhbHVlIGluIHJhbmdlIDAtMjU1XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiIGJsdWUgdmFsdWUgaW4gcmFuZ2UgMC0yNTVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthPTEuMF0gYWxwaGEgdmFsdWUgaW4gcmFuZ2UgMC4wLTEuMFxuICAgKi9cbiAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEuMCkge1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy5nID0gZztcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYWxwaGEgPSBhO1xuICB9XG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgaWYgdGhpcyBpcyBhIGZ1bGx5IG9wYXF1ZSBjb2xvciAoYWxwaGEgaXMgMS4wIG9yIHdhcyB1bmRlZmluZWQpXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGlzT3BhcXVlKCkge1xuICAgIHJldHVybiB0aGlzLmFscGhhID09PSAxLjA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBhbHBoYSB2YWx1ZSBpbnRvIGVxdWl2YWxlbnQgaGV4IHN0cmluZyB2YWx1ZSBwcm9wZXJseS5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICBhbHBoYUhleCgpIHtcbiAgICAvLyBuZWVkIHRvIHJvdW5kIHRvIGF2b2lkIG5vbnNlbnNpY2FsIHZhbHVlcyBsaWtlICc3Zi44JyBmb3IgYSAwLjUgYWxwaGFcbiAgICByZXR1cm4gcGFkZGVkSGV4KE1hdGgucm91bmQodGhpcy5hbHBoYSAqIDI1NS4wKSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2NhcmRzIGFueSBhbHBoYSB2YWx1ZS4gVG8gYmUgdXNlZCBpbnRlcm5hbGx5LCBub3QgZXh0ZXJuYWwgYXBpLiBEb2VzIG5vdCBwcm92aWRlIGxlYWRpbmcgJyMnIHN5bWJvbC5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICBfdG9SR0JIZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3BhZGRlZEhleCh0aGlzLnIpfSR7cGFkZGVkSGV4KHRoaXMuZyl9JHtwYWRkZWRIZXgodGhpcy5iKX1gO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5IENTUy5cbiAgICogQ29udmVydHMgdGhpcyBjb2xvciB0byBhIGhleCBzdHJpbmcgd2l0aCBsZWFkaW5nICcjJyBzeW1ib2wgYW5kIDYtIG9yIDgtXG4gICAqIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgKGRlcGVuZGluZyBvbiBpZiBhbHBoYSBpcyAxLjApXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgdG9SR0JBSGV4U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmlzT3BhcXVlKCkpIHtcbiAgICAgIHJldHVybiBgIyR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBgIyR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX0ke3RoaXMuYWxwaGFIZXgoKX1gO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5IEFuZHJvaWQvaU9TXG4gICAqIENvbnZlcnRzIHRoaXMgY29sb3IgdG8gYSBoZXggc3RyaW5nIHdpdGggbGVhZGluZyAnIycgc3ltYm9sIGFuZCA2LSBvciA4LVxuICAgKiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzIChkZXBlbmRpbmcgb24gaWYgYWxwaGEgaXMgMS4wKS4gQWxwaGEgaXMgdGhlIGZpcnN0IGVudHJ5IChpZiB0aGVyZSBpcyBhbHBoYS4pXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgdG9BUkdCSGV4U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmlzT3BhcXVlKCkpIHtcbiAgICAgIHJldHVybiBgIyR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBgIyR7dGhpcy5hbHBoYUhleCgpfSR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX1gO1xuICB9XG4gIC8qKlxuICAgKiBGb3IgY29tbW9uYWxpdHkgd2l0aCBuYXRpdmUgaU9TIFRpQ29sb3IgcHJveHkuIFByb2R1Y2VzIGFuIEFBUlJHR0JCIChvciBSUkdHQkIgaWYgZnVsbCBhbHBoYSkgaGV4IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuXG4gIHRvSGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRvQVJHQkhleFN0cmluZygpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIGNvbG9yIHRvIGFuIHJnYmEgZXhwcmVzc2lvbi4gVGhpcyBleHByZXNzaW9uIGlzIG1vcmUgY29uc2lzdGVudCBhY3Jvc3MgcGxhdGZvcm1zLlxuICAgKiAod2hlcmVhcyBpT1MvQW5kcm9pZCBkaWZmZXIgaW4gZXhwZWN0YXRpb25zIGZvciBoZXggc3RyaW5ncy4pXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgdG9SR0JBU3RyaW5nKCkge1xuICAgIHJldHVybiBgcmdiYSgke3RoaXMucn0sICR7dGhpcy5nfSwgJHt0aGlzLmJ9LCAke3RoaXMuYWxwaGEudG9GaXhlZCgzKX0pYDtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge0NvbG9yfVxuICAgKi9cblxuXG4gIHN0YXRpYyBmYWxsYmFjaygpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDApOyAvLyByZXR1cm4gYmxhY2sgdG8gbWF0Y2ggbmF0aXZlIGltcGwgaW4gaU9TXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdXBwbGllZCBoZXggc3RyaW5nIE1VU1QgYmUgaW4gZm9ybSAnIzAwMDAwMCcgKGkuZS4gbGVhZGluZyBwb3VuZCBzeW1ib2wsIDYgaGV4IGNoYXJhY3RlcnMgYWZ0ZXIpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZXggaGV4YWRlY2ltYWwgY29sb3Igc3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGFdIGFscGhhIHZhbHVlXG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICovXG5cblxuICBzdGF0aWMgZnJvbUhleDZTdHJpbmcoaGV4LCBhbHBoYSkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBoZXguc3RhcnRzV2l0aCgnIycpID8gMSA6IDA7XG4gICAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCwgMiksIDE2KTtcbiAgICBjb25zdCBnID0gcGFyc2VJbnQoaGV4LnN1YnN0cihzdGFydEluZGV4ICsgMiwgMiksIDE2KTtcbiAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cihzdGFydEluZGV4ICsgNCwgMiksIDE2KTtcbiAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGFscGhhKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN1cHBsaWVkIGhleCBzdHJpbmcgTVVTVCBiZSBpbiBmb3JtICcjMDAwMDAwMDAnIChpLmUuIGxlYWRpbmcgcG91bmQgc3ltYm9sLCA4IGhleCBjaGFyYWN0ZXJzIGFmdGVyKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4IGhleGFkZWNpbWFsIGNvbG9yIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7Q29sb3J9XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21IZXg4U3RyaW5nKGhleCkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBoZXguc3RhcnRzV2l0aCgnIycpID8gMSA6IDA7XG4gICAgY29uc3QgYWxwaGEgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXgsIDIpLCAxNik7IC8vIGFscGhhIGlzIG5vdyAwLTI1NVxuXG4gICAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCArIDIsIDIpLCAxNik7XG4gICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCArIDQsIDIpLCAxNik7XG4gICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCArIDYsIDIpLCAxNik7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhbHBoYSAvIDI1NS4wKTsgLy8gY29udmVydCB0byAwLjAtMS4wIChwZXJjZW50KVxuICB9XG4gIC8qKlxuICAgKiBOb3RlIHRoYXQgdGhlIGhleCB2YWx1ZSBjYW4gY29udGFpbiBhbHBoYSwgYnV0IG11c3QgZm9sbG93IHRoZSBDU1Mgc3RhbmRhcmQgb2YgI1JSR0dCQkFBIChOT1QgdGhlIEFuZHJvaWQgc3RhbmRhcmQgb2YgI0FBUlJHR0JCKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGVudHJ5IHBvc3NpYmxlIGhleCBzdHJpbmcgb3IgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2hleC5hbHBoYV0gYWxwaGEgdmFsdWUgaW4gcGVyY2VudCAoMC4wLTEwMC4wKSB3aGVuIGhleCBpcyBhbiBvYmplY3RcbiAgXHQgKiBAcGFyYW0ge3N0cmluZ30gW2hleC5jb2xvcl0gaGV4IHN0cmluZyBmb3IgdGhlIGJhc2UgY29sb3Igd2hlbiBoZXggaXMgYW4gb2JqZWN0XG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICogQHRocm93cyBpZiBlbnRyeSBoYXMgYm90aCBhbiBleHBsaWNpdCBhbHBoYSB2YWx1ZSBBTkQgYSBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYW4gYWxwaGEgdmFsdWVcbiAgICovXG5cblxuICBzdGF0aWMgZnJvbVNlbWFudGljQ29sb3JzRW50cnkoZW50cnkpIHtcbiAgICBsZXQgY29sb3IgPSBlbnRyeTtcbiAgICBsZXQgYWxwaGEgPSAxLjA7XG4gICAgbGV0IGhhZEFscGhhID0gZmFsc2U7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudHJ5LCAnYWxwaGEnKSkge1xuICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGVudHJ5LmFscGhhKSAvIDEwMC4wOyAvLyBjb252ZXJ0IGZyb20gMC0xMDAgcmFuZ2UgdG8gMC0xIHJhbmdlXG5cbiAgICAgIGhhZEFscGhhID0gdHJ1ZTtcbiAgICAgIGNvbG9yID0gZW50cnkuY29sb3I7IC8vIGlmIGl0IGhhcyBhbiBhbHBoYSBwcm9wZXJ0eSBhc3N1bWUgaXQgaGFzIGEgY29sb3IgcHJvcGVydHkgdG9vIVxuICAgIH0gLy8gZXhwYW5kIHRoZSBzaG9ydGVyIGhleCBzdHJpbmcgZm9ybXMgdG8gNiBvciA4IGRpZ2l0c1xuXG5cbiAgICBpZiAoY29sb3IubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0ZcIikgdG8gZnVsbCBmb3JtIChlLmcuIFwiMDAzM0ZGXCIpXG4gICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoSEVYXzNfUkVHRVgsIChtLCByLCBnLCBiKSA9PiByICsgciArIGcgKyBnICsgYiArIGIpO1xuICAgIH0gZWxzZSBpZiAoY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0Y4XCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRjg4XCIpXG4gICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoSEVYXzRfUkVHRVgsIChtLCBhLCByLCBnLCBiKSA9PiBhICsgYSArIHIgKyByICsgZyArIGcgKyBiICsgYik7XG4gICAgfVxuXG4gICAgaWYgKEhFWF82X1JFR0VYLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gQ29sb3IuZnJvbUhleDZTdHJpbmcoY29sb3IsIGFscGhhKTtcbiAgICB9XG5cbiAgICBpZiAoSEVYXzhfUkVHRVguZXhlYyhjb2xvcikpIHtcbiAgICAgIGlmIChoYWRBbHBoYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbG9yICR7ZW50cnl9IGhhZCBhbiBleHBsaWNpdCBhbHBoYSB2YWx1ZSBBTkQgYSBoZXggdmFsdWUgY29udGFpbmluZyBhbHBoYS4gVXNlIG9uZSBvciB0aGUgb3RoZXIuYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4OFN0cmluZyhjb2xvcik7XG4gICAgfSAvLyB1aC1vaCwgc29tZXRoaW5nIGlzIHVwIVxuXG5cbiAgICByZXR1cm4gQ29sb3IuZmFsbGJhY2soKTtcbiAgfVxuXG59XG5cbnZhciBjb2xvciA9IENvbG9yO1xuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOS0yMDIwIGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vLyBUaS5VSSB3aXRoaW4gdGhpcyBmaWxlLCB3ZSBtdXN0IGNhbGwga3JvbGwuYmluZGluZyB0byBnZXQgdGhlIFRpdGFuaXVtXG4vLyBuYW1lc3BhY2UgdGhhdCBpcyBwYXNzZWQgaW4gd2l0aCByZXF1aXJlIGFuZCB0aGF0IGRlYWwgd2l0aCB0aGUgLlVJXG4vLyBuYW1lc3BhY2UgdGhhdCBpcyBvbiB0aGF0IGRpcmVjdGx5LlxuXG5jb25zdCBVSSA9IGtyb2xsLmJpbmRpbmcoJ1RpdGFuaXVtJykuVGl0YW5pdW0uVUkgOyAvLyBNYWtlIG91ciByZWFkLW9ubHkgY29uc3RhbnRzXG4vLyBUT0RPOiBSZW1vdmUgaW4gU0RLIDEwLCBERVBSRUNBVEVEIGluIDkuMS4wXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSSwgJ1NFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQnLCB7XG4gIHZhbHVlOiAnbGlnaHQnLFxuICB3cml0YWJsZTogZmFsc2Vcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJLCAnU0VNQU5USUNfQ09MT1JfVFlQRV9EQVJLJywge1xuICB2YWx1ZTogJ2RhcmsnLFxuICB3cml0YWJsZTogZmFsc2Vcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJLCAnc2VtYW50aWNDb2xvclR5cGUnLCB7XG4gIGdldDogKCkgPT4ge1xuICAgIC8vIFRPRE86IEd1YXJkIGFnYWluc3QgaW9zIDwgMTMgYW5kIEFuZHJvaWQgYXBpIDwgMjk/XG4gICAgLy8gQXNzdW1lIFwibGlnaHRcIiBtb2RlIHVubGVzcyB3ZSBleHBsaWNpdGx5IGtub3cgaXQncyBkYXJrXG4gICAgaWYgKFRpLlVJLnVzZXJJbnRlcmZhY2VTdHlsZSA9PT0gVGkuVUkuVVNFUl9JTlRFUkZBQ0VfU1RZTEVfREFSSykge1xuICAgICAgcmV0dXJuIFVJLlNFTUFOVElDX0NPTE9SX1RZUEVfREFSSztcbiAgICB9XG5cbiAgICByZXR1cm4gVUkuU0VNQU5USUNfQ09MT1JfVFlQRV9MSUdIVDtcbiAgfVxufSk7IC8vIG9uIEFuZHJvaWQvaU9TIDwgMTMsIHdlIG5lZWQgdG8gcm9sbCBvdXIgb3duIGZldGNoU2VtYW50aWNDb2xvciBpbXBsXG4vLyBvbiBpT1MgMTMrLCB3ZSBoYXZlIGEgbmF0aXZlIHZlcnNpb25cblxue1xuXG4gIGxldCBjb2xvcnNldDtcblxuICBVSS5mZXRjaFNlbWFudGljQ29sb3IgPSBmdW5jdGlvbiBmZXRjaFNlbWFudGljQ29sb3IoY29sb3JOYW1lKSB7XG4gICAgLy8gTG9hZCBhbGwgc2VtYW50aWMgY29sb3JzIGZyb20gSlNPTiBpZiBub3QgZG9uZSBhbHJlYWR5LlxuICAgIC8vIERvIHNvIHZpYSByZXF1aXJlKCkgaW4gY2FzZSB0aGlzIGZpbGUgd2FzIGNoYW5nZWQgd2hpbGUgcnVubmluZyBMaXZlVmlldy5cbiAgICBpZiAoIWNvbG9yc2V0KSB7XG4gICAgICBjb25zdCBjb2xvcnNldEZpbGVOYW1lID0gJ3NlbWFudGljLmNvbG9ycy5qc29uJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29sb3JzZXRGaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5LCBjb2xvcnNldEZpbGVOYW1lKTtcblxuICAgICAgICBpZiAoY29sb3JzZXRGaWxlLmV4aXN0cygpKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZXF1aXJlXG4gICAgICAgICAgY29sb3JzZXQgPSByZXF1aXJlKGAvJHtjb2xvcnNldEZpbGVOYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBjb2xvcnMgZmlsZSAnJHtjb2xvcnNldEZpbGVOYW1lfSdgKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yLmZhbGxiYWNrKCkudG9IZXgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgLy8gT24gQW5kcm9pZCwgdXNlIGN1c3RvbSBzdHJpbmcgcmVmZXJlbmNlcyB0byBiZSBoYW5kbGVkIGJ5IFwiVGlDb2xvckhlbHBlci5qYXZhXCIuXG4gICAgICAgIGlmIChjb2xvcnNldFtjb2xvck5hbWVdKSB7XG4gICAgICAgICAgLy8gQWRkIGFsbCB0aGVtZSBjb2xvcnMgdG8gYSBzaW5nbGUgc3RyaW5nLlxuICAgICAgICAgIC8vIEV4YW1wbGU6IFwidGkuc2VtYW50aWMuY29sb3I6ZGFyaz08Q29sb3JTdHJpbmc+O2xpZ2h0PTxDb2xvclN0cmluZz5cIlxuICAgICAgICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBbXTtcblxuICAgICAgICAgIGZvciAoY29uc3QgY29sb3JUeXBlIGluIGNvbG9yc2V0W2NvbG9yTmFtZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yT2JqID0gY29sb3IuZnJvbVNlbWFudGljQ29sb3JzRW50cnkoY29sb3JzZXRbY29sb3JOYW1lXVtjb2xvclR5cGVdKTtcbiAgICAgICAgICAgIGNvbG9yQXJyYXkucHVzaChgJHtjb2xvclR5cGV9PSR7Y29sb3JPYmoudG9SR0JBU3RyaW5nKCl9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICd0aS5zZW1hbnRpYy5jb2xvcjonICsgY29sb3JBcnJheS5qb2luKCc7Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoVGkuQW5kcm9pZC5SLmNvbG9yW2NvbG9yTmFtZV0pIHtcbiAgICAgICAgICAvLyBXZSdyZSByZWZlcmVuY2luZyBhIG5hdGl2ZSBcInJlc1wiIGNvbG9yIGVudHJ5LlxuICAgICAgICAgIHJldHVybiBgQGNvbG9yLyR7Y29sb3JOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvb2t1cCBjb2xvciBmb3IgJHtjb2xvck5hbWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yLmZhbGxiYWNrKCkudG9IZXgoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtUHJlc2VudCBieSBBcHBjZWxlcmF0b3IsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lELCBPU19JT1MgKi9cbntcbiAgY29uc3QgVGFiID0gVGl0YW5pdW0uVUkuVGFiO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRhYihvcHRpb25zKSB7XG4gICAgY29uc3QgdGFiID0gbmV3IFRhYihvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0YWIuX3dpbmRvdyA9IG9wdGlvbnMud2luZG93O1xuICAgIH1cblxuICAgIHJldHVybiB0YWI7XG4gIH1cblxuICBUaXRhbml1bS5VSS5jcmVhdGVUYWIgPSBjcmVhdGVUYWI7XG5cbiAgVGFiLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKHdpbmRvdywgb3B0aW9ucykge1xuICAgIGlmICghd2luZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfSAvLyBXaGVuIHdlIG9wZW4gYSB3aW5kb3cgdXNpbmcgdGFiLm9wZW4od2luKSwgd2UgdHJlYXQgaXQgYXNcbiAgICAvLyBvcGVuaW5nIGEgSFcgd2luZG93IG9uIHRvcCBvZiB0aGUgdGFiLlxuXG5cbiAgICBvcHRpb25zLnRhYk9wZW4gPSB0cnVlO1xuICAgIHdpbmRvdy5vcGVuKG9wdGlvbnMpO1xuICB9O1xuXG4gIFRhYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMuZ2V0V2luZG93KCk7XG5cbiAgICBpZiAod2luZG93KSB7XG4gICAgICB3aW5kb3cuY2xvc2Uob3B0aW9ucyk7XG4gICAgICB0aGlzLnNldFdpbmRvdyhudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgX3NldFdpbmRvdyA9IFRhYi5wcm90b3R5cGUuc2V0V2luZG93O1xuXG4gIFRhYi5wcm90b3R5cGUuc2V0V2luZG93ID0gZnVuY3Rpb24gKHdpbmRvdykge1xuICAgIHRoaXMuX3dpbmRvdyA9IHdpbmRvdztcblxuICAgIF9zZXRXaW5kb3cuY2FsbCh0aGlzLCB3aW5kb3cpO1xuICB9OyAvLyBUT0RPOiBSZW1vdmUhIFRoaXMgaXMgYW4gdW5kb2N1bWVudGVkIGFjY2Vzc29yIG1ldGhvZFxuXG5cbiAgVGFiLnByb3RvdHlwZS5nZXRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvdztcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiLnByb3RvdHlwZSwgJ3dpbmRvdycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHNldDogVGFiLnByb3RvdHlwZS5zZXRXaW5kb3csXG4gICAgZ2V0OiBUYWIucHJvdG90eXBlLmdldFdpbmRvd1xuICB9KTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIGNvbnN0IFRhYkdyb3VwID0gVGl0YW5pdW0uVUkuVGFiR3JvdXA7IC8vIEF2b2lkIGNpcmN1bGFyIGxvb3BzIGluIHRvSlNPTigpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkdyb3VwLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrID09PSAnYWN0aXZpdHknIHx8IGsuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmlhbGl6ZWRba10gPSB0aGlzW2tdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGl0YW5pdW0uVUkuVGFiLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrID09PSAnd2luZG93JyB8fCBrID09PSAndGFiR3JvdXAnIHx8IGsuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmlhbGl6ZWRba10gPSB0aGlzW2tdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxNS1QcmVzZW50IGJ5IEFwcGNlbGVyYXRvciwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cbntcbiAgY29uc3QgVmlldyA9IFRpdGFuaXVtLlVJLlZpZXc7XG4gIGNvbnN0IF9hZGQgPSBWaWV3LnByb3RvdHlwZS5hZGQ7XG5cbiAgVmlldy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGl0YW5pdW0uVGlXaW5kb3cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCB3aW5kb3cvdGFiR3JvdXAgdG8gYSB2aWV3LicpO1xuICAgIH1cblxuICAgIHRoaXMuX2NoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4gfHwgW107XG5cbiAgICBfYWRkLmNhbGwodGhpcywgY2hpbGQpOyAvLyBUaGUgY2hpbGRyZW4gaGF2ZSB0byBiZSByZXRhaW5lZCBieSB0aGUgdmlldyBpbiB0aGUgSmF2YXNjcmlwdCBzaWRlXG4gICAgLy8gaW4gb3JkZXIgdG8gbGV0IFY4IGtub3cgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGNoaWxkcmVuIGFuZCB0aGUgdmlldy5cbiAgICAvLyBUaGVyZWZvcmUsIGFzIGxvbmcgYXMgaXRzIHdpbmRvdyBpcyBvcGVuLCBhbGwgaXRzIGNoaWxkcmVuIHdvbid0IGJlIGRldGFjaGVkXG4gICAgLy8gb3IgZ2FyYmFnZSBjb2xsZWN0ZWQgYW5kIFY4IHdpbGwgcmVjb2dhbml6ZSB0aGUgY2xvc3VyZXMgYW5kIHJldGFpbiBhbGxcbiAgICAvLyB0aGUgcmVsYXRlZCBwcm94aWVzLlxuXG5cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgfTtcblxuICBjb25zdCBfcmVtb3ZlID0gVmlldy5wcm90b3R5cGUucmVtb3ZlO1xuXG4gIFZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIF9yZW1vdmUuY2FsbCh0aGlzLCBjaGlsZCk7IC8vIFJlbW92ZSB0aGUgY2hpbGQgaW4gdGhlIEphdmFzY3JpcHQgc2lkZSBzbyBpdCBjYW4gYmUgZGV0YWNoZWQgYW5kIGdhcmJhZ2UgY29sbGVjdGVkLlxuXG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuIHx8IFtdO1xuICAgIGNvbnN0IGNoaWxkSW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgIGlmIChjaGlsZEluZGV4ICE9PSAtMSkge1xuICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgIH1cbiAgfTsgLy8gRG8gbm90IHNlcmlhbGl6ZSB0aGUgcGFyZW50IHZpZXcuIERvaW5nIHNvIHdpbGwgcmVzdWx0XG4gIC8vIGluIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGxvb3AuXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGl0YW5pdW0uVGlWaWV3LnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrID09PSAncGFyZW50JyB8fCBrLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemVkW2tdID0gdGhpc1trXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn1cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIGNvbnN0IGNyZWF0ZVdlYlZpZXcgPSBUaXRhbml1bS5VSS5jcmVhdGVXZWJWaWV3O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdlYlZpZXdXcmFwcGVyKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3ZWJWaWV3ID0gY3JlYXRlV2ViVmlldy5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHdlYlZpZXcub25DcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFlLmlzVXNlckdlc3R1cmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdpbiA9IFRpdGFuaXVtLlVJLmNyZWF0ZVdpbmRvdyh7fSwge1xuICAgICAgICBmdWxsc2NyZWVuOiBmYWxzZSAvLyBGb3JjZSBuZXcgYWN0aXZpdHkuXG5cbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV3V2ViVmlldyA9IFRpdGFuaXVtLlVJLmNyZWF0ZVdlYlZpZXcoKTtcbiAgICAgIHdpbi5hZGQobmV3V2ViVmlldyk7XG4gICAgICB3aW4ub3BlbigpO1xuICAgICAgcmV0dXJuIG5ld1dlYlZpZXc7XG4gICAgfTtcblxuICAgIHJldHVybiB3ZWJWaWV3O1xuICB9XG5cbiAgVGl0YW5pdW0uVUkuY3JlYXRlV2ViVmlldyA9IGNyZWF0ZVdlYlZpZXdXcmFwcGVyO1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxMS1QcmVzZW50IGJ5IEFwcGNlbGVyYXRvciwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG57XG4gIGNvbnN0IFRBRyA9ICdXaW5kb3cnO1xuICBjb25zdCBTY3JpcHQgPSBrcm9sbC5iaW5kaW5nKCdldmFscycpLlNjcmlwdDsgLy8gQW5kcm9pZC1zcGVjaWZpYyB3YXkgdG8gZ3JhYiBiaW5kaW5nLCBoYW5ncyBvZmYgJ3NjcmlwdCcgb24gaU9TXG5cbiAgY29uc3QgV2luZG93ID0gVGl0YW5pdW0uVUkuV2luZG93O1xuICBXaW5kb3cucHJvdG90eXBlLl9jYWNoZWRBY3Rpdml0eVByb3h5ID0gbnVsbDtcblxuICBmdW5jdGlvbiBjcmVhdGVXaW5kb3cob3B0aW9ucykge1xuICAgIGNvbnN0IHdpbmRvdyA9IG5ldyBXaW5kb3cob3B0aW9ucyk7XG4gICAgd2luZG93Ll9jaGlsZHJlbiA9IFtdO1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBUaXRhbml1bS5VSS5jcmVhdGVXaW5kb3cgPSBjcmVhdGVXaW5kb3c7IC8vIEFjdGl2aXR5IGdldHRlciAoYWNjb3VudCBmb3Igc2NlbmFyaW8gd2hlbiBoZWF2eSB3ZWlnaHQgd2luZG93J3MgYWN0aXZpdHkgaXMgbm90IGNyZWF0ZWQgeWV0KVxuXG4gIGZ1bmN0aW9uIGFjdGl2aXR5UHJveHlHZXR0ZXIoKSB7XG4gICAgY29uc3QgYWN0aXZpdHlQcm94eSA9IHRoaXMuX2dldFdpbmRvd0FjdGl2aXR5UHJveHkoKTtcblxuICAgIGlmIChhY3Rpdml0eVByb3h5KSB7XG4gICAgICByZXR1cm4gYWN0aXZpdHlQcm94eTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2FjaGVkQWN0aXZpdHlQcm94eSA9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB0aGlzLl9jYWNoZWRBY3Rpdml0eVByb3h5ID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEFjdGl2aXR5UHJveHk7XG4gIH1cblxuICBXaW5kb3cucHJvdG90eXBlLmdldEFjdGl2aXR5ID0gYWN0aXZpdHlQcm94eUdldHRlcjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpbmRvdy5wcm90b3R5cGUsICdhY3Rpdml0eScsIHtcbiAgICBnZXQ6IGFjdGl2aXR5UHJveHlHZXR0ZXJcbiAgfSk7XG4gIGNvbnN0IF9vcGVuID0gV2luZG93LnByb3RvdHlwZS5vcGVuO1xuXG4gIFdpbmRvdy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gUmV0YWluIHRoZSB3aW5kb3cgdW50aWwgaXQgaGFzIGNsb3NlZC5cbiAgICBjb25zdCBoYW5kbGUgPSBuZXcgUGVyc2lzdGVudEhhbmRsZSh0aGlzKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLl9jbG9zZUZyb21BY3Rpdml0eUZvcmNlZFRvRGVzdHJveSkge1xuICAgICAgICBpZiAoa3JvbGwuREJHKSB7XG4gICAgICAgICAga3JvbGwubG9nKFRBRywgJ1dpbmRvdyBpcyBjbG9zZWQgYmVjYXVzZSB0aGUgYWN0aXZpdHkgaXMgZm9yY2VkIHRvIGRlc3Ryb3kgYnkgQW5kcm9pZCBPUy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRGlzcG9zZSB0aGUgVVJMIGNvbnRleHQgaWYgdGhlIHdpbmRvdydzIGFjdGl2aXR5IGlzIGRlc3Ryb3llZC5cblxuXG4gICAgICBpZiAoc2VsZi5fdXJsQ29udGV4dCkge1xuICAgICAgICBTY3JpcHQuZGlzcG9zZUNvbnRleHQoc2VsZi5fdXJsQ29udGV4dCk7XG4gICAgICAgIHNlbGYuX3VybENvbnRleHQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGUuZGlzcG9zZSgpO1xuXG4gICAgICBpZiAoa3JvbGwuREJHKSB7XG4gICAgICAgIGtyb2xsLmxvZyhUQUcsICdXaW5kb3cgaXMgY2xvc2VkIG5vcm1hbGx5LicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfb3Blbi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIGNvbnN0IF9hZGQgPSBXaW5kb3cucHJvdG90eXBlLmFkZDtcblxuICBXaW5kb3cucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRpdGFuaXVtLlRpV2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgd2luZG93L3RhYkdyb3VwIHRvIGFub3RoZXIgd2luZG93L3RhYkdyb3VwLicpO1xuICAgIH1cblxuICAgIF9hZGQuY2FsbCh0aGlzLCBjaGlsZCk7IC8vIFRoZSBjaGlsZHJlbiBoYXZlIHRvIGJlIHJldGFpbmVkIGJ5IHRoZSB3aW5kb3cgaW4gdGhlIEphdmFzY3JpcHQgc2lkZVxuICAgIC8vIGluIG9yZGVyIHRvIGxldCBWOCBrbm93IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBjaGlsZHJlbiBhbmQgdGhlIHdpbmRvdy5cbiAgICAvLyBUaGVyZWZvcmUsIGFzIGxvbmcgYXMgdGhlIHdpbmRvdyBpcyBvcGVuLCBhbGwgaXRzIGNoaWxkcmVuIHdvbid0IGJlIGRldGFjaGVkXG4gICAgLy8gb3IgZ2FyYmFnZSBjb2xsZWN0ZWQgYW5kIFY4IHdpbGwgcmVjb2dhbml6ZSB0aGUgY2xvc3VyZXMgYW5kIHJldGFpbiBhbGxcbiAgICAvLyB0aGUgcmVsYXRlZCBwcm94aWVzLlxuXG5cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgfTtcblxuICBjb25zdCBfcmVtb3ZlID0gV2luZG93LnByb3RvdHlwZS5yZW1vdmU7XG5cbiAgV2luZG93LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBfcmVtb3ZlLmNhbGwodGhpcywgY2hpbGQpOyAvLyBSZW1vdmUgdGhlIGNoaWxkIGluIHRoZSBKYXZhc2NyaXB0IHNpZGUgc28gaXQgY2FuIGJlIGRldGFjaGVkIGFuZCBnYXJiYWdlIGNvbGxlY3RlZC5cblxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRJbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBXaW5kb3cucHJvdG90eXBlLnBvc3RXaW5kb3dDcmVhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrcm9sbC5EQkcpIHtcbiAgICAgIGtyb2xsLmxvZyhUQUcsICdDaGVja3BvaW50OiBwb3N0V2luZG93Q3JlYXRlZCgpJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NhY2hlZEFjdGl2aXR5UHJveHkpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsQWN0aXZpdHkuZXh0ZW5kKHRoaXMuX2NhY2hlZEFjdGl2aXR5UHJveHkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciB0aGUgRXZlbnRFbWl0dGVyIGluc3RhbmNlIHRvIHVzZSB0byByZWdpc3RlciBmb3IgaXQncyBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIGZvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIGNhbGxiYWNrL2Z1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHByZXBlbmQgd2hldGhlciB0byBwcmVwZW5kIG9yIGFwcGVuZCB0aGUgbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKi9cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudE5hbWUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVycyA9IHt9OyAvLyBpbml0aWFsaXplIGl0XG4gIH0gLy8gaWYgdGhlcmUncyBzb21lb25lIGxpc3RlbmluZyB0byAnbmV3TGlzdGVuZXInIGV2ZW50cywgZW1pdCB0aGF0ICoqYmVmb3JlKiogd2UgYWRkIHRoZSBsaXN0ZW5lciAodG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uKVxuXG5cbiAgaWYgKGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzLm5ld0xpc3RlbmVyKSB7XG4gICAgZW1pdHRlci5lbWl0KCduZXdMaXN0ZW5lcicsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuXG4gIGlmIChwcmVwZW5kKSB7XG4gICAgZXZlbnRMaXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdID0gZXZlbnRMaXN0ZW5lcnM7IC8vIENoZWNrIG1heCBsaXN0ZW5lcnMgYW5kIHNwaXQgb3V0IHdhcm5pbmcgaWYgPlxuXG4gIGNvbnN0IG1heCA9IGVtaXR0ZXIuZ2V0TWF4TGlzdGVuZXJzKCk7XG4gIGNvbnN0IGxlbmd0aCA9IGV2ZW50TGlzdGVuZXJzLmxlbmd0aDtcblxuICBpZiAobWF4ID4gMCAmJiBsZW5ndGggPiBtYXgpIHtcbiAgICBjb25zdCB3ID0gbmV3IEVycm9yKGBQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICR7bGVuZ3RofSAke2V2ZW50TmFtZX0gbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdGApO1xuICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgIHcuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdy50eXBlID0gZXZlbnROYW1lO1xuICAgIHcuY291bnQgPSBsZW5ndGg7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyh3KTtcbiAgfVxuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG5mdW5jdGlvbiBvbmNlV3JhcChlbWl0dGVyLCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy53cmFwcGVkRnVuYyk7IC8vIHJlbW92ZSBvdXJzZWx2ZXNcblxuICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy5lbWl0dGVyLCBhcmdzKTsgLy8gdGhlbiBmb3J3YXJkIHRoZSBldmVudCBjYWxsYmFja1xuICB9IC8vIHdlIGhhdmUgdG8gdXNlIGJpbmQgd2l0aCBhIGN1c3RvbSAndGhpcycsIGJlY2F1c2UgZXZlbnRzIGZpcmUgd2l0aCAndGhpcycgcG9pbnRpbmcgYXQgdGhlIGVtaXR0ZXJcblxuXG4gIGNvbnN0IHdyYXBwZXJUaGlzID0ge1xuICAgIGVtaXR0ZXIsXG4gICAgZXZlbnROYW1lLFxuICAgIGxpc3RlbmVyXG4gIH07XG4gIGNvbnN0IGJvdW5kID0gd3JhcHBlci5iaW5kKHdyYXBwZXJUaGlzKTsgLy8gYmluZCB0byBmb3JjZSBcInRoaXNcIiB0byByZWZlciB0byBvdXIgY3VzdG9tIG9iamVjdCB0cmFja2luZyB0aGUgd3JhcHBlci9lbWl0dGVyL2xpc3RlbmVyXG5cbiAgYm91bmQubGlzdGVuZXIgPSBsaXN0ZW5lcjsgLy8gaGF2ZSB0byBhZGQgbGlzdGVuZXIgcHJvcGVydHkgZm9yIFwidW53cmFwcGluZ1wiXG5cbiAgd3JhcHBlclRoaXMud3JhcHBlZEZ1bmMgPSBib3VuZDtcbiAgcmV0dXJuIGJvdW5kO1xufSAvLyBtYW55IGNvbnN1bWVycyBtYWtlIHVzZSBvZiB0aGlzIHZpYSB1dGlsLmluaGVyaXRzLCB3aGljaCBkb2VzIG5vdCBjaGFpbiBjb25zdHJ1Y3RvciBjYWxscyFcbi8vIHNvIHdlIG5lZWQgdG8gYmUgYXdhcmUgdGhhdCBfZXZlbnRzVG9MaXN0ZW5lcnMgbWF5ZSBiZSBudWxsL3VuZGVmaW5lZCBvbiBpbnN0YW5jZXMsIGFuZCBjaGVjayBpbiBtZXRob2RzIGJlZm9yZSBhY2Nlc3NpbmcgaXRcblxuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ldmVudHNUb0xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfVxuXG4gIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgfVxuXG4gIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMub24oZXZlbnROYW1lLCBvbmNlV3JhcCh0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyKSk7XG4gIH1cblxuICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIG9uY2VXcmFwKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIpKTtcbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBldmVudExpc3RlbmVycy5sZW5ndGg7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMTtcbiAgICBsZXQgdW53cmFwcGVkTGlzdGVuZXI7IC8vIE5lZWQgdG8gc2VhcmNoIExJRk8sIGFuZCBuZWVkIHRvIGhhbmRsZSB3cmFwcGVkIGZ1bmN0aW9ucyAob25jZSB3cmFwcGVycylcblxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGV2ZW50TGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciB8fCBldmVudExpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIHVud3JhcHBlZExpc3RlbmVyID0gZXZlbnRMaXN0ZW5lcnNbaV0ubGlzdGVuZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBsZW5ndGggd2FzIDEgYW5kIHdlIHdhbnQgdG8gcmVtb3ZlIGxhc3QgZW50cnksIHNvIGRlbGV0ZSB0aGUgZXZlbnQgdHlwZSBmcm9tIG91ciBsaXN0ZW5lciBtYXBwaW5nIG5vdyFcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBoYWQgMisgbGlzdGVuZXJzLCBzbyBzdG9yZSBhcnJheSB3aXRob3V0IHRoaXMgZ2l2ZW4gbGlzdGVuZXJcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGZvdW5kSW5kZXgsIDEpOyAvLyBtb2RpZmllcyBpbiBwbGFjZSwgbm8gbmVlZCB0byBhc3NpZ24gdG8gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXVxuICAgICAgfSAvLyBEb24ndCBlbWl0IGlmIHRoZXJlJ3Mgbm8gbGlzdGVuZXJzIGZvciAncmVtb3ZlTGlzdGVuZXInIHR5cGUhXG5cblxuICAgICAgaWYgKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCBldmVudE5hbWUsIHVud3JhcHBlZExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcblxuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgZXZlbnRMaXN0ZW5lcnMuc2xpY2UoKSkge1xuICAgICAgLy8gbXVzdCBvcGVyYXRlIG9uIGNvcHkgYmVjYXVzZSBsaXN0ZW5lcnMgLGF5IGdldCByZW1vdmUgYXMgc2lkZS1lZmZlY3Qgb2YgY2FsbGluZ1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoICE9PSAwO1xuICB9XG5cbiAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuICB9XG5cbiAgZXZlbnROYW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgfHwge30pO1xuICB9XG5cbiAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gLy8gTmVlZCB0byBcInVud3JhcFwiIG9uY2Ugd3JhcHBlcnMhXG5cblxuICAgIGNvbnN0IHJhdyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgcmV0dXJuIHJhdy5tYXAobCA9PiBsLmxpc3RlbmVyIHx8IGwpOyAvLyBoZXJlIHdlIHVud3JhcCB0aGUgb25jZSB3cmFwcGVyIGlmIHRoZXJlIGlzIG9uZSBvciBmYWxsIGJhY2sgdG8gbGlzdGVuZXIgZnVuY3Rpb25cbiAgfVxuXG4gIHJhd0xpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW10pLnNsaWNlKDApOyAvLyByZXR1cm4gYSBjb3B5XG4gIH1cblxuICBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heExpc3RlbmVycyB8fCBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgfVxuXG4gIHNldE1heExpc3RlbmVycyhuKSB7XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjsgLy8gVE9ETzogVHlwZSBjaGVjayBuLCBtYWtlIHN1cmUgPj0gMCAobyBlcXVhbHMgbm8gbGltaXQpXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307IC8vIGluaXRpYWxpemUgaXRcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIGVtaXQhIHdlIGNhbiBqdXN0IHdpcGUhXG4gICAgICBpZiAoZXZlbnROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGV2ZXJ5IHR5cGUhXG4gICAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgc3BlY2lmaWMgdHlwZVxuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyB5dWNrLCB3ZSdsbCBoYXZlIHRvIGVtaXQgJ3JlbW92ZUxpc3RlbmVyJyBldmVudHMgYXMgd2UgZ29cblxuXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBSZW1vdmUgYWxsIHR5cGVzIChidXQgZG8gJ3JlbW92ZUxpc3RlbmVyJyBsYXN0ISlcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXModGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpLmZpbHRlcihuYW1lID0+IG5hbWUgIT09ICdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG5hbWUpKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVycyBmb3Igb25lIHR5cGUsIGJhY2sgdG8gZnJvbnQgKExhc3QtaW4sIGZpcnN0LW91dCwgZXhjZXB0IHdoZXJlIHByZXBlbmQgZi1lZCBpdCB1cClcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG5cbiAgICAgIGZvciAobGV0IGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgZXZlbnROYW1lKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcbn07XG5cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogQHBhcmFtICB7Kn0gYXJnIHBhc3NlZCBpbiBhcmd1bWVudCB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVuYW1lIGkuZS4gJ3N0cmluZycsICdGdW5jdGlvbicgKHZhbHVlIGlzIGNvbXBhcmVkIHRvIHR5cGVvZiBhZnRlciBsb3dlcmNhc2luZylcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50VHlwZShhcmcsIG5hbWUsIHR5cGVuYW1lKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuXG4gIGlmICh0eXBlICE9PSB0eXBlbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSAke3R5cGVuYW1lfS4gUmVjZWl2ZWQgdHlwZSAke3R5cGV9YCk7XG4gIH1cbn1cblxuY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiAnc3RhbmRhcmRpemVzJyB0aGUgcmVwb3J0ZWQgYXJjaGl0ZWN0dXJlcyB0byB0aGUgZXF1aXZhbGVudHMgcmVwb3J0ZWQgYnkgTm9kZS5qc1xuICogbm9kZSB2YWx1ZXM6ICdhcm0nLCAnYXJtNjQnLCAnaWEzMicsICdtaXBzJywgJ21pcHNlbCcsICdwcGMnLCAncHBjNjQnLCAnczM5MCcsICdzMzkweCcsICd4MzInLCBhbmQgJ3g2NCcuXG4gKiBpT1MgdmFsdWVzOiBcImFybTY0XCIsIFwiYXJtdjdcIiwgXCJ4ODZfNjRcIiwgXCJpMzg2XCIsIFwiVW5rbm93blwiXG4gKiBBbmRyb2lkIHZhbHVlczogXCJhcm1lYWJpXCIsIFwiYXJtZWFiaS12N2FcIiwgXCJhcm02NC12OGFcIiwgXCJ4ODZcIiwgXCJ4ODZfNjRcIiwgXCJtaXBzXCIsIFwibWlwczY0XCIsIFwidW5rbm93blwiXG4gKiBXaW5kb3dzIHZhbHVlczogXCJ4NjRcIiwgXCJpYTY0XCIsIFwiQVJNXCIsIFwieDg2XCIsIFwidW5rbm93blwiXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luYWwgb3JpZ2luYWwgYXJjaGl0ZWN0dXJlIHJlcG9ydGVkIGJ5IFRpLlBsYXRmb3JtXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHN0YW5kYXJkaXplQXJjaChvcmlnaW5hbCkge1xuICBzd2l0Y2ggKG9yaWdpbmFsKSB7XG4gICAgLy8gY29lcmNlICdhcm12NycsICdhcm1lYWJpJywgJ2FybWVhYmktdjdhJywgJ0FSTScgLT4gJ2FybSdcbiAgICAvLyAnYXJtZWFiaScgaXMgYSBkZWFkIEFCSSBmb3IgQW5kcm9pZCwgcmVtb3ZlZCBpbiBOREsgcjE3XG4gICAgY2FzZSAnYXJtdjcnOlxuICAgIGNhc2UgJ2FybWVhYmknOlxuICAgIGNhc2UgJ2FybWVhYmktdjdhJzpcbiAgICBjYXNlICdBUk0nOlxuICAgICAgcmV0dXJuICdhcm0nO1xuICAgIC8vIGNvZXJjZSAnYXJtNjQtdjhhJyAtPiAnYXJtNjQnXG5cbiAgICBjYXNlICdhcm02NC12OGEnOlxuICAgICAgcmV0dXJuICdhcm02NCc7XG4gICAgLy8gY29lcmNlICdpMzg2JywgJ3g4NicgLT4gJ2lhMzInXG5cbiAgICBjYXNlICdpMzg2JzpcbiAgICBjYXNlICd4ODYnOlxuICAgICAgcmV0dXJuICdpYTMyJztcbiAgICAvLyBjb2VyY2UgJ3g4Nl82NCcsICdpYTY0JywgJ3g2NCcgLT4gJ3g2NCdcblxuICAgIGNhc2UgJ3g4Nl82NCc6XG4gICAgY2FzZSAnaWE2NCc6XG4gICAgICByZXR1cm4gJ3g2NCc7XG4gICAgLy8gY29lcmNlICdtaXBzNjQnIC0+ICdtaXBzJyAvLyAnbWlwcycgYW5kICdtaXBzNjQnIGFyZSBkZWFkIEFCSXMgZm9yIEFuZHJvaWQsIHJlbW92ZWQgaW4gTkRLIHIxN1xuXG4gICAgY2FzZSAnbWlwczY0JzpcbiAgICAgIHJldHVybiAnbWlwcyc7XG4gICAgLy8gY29lcmNlICdVbmtub3duJyAtPiAndW5rbm93bidcblxuICAgIGNhc2UgJ1Vua25vd24nOlxuICAgICAgcmV0dXJuICd1bmtub3duJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbn1cblxuY29uc3QgcHJvY2VzcyQxID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5wcm9jZXNzJDEuYWJvcnQgPSAoKSA9PiB7fTsgLy8gVE9ETzogRG8gd2UgaGF2ZSBlcXVpdmFsZW50IG9mIGZvcmNpYmx5IGtpbGxpbmcgdGhlIHByb2Nlc3M/IFdlIGhhdmUgcmVzdGFydCwgYnV0IEkgdGhpbmsgd2UganVzdCB3YW50IGEgbm8tb3Agc3R1YiBoZXJlXG5cblxucHJvY2VzcyQxLmFyY2ggPSBzdGFuZGFyZGl6ZUFyY2goVGkuUGxhdGZvcm0uYXJjaGl0ZWN0dXJlKTtcbnByb2Nlc3MkMS5hcmd2ID0gW107IC8vIFRPRE86IFdoYXQgbWFrZXMgc2Vuc2UgaGVyZT8gcGF0aCB0byB0aXRhbml1bSBjbGkgZm9yIGZpcnN0IGFyZz8gcGF0aCB0byB0aS5tYWluL2FwcC5qcyBmb3Igc2Vjb25kP1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvY2VzcyQxLCAnYXJndjAnLCB7XG4gIHZhbHVlOiAnJyxcbiAgLy8gVE9ETzogUGF0aCB0byAuYXBwIG9uIGlPUz9cbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcblxucHJvY2VzcyQxLmJpbmRpbmcgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIHVuc3VwcG9ydGVkIGFuZCBub3QgdXNlci1mYWNpbmcgQVBJJyk7XG59O1xuXG5wcm9jZXNzJDEuY2hhbm5lbCA9IHVuZGVmaW5lZDtcblxucHJvY2VzcyQxLmNoZGlyID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgdW5zdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MkMS5jb25maWcgPSB7fTtcbnByb2Nlc3MkMS5jb25uZWN0ZWQgPSBmYWxzZTtcblxucHJvY2VzcyQxLmNwdVVzYWdlID0gKCkgPT4ge1xuICAvLyBGSVhNRTogQ2FuIHdlIGxvb2sgYXQgT1MuY3B1cyB0byBnZXQgdGhpcyBkYXRhP1xuICByZXR1cm4ge1xuICAgIHVzZXI6IDAsXG4gICAgc3lzdGVtOiAwXG4gIH07XG59O1xuXG5wcm9jZXNzJDEuY3dkID0gKCkgPT4gX19kaXJuYW1lO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvY2VzcyQxLCAnZGVidWdQb3J0Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgdmFsdWUgPSAwOyAvLyBkZWZhdWx0IHRvIDBcblxuICAgIHRyeSB7XG4gICAgICBpZiAoXCJhbmRyb2lkXCIgPT09ICdhbmRyb2lkJykge1xuICAgICAgICBjb25zdCBhc3NldHMgPSBrcm9sbC5iaW5kaW5nKCdhc3NldHMnKTtcbiAgICAgICAgY29uc3QganNvbiA9IGFzc2V0cy5yZWFkQXNzZXQoJ2RlcGxveS5qc29uJyk7XG5cbiAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICBjb25zdCBkZXBsb3lEYXRhID0gSlNPTi5wYXJzZShqc29uKTtcblxuICAgICAgICAgIGlmIChkZXBsb3lEYXRhLmRlYnVnZ2VyUG9ydCAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIC0xIG1lYW5zIG5vdCBzZXQgKG5vdCBpbiBkZWJ1ZyBtb2RlKVxuICAgICAgICAgICAgdmFsdWUgPSBkZXBsb3lEYXRhLmRlYnVnZ2VyUG9ydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge30gLy8gaWdub3JlXG4gICAgLy8gb3ZlcndyaXRlIHRoaXMgZ2V0dGVyIHdpdGggc3RhdGljIHZhbHVlXG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVidWdQb3J0Jywge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5wcm9jZXNzJDEuZGlzY29ubmVjdCA9ICgpID0+IHt9OyAvLyBuby1vcFxuXG5cbnByb2Nlc3MkMS5kbG9wZW4gPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5kbG9wZW4gaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2VzcyQxLmVtaXRXYXJuaW5nID0gZnVuY3Rpb24gKHdhcm5pbmcsIG9wdGlvbnMsIGNvZGUsIGN0b3IpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBsZXQgdHlwZTtcbiAgbGV0IGRldGFpbDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgdHlwZSA9IG9wdGlvbnM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICBjb2RlID0gb3B0aW9ucy5jb2RlO1xuICAgIGRldGFpbCA9IG9wdGlvbnMuZGV0YWlsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3YXJuaW5nID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IG1ha2UgdXNlIG9mIGBjdG9yYCBhcmcgZm9yIGxpbWl0aW5nIHN0YWNrIHRyYWNlcz8gQ2FuIG9ubHkgcmVhbGx5IGJlIHVzZWQgb24gVjhcbiAgICAvLyBzZXQgc3RhY2sgdHJhY2UgbGltaXQgdG8gMCwgdGhlbiBjYWxsIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHdhcm5pbmcsIGN0b3IpO1xuICAgIHdhcm5pbmcgPSBuZXcgRXJyb3Iod2FybmluZyk7XG4gICAgd2FybmluZy5uYW1lID0gdHlwZSB8fCAnV2FybmluZyc7XG5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuaW5nLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChkZXRhaWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybmluZy5kZXRhaWwgPSBkZXRhaWw7XG4gICAgfVxuICB9IC8vIFRPRE86IFRocm93IFR5cGVFcnJvciBpZiBub3QgYW4gaW5zdGFuY2VvZiBFcnJvciBhdCB0aGlzIHBvaW50IVxuXG5cbiAgY29uc3QgaXNEZXByZWNhdGlvbiA9IHdhcm5pbmcubmFtZSA9PT0gJ0RlcHJlY2F0aW9uV2FybmluZyc7XG5cbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQxLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm47IC8vIGlnbm9yZVxuICB9XG5cbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQxLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICB0aHJvdyB3YXJuaW5nO1xuICB9XG5cbiAgdGhpcy5lbWl0KCd3YXJuaW5nJywgd2FybmluZyk7XG59O1xuXG5mdW5jdGlvbiBsb2FkRW52SnNvbigpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBqc29uRmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShUaS5GaWxlc3lzdGVtLnJlc291cmNlc0RpcmVjdG9yeSwgJ19lbnZfLmpzb24nKTtcblxuICAgIGlmIChqc29uRmlsZS5leGlzdHMoKSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbkZpbGUucmVhZCgpLnRleHQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBUaS5BUEkuZXJyb3IoYEZhaWxlZCB0byByZWFkIFwiX2Vudl8uanNvblwiLiBSZWFzb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxuXG4gIHJldHVybiB7fTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb2Nlc3MkMSwgJ2VudicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgZGVsZXRlIHRoaXMuZW52O1xuICAgIHJldHVybiB0aGlzLmVudiA9IGxvYWRFbnZKc29uKCk7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5wcm9jZXNzJDEuZXhlY0FyZ3YgPSBbXTtcbnByb2Nlc3MkMS5leGVjUGF0aCA9ICcnOyAvLyBGSVhNRTogV2hhdCBtYWtlcyBzZW5zZSBoZXJlPyBQYXRoIHRvIHRpdGFuaXVtIENMSSBoZXJlP1xuXG5wcm9jZXNzJDEuZXhpdCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmV4aXQgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2VzcyQxLmV4aXRDb2RlID0gdW5kZWZpbmVkO1xucHJvY2VzcyQxLm5vRGVwcmVjYXRpb24gPSBmYWxzZTtcbnByb2Nlc3MkMS5waWQgPSAwOyAvLyBGSVhNRTogU2hvdWxkIHdlIHRyeSBhbmQgYWRvcHQgJ2lwYWQnLydpcGhvbmUnIHRvICdkYXJ3aW4nPyBvciAnaW9zJz9cblxucHJvY2VzcyQxLnBsYXRmb3JtID0gXCJhbmRyb2lkXCI7XG5wcm9jZXNzJDEucHBpZCA9IDA7IC8vIFRPRE86IEFkZCByZWxlYXNlIHByb3BlcnR5IChPYmplY3QpXG4vLyBUT0RPOiBDYW4gd2UgZXhwb3NlIHN0ZG91dC9zdGRlcnIvc3RkaW4gbmF0aXZlbHk/XG4vLyBEb24ndCB3cmFwIGNvbnNvbGUubG9nL2Vycm9yIGJlY2F1c2UgdGVjaG5pY2FsbHkgZ2xvYmFsIGNvbnNvbGUgd3JhcHMgcHJvY2Vzcy5zdGRvdXQvc3RkZXJyIChvciBzaG91bGQpXG5cbnByb2Nlc3MkMS5zdGRlcnIgPSB7XG4gIGlzVFRZOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHdyaXRlOiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgIFRpLkFQSS5lcnJvcihjaHVuayk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5wcm9jZXNzJDEuc3Rkb3V0ID0ge1xuICBpc1RUWTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB3cml0ZTogKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spID0+IHtcbiAgICBUaS5BUEkuaW5mbyhjaHVuayk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5wcm9jZXNzJDEudGl0bGUgPSBUaS5BcHAubmFtZTtcbnByb2Nlc3MkMS50aHJvd0RlcHJlY2F0aW9uID0gZmFsc2U7XG5wcm9jZXNzJDEudHJhY2VEZXByZWNhdGlvbiA9IGZhbHNlO1xuXG5wcm9jZXNzJDEudW1hc2sgPSAoKSA9PiAwOyAvLyBqdXN0IGFsd2F5cyByZXR1cm4gMFxuXG5cbnByb2Nlc3MkMS51cHRpbWUgPSAoKSA9PiB7XG4gIGNvbnN0IGRpZmZNcyA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gIHJldHVybiBkaWZmTXMgLyAxMDAwLjA7IC8vIGNvbnZlcnQgdG8gXCJzZWNvbmRzXCIgd2l0aCBmcmFjdGlvbnNcbn07XG5cbnByb2Nlc3MkMS52ZXJzaW9uID0gXCIxMC4wLjBcIjtcbnByb2Nlc3MkMS52ZXJzaW9ucyA9IHtcbiAgbW9kdWxlczogJycsXG4gIC8vIFRPRE86IFJlcG9ydCBtb2R1bGUgYXBpIHZlcnNpb24gKGZvciBjdXJyZW50IHBsYXRmb3JtISlcbiAgdjg6ICcnLFxuICAvLyBUT0RPOiByZXBvcnQgYW5kcm9pZCdzIHY4IHZlcnNpb24gKGlmIG9uIEFuZHJvaWQhKVxuICBqc2M6ICcnIC8vIFRPRE86IHJlcG9ydCBqYXZhc2NyaXB0Y29yZSB2ZXJzaW9uIGZvciBpT1MvV0luZG93cz9cbiAgLy8gVE9ETzogUmVwb3J0IGlvcy9BbmRyb2lkL1dpbmRvd3MgcGxhdGZvcm0gdmVyc2lvbnM/XG5cbn07XG5wcm9jZXNzJDFbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdwcm9jZXNzJztcbmdsb2JhbC5wcm9jZXNzID0gcHJvY2VzcyQxOyAvLyBoYW5kbGUgc3BpdHRpbmcgb3V0IHdhcm5pbmdzXG5cbmNvbnN0IFdBUk5JTkdfUFJFRklYID0gYCh0aXRhbml1bToke3Byb2Nlc3MkMS5waWR9KSBgO1xucHJvY2VzcyQxLm9uKCd3YXJuaW5nJywgd2FybmluZyA9PiB7XG4gIGNvbnN0IGlzRGVwcmVjYXRpb24gPSB3YXJuaW5nLm5hbWUgPT09ICdEZXByZWNhdGlvbldhcm5pbmcnOyAvLyBpZiB3ZSdyZSBub3QgZG9pbmcgZGVwcmVjYXRpb25zLCBpZ25vcmUhXG5cbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQxLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVE9ETzogQ2hlY2sgcHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uIGFuZCBpZiBzZXQsIGluY2x1ZGUgc3RhY2sgdHJhY2UgaW4gbWVzc2FnZSFcblxuXG4gIGxldCBtc2cgPSBXQVJOSU5HX1BSRUZJWDtcblxuICBpZiAod2FybmluZy5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtc2cgKz0gYFske3dhcm5pbmcuY29kZX1dIGA7XG4gIH1cblxuICBpZiAod2FybmluZy50b1N0cmluZykge1xuICAgIG1zZyArPSB3YXJuaW5nLnRvU3RyaW5nKCk7XG4gIH1cblxuICBpZiAod2FybmluZy5kZXRhaWwpIHtcbiAgICBtc2cgKz0gYFxcbiR7d2FybmluZy5kZXRhaWx9YDtcbiAgfVxuXG4gIGNvbnNvbGUuZXJyb3IobXNnKTtcbn0pO1xubGV0IHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuXG5wcm9jZXNzJDEuaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2sgPSAoKSA9PiB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrICE9PSBudWxsO1xuXG5wcm9jZXNzJDEuc2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2sgPSBmbiA9PiB7XG4gIGlmIChmbiA9PT0gbnVsbCkge1xuICAgIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydEFyZ3VtZW50VHlwZShmbiwgJ2ZuJywgJ2Z1bmN0aW9uJyk7XG5cbiAgaWYgKHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9jZXNzLnNldFVuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrKClgIHdhcyBjYWxsZWQgd2hpbGUgYSBjYXB0dXJlIGNhbGxiYWNrIHdhcyBhbHJlYWR5IGFjdGl2ZScpO1xuICB9XG5cbiAgdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayA9IGZuO1xufTtcblxuVGkuQXBwLmFkZEV2ZW50TGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIENyZWF0ZSBhbiBFcnJvciBpbnN0YW5jZSB0aGF0IHdyYXBzIHRoZSBkYXRhIGZyb20gdGhlIGV2ZW50XG4gIC8vIGlkZWFsbHkgd2UnZCBqdXN0IGZvcndhcmQgYWxvbmcgdGhlIG9yaWdpbmFsIEVycm9yIVxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihldmVudC5tZXNzYWdlKTtcbiAgZXJyb3Iuc3RhY2sgPSBldmVudC5iYWNrdHJhY2U7XG4gIGVycm9yLmZpbGVOYW1lID0gZXZlbnQuc291cmNlTmFtZTtcbiAgZXJyb3IubGluZU51bWJlciA9IGV2ZW50LmxpbmU7XG4gIGVycm9yLmNvbHVtbk51bWJlciA9IGV2ZW50LmxpbmVPZmZzZXQ7XG5cbiAgaWYgKHByb2Nlc3MkMS5oYXNVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjaygpKSB7XG4gICAgcmV0dXJuIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2soZXJyb3IpO1xuICB9IC8vIG90aGVyd2lzZSBmb3J3YXJkIHRoZSBldmVudCFcblxuXG4gIHByb2Nlc3MkMS5lbWl0KCd1bmNhdWdodEV4Y2VwdGlvbicsIGVycm9yKTtcbn0pO1xuLy8gSlMgZW5naW5lIHNob3VsZCBiZSBhYmxlIHRvIG9wdGltaXplIGVhc2llclxuXG5jbGFzcyBDYWxsYmFja1dpdGhBcmdzIHtcbiAgY29uc3RydWN0b3IoZnVuYywgYXJncykge1xuICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuXG4gIHJ1bigpIHtcbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICB0aGlzLmZ1bmMuYXBwbHkobnVsbCwgdGhpcy5hcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mdW4oKTtcbiAgICB9XG4gIH1cblxufSAvLyBuZXh0VGljayB2cyBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIGhhbmRsZWQgaW4gYSBzZW1pLXNtYXJ0IHdheVxuLy8gQmFzaWNhbGx5IG5leHRUaWNrIG5lZWRzIHRvIGRyYWluIHRoZSBmdWxsIHF1ZXVlIChhbmQgY2FuIGNhdXNlIGluZmluaXRlIGxvb3BzIGlmIG5leHRUaWNrIGNhbGxiYWNrIGNhbGxzIG5leHRUaWNrISlcbi8vIFRoZW4gd2Ugc2hvdWxkIGdvIHRocm91Z2ggdGhlIFwiaW1tZWRpYXRlXCIgcXVldWVcbi8vIGh0dHA6Ly9wbGFmZXIuZ2l0aHViLmlvLzIwMTUvMDkvMDgvbmV4dFRpY2stdnMtc2V0SW1tZWRpYXRlL1xuXG5cbmNvbnN0IHRpY2tRdWV1ZSA9IFtdO1xuY29uc3QgaW1tZWRpYXRlUXVldWUgPSBbXTtcbmxldCBkcmFpbmluZ1RpY2tRdWV1ZSA9IGZhbHNlO1xubGV0IGRyYWluUXVldWVzVGltZW91dCA9IG51bGw7XG4vKipcbiAqIEl0ZXJhdGl2ZWx5IHJ1bnMgYWxsIFwidGlja3NcIiB1bnRpbCB0aGVyZSBhcmUgbm8gbW9yZS5cbiAqIFRoaXMgY2FuIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbiBpZiBhIHRpY2sgc2NoZWR1bGVzIGFub3RoZXIgZm9yZXZlci5cbiAqL1xuXG5mdW5jdGlvbiBkcmFpblRpY2tRdWV1ZSgpIHtcbiAgaWYgKGRyYWluaW5nVGlja1F1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZHJhaW5pbmdUaWNrUXVldWUgPSB0cnVlO1xuXG4gIHdoaWxlICh0aWNrUXVldWUubGVuZ3RoKSB7XG4gICAgY29uc3QgdGljayA9IHRpY2tRdWV1ZS5zaGlmdCgpO1xuICAgIHRpY2sucnVuKCk7XG4gIH1cblxuICBkcmFpbmluZ1RpY2tRdWV1ZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlcygpIHtcbiAgLy8gZHJhaW4gdGhlIGZ1bGwgdGljayBxdWV1ZSBmaXJzdC4uLlxuICBkcmFpblRpY2tRdWV1ZSgpOyAvLyB0aWNrIHF1ZXVlIHNob3VsZCBiZSBlbXB0eSFcblxuICBjb25zdCBpbW1lZGlhdGVzUmVtYWluaW5nID0gcHJvY2Vzc0ltbWVkaWF0ZVF1ZXVlKCk7XG5cbiAgaWYgKGltbWVkaWF0ZXNSZW1haW5pbmcgIT09IDApIHtcbiAgICAvLyByZS1zY2hlZHVsZSBkcmFpbmluZyBvdXIgcXVldWVzLCBhcyB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBtb3JlIFwiaW1tZWRpYXRlXCIgdG8gaGFuZGxlXG4gICAgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gc2V0VGltZW91dChkcmFpblF1ZXVlcywgMCk7XG4gIH0gZWxzZSB7XG4gICAgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBwcm9jZXNzIFwiaW1tZWRpYXRlc1wiIChpbiBhIG11Y2ggbW9yZSBsZWlzdXJlbHkgd2F5IHRoYW4gdGlja3MpXG4gKiBXZSBnaXZlIGEgMTAwbXMgd2luZG93IHRvIHJ1biB0aGVtIGluIGJlZm9yZSByZS1zY2hlZHVsaW5nIHRoZSB0aW1lb3V0IHRvIHByb2Nlc3MgdGhlbSBhZ2Fpbi5cbiAqIElmIGFueSB0aWNrcyBhcmUgYWRkZWQgZHVyaW5nIGludm9jYXRpb24gb2YgaW1tZWRpYXRlLCB3ZSBkcmFpbiB0aGUgdGljayBxdWV1ZSBmdWxseSBiZWZvcmVcbiAqIHByb2NlZWRpbmcgdG8gbmV4dCBpbW1lZGlhdGUgKGlmIHdlIHN0aWxsIGhhdmUgdGltZSBpbiBvdXIgd2luZG93KS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IG51bWJlciBvZiByZW1haW5pbmcgaW1tZWRpYXRlcyB0byBiZSBwcm9jZXNzZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NJbW1lZGlhdGVRdWV1ZSgpIHtcbiAgY29uc3QgaW1tZWRpYXRlRGVhZGxpbmUgPSBEYXRlLm5vdygpICsgMTAwOyAvLyBnaXZlIHVzIHVwIHRvIDEwMG1zIHRvIHByb2Nlc3MgaW1tZWRpYXRlc1xuXG4gIHdoaWxlIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGggJiYgRGF0ZS5ub3coKSA8IGltbWVkaWF0ZURlYWRsaW5lKSB7XG4gICAgY29uc3QgaW1tZWRpYXRlID0gaW1tZWRpYXRlUXVldWUuc2hpZnQoKTtcbiAgICBpbW1lZGlhdGUucnVuKCk7XG5cbiAgICBpZiAodGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHRoZXkgYWRkZWQgYSB0aWNrISBkcmFpbiB0aGUgdGljayBxdWV1ZSBiZWZvcmUgd2UgZG8gYW55dGhpbmcgZWxzZSAodGhpcyAqbWF5KiBlYXQgdXAgb3VyIGRlYWRsaW5lL3dpbmRvdyB0byBwcm9jZXNzIGFueSBtb3JlIGltbWVkaWF0ZXMpXG4gICAgICBkcmFpblRpY2tRdWV1ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbW1lZGlhdGVRdWV1ZS5sZW5ndGg7XG59XG5cbnByb2Nlc3MkMS5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgLi4uYXJncykge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY2FsbGJhY2ssICdjYWxsYmFjaycsICdmdW5jdGlvbicpO1xuICB0aWNrUXVldWUucHVzaChuZXcgQ2FsbGJhY2tXaXRoQXJncyhjYWxsYmFjaywgYXJncykpO1xuXG4gIGlmICghZHJhaW5RdWV1ZXNUaW1lb3V0KSB7XG4gICAgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gc2V0VGltZW91dChkcmFpblF1ZXVlcywgMCk7XG4gIH1cbn07XG5cbmdsb2JhbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGNhbGxiYWNrLCAnY2FsbGJhY2snLCAnZnVuY3Rpb24nKTtcbiAgY29uc3QgaW1tZWRpYXRlID0gbmV3IENhbGxiYWNrV2l0aEFyZ3MoY2FsbGJhY2ssIGFyZ3MpO1xuICBpbW1lZGlhdGVRdWV1ZS5wdXNoKGltbWVkaWF0ZSk7XG5cbiAgaWYgKCFkcmFpblF1ZXVlc1RpbWVvdXQpIHtcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRyYWluUXVldWVzLCAwKTtcbiAgfVxuXG4gIHJldHVybiBpbW1lZGlhdGU7XG59O1xuXG5nbG9iYWwuY2xlYXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIGNvbnN0IGluZGV4ID0gaW1tZWRpYXRlUXVldWUuaW5kZXhPZihpbW1lZGlhdGUpO1xuXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBpbW1lZGlhdGVRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG5jb25zdCBGT1JXQVJEX1NMQVNIID0gNDc7IC8vICcvJ1xuXG5jb25zdCBCQUNLV0FSRF9TTEFTSCA9IDkyOyAvLyAnXFxcXCdcblxuLyoqXG4gKiBJcyB0aGlzIFthLXpBLVpdP1xuICogQHBhcmFtICB7bnVtYmVyfSAgY2hhckNvZGUgdmFsdWUgZnJvbSBTdHJpbmcuY2hhckNvZGVBdCgpXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuZnVuY3Rpb24gaXNXaW5kb3dzRGV2aWNlTmFtZShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gOTAgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTIyO1xufVxuLyoqXG4gKiBbaXNBYnNvbHV0ZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IGlzUG9zaXggd2hldGhlciB0aGlzIGltcGwgaXMgZm9yIFBPU0lYIG9yIG5vdFxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gaXNBYnNvbHV0ZShpc1Bvc2l4LCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBjb25zdCBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7IC8vIGVtcHR5IHN0cmluZyBzcGVjaWFsIGNhc2VcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGFyID0gZmlsZXBhdGguY2hhckNvZGVBdCgwKTtcblxuICBpZiAoZmlyc3RDaGFyID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gd2UgYWxyZWFkeSBkaWQgb3VyIGNoZWNrcyBmb3IgcG9zaXhcblxuXG4gIGlmIChpc1Bvc2l4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIHdpbjMyIGZyb20gaGVyZSBvbiBvdXRcblxuXG4gIGlmIChmaXJzdENoYXIgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobGVuZ3RoID4gMiAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKGZpcnN0Q2hhcikgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICBjb25zdCB0aGlyZENoYXIgPSBmaWxlcGF0aC5jaGFyQXQoMik7XG4gICAgcmV0dXJuIHRoaXJkQ2hhciA9PT0gJy8nIHx8IHRoaXJkQ2hhciA9PT0gJ1xcXFwnO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBbZGlybmFtZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yICBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpcm5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBjb25zdCBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnLic7XG4gIH0gLy8gaWdub3JlIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgbGV0IGZyb21JbmRleCA9IGxlbmd0aCAtIDE7XG4gIGNvbnN0IGhhZFRyYWlsaW5nID0gZmlsZXBhdGguZW5kc1dpdGgoc2VwYXJhdG9yKTtcblxuICBpZiAoaGFkVHJhaWxpbmcpIHtcbiAgICBmcm9tSW5kZXgtLTtcbiAgfVxuXG4gIGNvbnN0IGZvdW5kSW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZihzZXBhcmF0b3IsIGZyb21JbmRleCk7IC8vIG5vIHNlcGFyYXRvcnNcblxuICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIHtcbiAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIHJvb3Qgd2luZG93cyBwYXRoc1xuICAgIGlmIChsZW5ndGggPj0gMiAmJiBzZXBhcmF0b3IgPT09ICdcXFxcJyAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICc6Jykge1xuICAgICAgY29uc3QgZmlyc3RDaGFyID0gZmlsZXBhdGguY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyKSkge1xuICAgICAgICByZXR1cm4gZmlsZXBhdGg7IC8vIGl0J3MgYSByb290IHdpbmRvd3MgcGF0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnLic7XG4gIH0gLy8gb25seSBmb3VuZCByb290IHNlcGFyYXRvclxuXG5cbiAgaWYgKGZvdW5kSW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gc2VwYXJhdG9yOyAvLyBpZiBpdCB3YXMgJy8nLCByZXR1cm4gdGhhdFxuICB9IC8vIEhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgJy8vc29tZXRoaW5nJ1xuXG5cbiAgaWYgKGZvdW5kSW5kZXggPT09IDEgJiYgc2VwYXJhdG9yID09PSAnLycgJiYgZmlsZXBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gJy8vJztcbiAgfVxuXG4gIHJldHVybiBmaWxlcGF0aC5zbGljZSgwLCBmb3VuZEluZGV4KTtcbn1cbi8qKlxuICogW2V4dG5hbWUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBleHRuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgY29uc3QgaW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gLy8gaWdub3JlIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgbGV0IGVuZEluZGV4ID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpKSB7XG4gICAgZW5kSW5kZXgtLTtcbiAgfVxuXG4gIHJldHVybiBmaWxlcGF0aC5zbGljZShpbmRleCwgZW5kSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBsYXN0SW5kZXhXaW4zMlNlcGFyYXRvcihmaWxlcGF0aCwgaW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IGluZGV4OyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGNoYXIgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGNoYXIgPT09IEJBQ0tXQVJEX1NMQVNIIHx8IGNoYXIgPT09IEZPUldBUkRfU0xBU0gpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbi8qKlxuICogW2Jhc2VuYW1lIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtleHRdICAgICAgZmlsZSBleHRlbnNpb24gdG8gZHJvcCBpZiBpdCBleGlzdHNcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBiYXNlbmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoLCBleHQpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcblxuICBpZiAoZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnRBcmd1bWVudFR5cGUoZXh0LCAnZXh0JywgJ3N0cmluZycpO1xuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBpc1Bvc2l4ID0gc2VwYXJhdG9yID09PSAnLyc7XG4gIGxldCBlbmRJbmRleCA9IGxlbmd0aDsgLy8gZHJvcCB0cmFpbGluZyBzZXBhcmF0b3IgKGlmIHRoZXJlIGlzIG9uZSlcblxuICBjb25zdCBsYXN0Q2hhckNvZGUgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpO1xuXG4gIGlmIChsYXN0Q2hhckNvZGUgPT09IEZPUldBUkRfU0xBU0ggfHwgIWlzUG9zaXggJiYgbGFzdENoYXJDb2RlID09PSBCQUNLV0FSRF9TTEFTSCkge1xuICAgIGVuZEluZGV4LS07XG4gIH0gLy8gRmluZCBsYXN0IG9jY3VyZW5jZSBvZiBzZXBhcmF0b3JcblxuXG4gIGxldCBsYXN0SW5kZXggPSAtMTtcblxuICBpZiAoaXNQb3NpeCkge1xuICAgIGxhc3RJbmRleCA9IGZpbGVwYXRoLmxhc3RJbmRleE9mKHNlcGFyYXRvciwgZW5kSW5kZXggLSAxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbiB3aW4zMiwgaGFuZGxlICplaXRoZXIqIHNlcGFyYXRvciFcbiAgICBsYXN0SW5kZXggPSBsYXN0SW5kZXhXaW4zMlNlcGFyYXRvcihmaWxlcGF0aCwgZW5kSW5kZXggLSAxKTsgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiByb290IHBhdGggbGlrZSAnQzonIG9yICdDOlxcXFwnXG5cbiAgICBpZiAoKGxhc3RJbmRleCA9PT0gMiB8fCBsYXN0SW5kZXggPT09IC0xKSAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICc6JyAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKGZpbGVwYXRoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9IC8vIFRha2UgZnJvbSBsYXN0IG9jY3VycmVuY2Ugb2Ygc2VwYXJhdG9yIHRvIGVuZCBvZiBzdHJpbmcgKG9yIGJlZ2lubmluZyB0byBlbmQgaWYgbm90IGZvdW5kKVxuXG5cbiAgY29uc3QgYmFzZSA9IGZpbGVwYXRoLnNsaWNlKGxhc3RJbmRleCArIDEsIGVuZEluZGV4KTsgLy8gZHJvcCB0cmFpbGluZyBleHRlbnNpb24gKGlmIHNwZWNpZmllZClcblxuICBpZiAoZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHJldHVybiBiYXNlLmVuZHNXaXRoKGV4dCkgPyBiYXNlLnNsaWNlKDAsIGJhc2UubGVuZ3RoIC0gZXh0Lmxlbmd0aCkgOiBiYXNlO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgubm9ybWFsaXplKClgIG1ldGhvZCBub3JtYWxpemVzIHRoZSBnaXZlbiBwYXRoLCByZXNvbHZpbmcgJy4uJyBhbmQgJy4nIHNlZ21lbnRzLlxuICpcbiAqIFdoZW4gbXVsdGlwbGUsIHNlcXVlbnRpYWwgcGF0aCBzZWdtZW50IHNlcGFyYXRpb24gY2hhcmFjdGVycyBhcmUgZm91bmQgKGUuZy5cbiAqIC8gb24gUE9TSVggYW5kIGVpdGhlciBcXCBvciAvIG9uIFdpbmRvd3MpLCB0aGV5IGFyZSByZXBsYWNlZCBieSBhIHNpbmdsZVxuICogaW5zdGFuY2Ugb2YgdGhlIHBsYXRmb3JtLXNwZWNpZmljIHBhdGggc2VnbWVudCBzZXBhcmF0b3IgKC8gb24gUE9TSVggYW5kIFxcXG4gKiBvbiBXaW5kb3dzKS4gVHJhaWxpbmcgc2VwYXJhdG9ycyBhcmUgcHJlc2VydmVkLlxuICpcbiAqIElmIHRoZSBwYXRoIGlzIGEgemVyby1sZW5ndGggc3RyaW5nLCAnLicgaXMgcmV0dXJuZWQsIHJlcHJlc2VudGluZyB0aGVcbiAqIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcblxuICBpZiAoZmlsZXBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcuJztcbiAgfSAvLyBXaW5kb3dzIGNhbiBoYW5kbGUgJy8nIG9yICdcXFxcJyBhbmQgYm90aCBzaG91bGQgYmUgdHVybmVkIGludG8gc2VwYXJhdG9yXG5cblxuICBjb25zdCBpc1dpbmRvd3MgPSBzZXBhcmF0b3IgPT09ICdcXFxcJztcblxuICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgZmlsZXBhdGggPSBmaWxlcGF0aC5yZXBsYWNlKC9cXC8vZywgc2VwYXJhdG9yKTtcbiAgfVxuXG4gIGNvbnN0IGhhZExlYWRpbmcgPSBmaWxlcGF0aC5zdGFydHNXaXRoKHNlcGFyYXRvcik7IC8vIE9uIFdpbmRvd3MsIG5lZWQgdG8gaGFuZGxlIFVOQyBwYXRocyAoXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFxkaXIpIHNwZWNpYWwgdG8gcmV0YWluIGxlYWRpbmcgZG91YmxlIGJhY2tzbGFzaFxuXG4gIGNvbnN0IGlzVU5DID0gaGFkTGVhZGluZyAmJiBpc1dpbmRvd3MgJiYgZmlsZXBhdGgubGVuZ3RoID4gMiAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICdcXFxcJztcbiAgY29uc3QgaGFkVHJhaWxpbmcgPSBmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpO1xuICBjb25zdCBwYXJ0cyA9IGZpbGVwYXRoLnNwbGl0KHNlcGFyYXRvcik7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXJ0cykge1xuICAgIGlmIChzZWdtZW50Lmxlbmd0aCAhPT0gMCAmJiBzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICAgIHJlc3VsdC5wb3AoKTsgLy8gRklYTUU6IFdoYXQgaWYgdGhpcyBnb2VzIGFib3ZlIHJvb3Q/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBub3JtYWxpemVkID0gaGFkTGVhZGluZyA/IHNlcGFyYXRvciA6ICcnO1xuICBub3JtYWxpemVkICs9IHJlc3VsdC5qb2luKHNlcGFyYXRvcik7XG5cbiAgaWYgKGhhZFRyYWlsaW5nKSB7XG4gICAgbm9ybWFsaXplZCArPSBzZXBhcmF0b3I7XG4gIH1cblxuICBpZiAoaXNVTkMpIHtcbiAgICBub3JtYWxpemVkID0gJ1xcXFwnICsgbm9ybWFsaXplZDtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuLyoqXG4gKiBbYXNzZXJ0U2VnbWVudCBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAgeyp9IHNlZ21lbnQgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7dm9pZH0gICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRTZWdtZW50KHNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJHtzZWdtZW50fWApO1xuICB9XG59XG4vKipcbiAqIFRoZSBgcGF0aC5qb2luKClgIG1ldGhvZCBqb2lucyBhbGwgZ2l2ZW4gcGF0aCBzZWdtZW50cyB0b2dldGhlciB1c2luZyB0aGVcbiAqIHBsYXRmb3JtLXNwZWNpZmljIHNlcGFyYXRvciBhcyBhIGRlbGltaXRlciwgdGhlbiBub3JtYWxpemVzIHRoZSByZXN1bHRpbmcgcGF0aC5cbiAqIFplcm8tbGVuZ3RoIHBhdGggc2VnbWVudHMgYXJlIGlnbm9yZWQuIElmIHRoZSBqb2luZWQgcGF0aCBzdHJpbmcgaXMgYSB6ZXJvLVxuICogbGVuZ3RoIHN0cmluZyB0aGVuICcuJyB3aWxsIGJlIHJldHVybmVkLCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nW119IHBhdGhzIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgVGhlIGpvaW5lZCBmaWxlcGF0aFxuICovXG5cblxuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IsIHBhdGhzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdOyAvLyBuYWl2ZSBpbXBsOiBqdXN0IGpvaW4gYWxsIHRoZSBwYXRocyB3aXRoIHNlcGFyYXRvclxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRocykge1xuICAgIGFzc2VydFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUoc2VwYXJhdG9yLCByZXN1bHQuam9pbihzZXBhcmF0b3IpKTtcbn1cbi8qKlxuICogVGhlIGBwYXRoLnJlc29sdmUoKWAgbWV0aG9kIHJlc29sdmVzIGEgc2VxdWVuY2Ugb2YgcGF0aHMgb3IgcGF0aCBzZWdtZW50cyBpbnRvIGFuIGFic29sdXRlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ1tdfSBwYXRocyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmUoc2VwYXJhdG9yLCBwYXRocykge1xuICBsZXQgcmVzb2x2ZWQgPSAnJztcbiAgbGV0IGhpdFJvb3QgPSBmYWxzZTtcbiAgY29uc3QgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nOyAvLyBnbyBmcm9tIHJpZ2h0IHRvIGxlZnQgdW50aWwgd2UgaGl0IGFic29sdXRlIHBhdGgvcm9vdFxuXG4gIGZvciAobGV0IGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoc1tpXTtcbiAgICBhc3NlcnRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTsgLy8gc2tpcCBlbXB0eVxuICAgIH1cblxuICAgIHJlc29sdmVkID0gc2VnbWVudCArIHNlcGFyYXRvciArIHJlc29sdmVkOyAvLyBwcmVwZW5kIG5ldyBzZWdtZW50XG5cbiAgICBpZiAoaXNBYnNvbHV0ZShpc1Bvc2l4LCBzZWdtZW50KSkge1xuICAgICAgLy8gaGF2ZSB3ZSBiYWNrZWQgaW50byBhbiBhYnNvbHV0ZSBwYXRoP1xuICAgICAgaGl0Um9vdCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gaWYgd2UgZGlkbid0IGhpdCByb290LCBwcmVwZW5kIGN3ZFxuXG5cbiAgaWYgKCFoaXRSb290KSB7XG4gICAgcmVzb2x2ZWQgPSAoZ2xvYmFsLnByb2Nlc3MgPyBwcm9jZXNzLmN3ZCgpIDogJy8nKSArIHNlcGFyYXRvciArIHJlc29sdmVkO1xuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShzZXBhcmF0b3IsIHJlc29sdmVkKTtcblxuICBpZiAobm9ybWFsaXplZC5jaGFyQXQobm9ybWFsaXplZC5sZW5ndGggLSAxKSA9PT0gc2VwYXJhdG9yKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgb24gV2luZG93cyBhcyB3ZWxsLCBzbyB3ZSBkb24ndCB0cmltIHRyYWlsaW5nIHNlcGFyYXRvciBvbiBzb21ldGhpbmcgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcJ1xuICAgIC8vIERvbid0IHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3IgaWYgdGhpcyBpcyByb290IHBhdGggb24gd2luZG93cyFcbiAgICBpZiAoIWlzUG9zaXggJiYgbm9ybWFsaXplZC5sZW5ndGggPT09IDMgJiYgbm9ybWFsaXplZC5jaGFyQXQoMSkgPT09ICc6JyAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKG5vcm1hbGl6ZWQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH0gLy8gb3RoZXJ3aXNlIHRyaW0gdHJhaWxpbmcgc2VwYXJhdG9yXG5cblxuICAgIHJldHVybiBub3JtYWxpemVkLnNsaWNlKDAsIG5vcm1hbGl6ZWQubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxuICogVGhlIGBwYXRoLnJlbGF0aXZlKClgIG1ldGhvZCByZXR1cm5zIHRoZSByZWxhdGl2ZSBwYXRoIGBmcm9tYCBmcm9tIHRvIGB0b2AgYmFzZWRcbiAqIG9uIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBJZiBmcm9tIGFuZCB0byBlYWNoIHJlc29sdmUgdG8gdGhlIHNhbWVcbiAqIHBhdGggKGFmdGVyIGNhbGxpbmcgYHBhdGgucmVzb2x2ZSgpYCBvbiBlYWNoKSwgYSB6ZXJvLWxlbmd0aCBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gKlxuICogSWYgYSB6ZXJvLWxlbmd0aCBzdHJpbmcgaXMgcGFzc2VkIGFzIGBmcm9tYCBvciBgdG9gLCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICogd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIHplcm8tbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZnJvbSBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRvICAgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbGF0aXZlKHNlcGFyYXRvciwgZnJvbSwgdG8pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZyb20sICdmcm9tJywgJ3N0cmluZycpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUodG8sICd0bycsICdzdHJpbmcnKTtcblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmcm9tID0gcmVzb2x2ZShzZXBhcmF0b3IsIFtmcm9tXSk7XG4gIHRvID0gcmVzb2x2ZShzZXBhcmF0b3IsIFt0b10pO1xuXG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIHJldHVybiAnJztcbiAgfSAvLyB3ZSBub3cgaGF2ZSB0d28gYWJzb2x1dGUgcGF0aHMsXG4gIC8vIGxldHMgXCJnbyB1cFwiIGZyb20gYGZyb21gIHVudGlsIHdlIHJlYWNoIGNvbW1vbiBiYXNlIGRpciBvZiBgdG9gXG4gIC8vIGNvbnN0IG9yaWdpbmFsRnJvbSA9IGZyb207XG5cblxuICBsZXQgdXBDb3VudCA9IDA7XG4gIGxldCByZW1haW5pbmdQYXRoID0gJyc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodG8uc3RhcnRzV2l0aChmcm9tKSkge1xuICAgICAgLy8gbWF0Y2ghIHJlY29yZCByZXN0Li4uP1xuICAgICAgcmVtYWluaW5nUGF0aCA9IHRvLnNsaWNlKGZyb20ubGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gRklYTUU6IEJyZWFrL3Rocm93IGlmIHdlIGhpdCBiYWQgZWRnZSBjYXNlIG9mIG5vIGNvbW1vbiByb290IVxuXG5cbiAgICBmcm9tID0gZGlybmFtZShzZXBhcmF0b3IsIGZyb20pO1xuICAgIHVwQ291bnQrKztcbiAgfSAvLyByZW1vdmUgbGVhZGluZyBzZXBhcmF0b3IgZnJvbSByZW1haW5pbmdQYXRoIGlmIHRoZXJlIGlzIGFueVxuXG5cbiAgaWYgKHJlbWFpbmluZ1BhdGgubGVuZ3RoID4gMCkge1xuICAgIHJlbWFpbmluZ1BhdGggPSByZW1haW5pbmdQYXRoLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuICgnLi4nICsgc2VwYXJhdG9yKS5yZXBlYXQodXBDb3VudCkgKyByZW1haW5pbmdQYXRoO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgucGFyc2UoKWAgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgcmVwcmVzZW50XG4gKiBzaWduaWZpY2FudCBlbGVtZW50cyBvZiB0aGUgcGF0aC4gVHJhaWxpbmcgZGlyZWN0b3J5IHNlcGFyYXRvcnMgYXJlIGlnbm9yZWQsXG4gKiBzZWUgYHBhdGguc2VwYC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSBkaXIgPHN0cmluZz5cbiAqIC0gcm9vdCA8c3RyaW5nPlxuICogLSBiYXNlIDxzdHJpbmc+XG4gKiAtIG5hbWUgPHN0cmluZz5cbiAqIC0gZXh0IDxzdHJpbmc+XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByb290OiAnJyxcbiAgICBkaXI6ICcnLFxuICAgIGJhc2U6ICcnLFxuICAgIGV4dDogJycsXG4gICAgbmFtZTogJydcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IC8vIENoZWF0IGFuZCBqdXN0IGNhbGwgb3VyIG90aGVyIG1ldGhvZHMgZm9yIGRpcm5hbWUvYmFzZW5hbWUvZXh0bmFtZT9cblxuXG4gIHJlc3VsdC5iYXNlID0gYmFzZW5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCk7XG4gIHJlc3VsdC5leHQgPSBleHRuYW1lKHNlcGFyYXRvciwgcmVzdWx0LmJhc2UpO1xuICBjb25zdCBiYXNlTGVuZ3RoID0gcmVzdWx0LmJhc2UubGVuZ3RoO1xuICByZXN1bHQubmFtZSA9IHJlc3VsdC5iYXNlLnNsaWNlKDAsIGJhc2VMZW5ndGggLSByZXN1bHQuZXh0Lmxlbmd0aCk7XG4gIGNvbnN0IHRvU3VidHJhY3QgPSBiYXNlTGVuZ3RoID09PSAwID8gMCA6IGJhc2VMZW5ndGggKyAxO1xuICByZXN1bHQuZGlyID0gZmlsZXBhdGguc2xpY2UoMCwgZmlsZXBhdGgubGVuZ3RoIC0gdG9TdWJ0cmFjdCk7IC8vIGRyb3AgdHJhaWxpbmcgc2VwYXJhdG9yIVxuXG4gIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KDApOyAvLyBib3RoIHdpbjMyIGFuZCBQT1NJWCByZXR1cm4gJy8nIHJvb3RcblxuICBpZiAoZmlyc3RDaGFyQ29kZSA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgIHJlc3VsdC5yb290ID0gJy8nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gd2UncmUgZG9uZSB3aXRoIFBPU0lYLi4uXG5cblxuICBpZiAoc2VwYXJhdG9yID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IC8vIGZvciB3aW4zMi4uLlxuXG5cbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcZmlsZV9wYXRoJ1xuICAgIC8vIG5lZWQgdG8gcmV0YWluICdcXFxcXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFwnIGFzIHJvb3QgaW4gdGhhdCBjYXNlIVxuICAgIHJlc3VsdC5yb290ID0gJ1xcXFwnO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gY2hlY2sgZm9yIEM6IHN0eWxlIHJvb3RcblxuXG4gIGlmIChsZW5ndGggPiAxICYmIGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyQ29kZSkgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICBpZiAobGVuZ3RoID4gMikge1xuICAgICAgLy8gaXMgaXQgbGlrZSBDOlxcXFw/XG4gICAgICBjb25zdCB0aGlyZENoYXJDb2RlID0gZmlsZXBhdGguY2hhckNvZGVBdCgyKTtcblxuICAgICAgaWYgKHRoaXJkQ2hhckNvZGUgPT09IEZPUldBUkRfU0xBU0ggfHwgdGhpcmRDaGFyQ29kZSA9PT0gQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgcmVzdWx0LnJvb3QgPSBmaWxlcGF0aC5zbGljZSgwLCAzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IC8vIG5vcGUsIGp1c3QgQzosIG5vIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgICByZXN1bHQucm9vdCA9IGZpbGVwYXRoLnNsaWNlKDAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVGhlIGBwYXRoLmZvcm1hdCgpYCBtZXRob2QgcmV0dXJucyBhIHBhdGggc3RyaW5nIGZyb20gYW4gb2JqZWN0LiBUaGlzIGlzIHRoZVxuICogb3Bwb3NpdGUgb2YgYHBhdGgucGFyc2UoKWAuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge29iamVjdH0gcGF0aE9iamVjdCBvYmplY3Qgb2YgZm9ybWF0IHJldHVybmVkIGJ5IGBwYXRoLnBhcnNlKClgXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QuZGlyIGRpcmVjdG9yeSBuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3Qucm9vdCBmaWxlIHJvb3QgZGlyLCBpZ25vcmVkIGlmIGBwYXRoT2JqZWN0LmRpcmAgaXMgcHJvdmlkZWRcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5iYXNlIGZpbGUgYmFzZW5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5uYW1lIGJhc2VuYW1lIG1pbnVzIGV4dGVuc2lvbiwgaWdub3JlZCBpZiBgcGF0aE9iamVjdC5iYXNlYCBleGlzdHNcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5leHQgZmlsZSBleHRlbnNpb24sIGlnbm9yZWQgaWYgYHBhdGhPYmplY3QuYmFzZWAgZXhpc3RzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXQoc2VwYXJhdG9yLCBwYXRoT2JqZWN0KSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShwYXRoT2JqZWN0LCAncGF0aE9iamVjdCcsICdvYmplY3QnKTtcbiAgY29uc3QgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCBgJHtwYXRoT2JqZWN0Lm5hbWUgfHwgJyd9JHtwYXRoT2JqZWN0LmV4dCB8fCAnJ31gOyAvLyBhcHBlbmQgYmFzZSB0byByb290IGlmIGBkaXJgIHdhc24ndCBzcGVjaWZpZWQsIG9yIGlmXG4gIC8vIGRpciBpcyB0aGUgcm9vdFxuXG4gIGlmICghcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5kaXIgPT09IHBhdGhPYmplY3Qucm9vdCkge1xuICAgIHJldHVybiBgJHtwYXRoT2JqZWN0LnJvb3QgfHwgJyd9JHtiYXNlfWA7XG4gIH0gLy8gY29tYmluZSBkaXIgKyAvICsgYmFzZVxuXG5cbiAgcmV0dXJuIGAke3BhdGhPYmplY3QuZGlyfSR7c2VwYXJhdG9yfSR7YmFzZX1gO1xufVxuLyoqXG4gKiBPbiBXaW5kb3dzIHN5c3RlbXMgb25seSwgcmV0dXJucyBhbiBlcXVpdmFsZW50IG5hbWVzcGFjZS1wcmVmaXhlZCBwYXRoIGZvclxuICogdGhlIGdpdmVuIHBhdGguIElmIHBhdGggaXMgbm90IGEgc3RyaW5nLCBwYXRoIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb25zLlxuICogU2VlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3MvZGVza3RvcC9GaWxlSU8vbmFtaW5nLWEtZmlsZSNuYW1lc3BhY2VzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gdG9OYW1lc3BhY2VkUGF0aChmaWxlcGF0aCkge1xuICBpZiAodHlwZW9mIGZpbGVwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfVxuXG4gIGlmIChmaWxlcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCByZXNvbHZlZFBhdGggPSByZXNvbHZlKCdcXFxcJywgW2ZpbGVwYXRoXSk7XG4gIGNvbnN0IGxlbmd0aCA9IHJlc29sdmVkUGF0aC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAvLyBuZWVkICdcXFxcXFxcXCcgb3IgJ0M6JyBtaW5pbXVtXG4gICAgcmV0dXJuIGZpbGVwYXRoO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGFyQ29kZSA9IHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApOyAvLyBpZiBzdGFydCB3aXRoICdcXFxcXFxcXCcsIHByZWZpeCB3aXRoIFVOQyByb290LCBkcm9wIHRoZSBzbGFzaGVzXG5cbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIICYmIHJlc29sdmVkUGF0aC5jaGFyQXQoMSkgPT09ICdcXFxcJykge1xuICAgIC8vIHJldHVybiBhcy1pcyBpZiBpdCdzIGFuIGFyZWFkeSBsb25nIHBhdGggKCdcXFxcXFxcXD9cXFxcJyBvciAnXFxcXFxcXFwuXFxcXCcgcHJlZml4KVxuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgY29uc3QgdGhpcmRDaGFyID0gcmVzb2x2ZWRQYXRoLmNoYXJBdCgyKTtcblxuICAgICAgaWYgKHRoaXJkQ2hhciA9PT0gJz8nIHx8IHRoaXJkQ2hhciA9PT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBmaWxlcGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJ1xcXFxcXFxcP1xcXFxVTkNcXFxcJyArIHJlc29sdmVkUGF0aC5zbGljZSgyKTtcbiAgfSBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VOYW1lKGZpcnN0Q2hhckNvZGUpICYmIHJlc29sdmVkUGF0aC5jaGFyQXQoMSkgPT09ICc6Jykge1xuICAgIHJldHVybiAnXFxcXFxcXFw/XFxcXCcgKyByZXNvbHZlZFBhdGg7XG4gIH1cblxuICByZXR1cm4gZmlsZXBhdGg7XG59XG5cbmNvbnN0IFdpbjMyUGF0aCA9IHtcbiAgc2VwOiAnXFxcXCcsXG4gIGRlbGltaXRlcjogJzsnLFxuICBiYXNlbmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gYmFzZW5hbWUodGhpcy5zZXAsIGZpbGVwYXRoLCBleHQpO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBub3JtYWxpemUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gKC4uLnBhdGhzKSB7XG4gICAgcmV0dXJuIGpvaW4odGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUoZmFsc2UsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiByZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnNlcCwgcGF0aHMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGZvcm1hdDogZnVuY3Rpb24gKHBhdGhPYmplY3QpIHtcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMuc2VwLCBwYXRoT2JqZWN0KTtcbiAgfSxcbiAgdG9OYW1lc3BhY2VkUGF0aDogdG9OYW1lc3BhY2VkUGF0aFxufTtcbmNvbnN0IFBvc2l4UGF0aCA9IHtcbiAgc2VwOiAnLycsXG4gIGRlbGltaXRlcjogJzonLFxuICBiYXNlbmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gYmFzZW5hbWUodGhpcy5zZXAsIGZpbGVwYXRoLCBleHQpO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBub3JtYWxpemUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gKC4uLnBhdGhzKSB7XG4gICAgcmV0dXJuIGpvaW4odGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUodHJ1ZSwgZmlsZXBhdGgpO1xuICB9LFxuICByZWxhdGl2ZTogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlKHRoaXMuc2VwLCBmcm9tLCB0byk7XG4gIH0sXG4gIHJlc29sdmU6IGZ1bmN0aW9uICguLi5wYXRocykge1xuICAgIHJldHVybiByZXNvbHZlKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gcGFyc2UodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZm9ybWF0OiBmdW5jdGlvbiAocGF0aE9iamVjdCkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcy5zZXAsIHBhdGhPYmplY3QpO1xuICB9LFxuICB0b05hbWVzcGFjZWRQYXRoOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7IC8vIG5vLW9wXG4gIH1cbn07XG5jb25zdCBwYXRoID0gUG9zaXhQYXRoO1xucGF0aC53aW4zMiA9IFdpbjMyUGF0aDtcbnBhdGgucG9zaXggPSBQb3NpeFBhdGg7XG5cbmNvbnN0IFBvc2l4Q29uc3RhbnRzID0ge1xuICBVVl9VRFBfUkVVU0VBRERSOiA0LFxuICBkbG9wZW46IHt9LFxuICBlcnJubzoge1xuICAgIEUyQklHOiA3LFxuICAgIEVBQ0NFUzogMTMsXG4gICAgRUFERFJJTlVTRTogNDgsXG4gICAgRUFERFJOT1RBVkFJTDogNDksXG4gICAgRUFGTk9TVVBQT1JUOiA0NyxcbiAgICBFQUdBSU46IDM1LFxuICAgIEVBTFJFQURZOiAzNyxcbiAgICBFQkFERjogOSxcbiAgICBFQkFETVNHOiA5NCxcbiAgICBFQlVTWTogMTYsXG4gICAgRUNBTkNFTEVEOiA4OSxcbiAgICBFQ0hJTEQ6IDEwLFxuICAgIEVDT05OQUJPUlRFRDogNTMsXG4gICAgRUNPTk5SRUZVU0VEOiA2MSxcbiAgICBFQ09OTlJFU0VUOiA1NCxcbiAgICBFREVBRExLOiAxMSxcbiAgICBFREVTVEFERFJSRVE6IDM5LFxuICAgIEVET006IDMzLFxuICAgIEVEUVVPVDogNjksXG4gICAgRUVYSVNUOiAxNyxcbiAgICBFRkFVTFQ6IDE0LFxuICAgIEVGQklHOiAyNyxcbiAgICBFSE9TVFVOUkVBQ0g6IDY1LFxuICAgIEVJRFJNOiA5MCxcbiAgICBFSUxTRVE6IDkyLFxuICAgIEVJTlBST0dSRVNTOiAzNixcbiAgICBFSU5UUjogNCxcbiAgICBFSU5WQUw6IDIyLFxuICAgIEVJTzogNSxcbiAgICBFSVNDT05OOiA1NixcbiAgICBFSVNESVI6IDIxLFxuICAgIEVMT09QOiA2MixcbiAgICBFTUZJTEU6IDI0LFxuICAgIEVNTElOSzogMzEsXG4gICAgRU1TR1NJWkU6IDQwLFxuICAgIEVNVUxUSUhPUDogOTUsXG4gICAgRU5BTUVUT09MT05HOiA2MyxcbiAgICBFTkVURE9XTjogNTAsXG4gICAgRU5FVFJFU0VUOiA1MixcbiAgICBFTkVUVU5SRUFDSDogNTEsXG4gICAgRU5GSUxFOiAyMyxcbiAgICBFTk9CVUZTOiA1NSxcbiAgICBFTk9EQVRBOiA5NixcbiAgICBFTk9ERVY6IDE5LFxuICAgIEVOT0VOVDogMixcbiAgICBFTk9FWEVDOiA4LFxuICAgIEVOT0xDSzogNzcsXG4gICAgRU5PTElOSzogOTcsXG4gICAgRU5PTUVNOiAxMixcbiAgICBFTk9NU0c6IDkxLFxuICAgIEVOT1BST1RPT1BUOiA0MixcbiAgICBFTk9TUEM6IDI4LFxuICAgIEVOT1NSOiA5OCxcbiAgICBFTk9TVFI6IDk5LFxuICAgIEVOT1NZUzogNzgsXG4gICAgRU5PVENPTk46IDU3LFxuICAgIEVOT1RESVI6IDIwLFxuICAgIEVOT1RFTVBUWTogNjYsXG4gICAgRU5PVFNPQ0s6IDM4LFxuICAgIEVOT1RTVVA6IDQ1LFxuICAgIEVOT1RUWTogMjUsXG4gICAgRU5YSU86IDYsXG4gICAgRU9QTk9UU1VQUDogMTAyLFxuICAgIEVPVkVSRkxPVzogODQsXG4gICAgRVBFUk06IDEsXG4gICAgRVBJUEU6IDMyLFxuICAgIEVQUk9UTzogMTAwLFxuICAgIEVQUk9UT05PU1VQUE9SVDogNDMsXG4gICAgRVBST1RPVFlQRTogNDEsXG4gICAgRVJBTkdFOiAzNCxcbiAgICBFUk9GUzogMzAsXG4gICAgRVNQSVBFOiAyOSxcbiAgICBFU1JDSDogMyxcbiAgICBFU1RBTEU6IDcwLFxuICAgIEVUSU1FOiAxMDEsXG4gICAgRVRJTUVET1VUOiA2MCxcbiAgICBFVFhUQlNZOiAyNixcbiAgICBFV09VTERCTE9DSzogMzUsXG4gICAgRVhERVY6IDE4XG4gIH0sXG4gIHNpZ25hbHM6IHtcbiAgICBTSUdIVVA6IDEsXG4gICAgU0lHSU5UOiAyLFxuICAgIFNJR1FVSVQ6IDMsXG4gICAgU0lHSUxMOiA0LFxuICAgIFNJR1RSQVA6IDUsXG4gICAgU0lHQUJSVDogNixcbiAgICBTSUdJT1Q6IDYsXG4gICAgU0lHQlVTOiAxMCxcbiAgICBTSUdGUEU6IDgsXG4gICAgU0lHS0lMTDogOSxcbiAgICBTSUdVU1IxOiAzMCxcbiAgICBTSUdTRUdWOiAxMSxcbiAgICBTSUdVU1IyOiAzMSxcbiAgICBTSUdQSVBFOiAxMyxcbiAgICBTSUdBTFJNOiAxNCxcbiAgICBTSUdURVJNOiAxNSxcbiAgICBTSUdDSExEOiAyMCxcbiAgICBTSUdDT05UOiAxOSxcbiAgICBTSUdTVE9QOiAxNyxcbiAgICBTSUdUU1RQOiAxOCxcbiAgICBTSUdUVElOOiAyMSxcbiAgICBTSUdUVE9VOiAyMixcbiAgICBTSUdVUkc6IDE2LFxuICAgIFNJR1hDUFU6IDI0LFxuICAgIFNJR1hGU1o6IDI1LFxuICAgIFNJR1ZUQUxSTTogMjYsXG4gICAgU0lHUFJPRjogMjcsXG4gICAgU0lHV0lOQ0g6IDI4LFxuICAgIFNJR0lPOiAyMyxcbiAgICBTSUdJTkZPOiAyOSxcbiAgICBTSUdTWVM6IDEyXG4gIH0sXG4gIHByaW9yaXR5OiB7XG4gICAgUFJJT1JJVFlfTE9XOiAxOSxcbiAgICBQUklPUklUWV9CRUxPV19OT1JNQUw6IDEwLFxuICAgIFBSSU9SSVRZX05PUk1BTDogMCxcbiAgICBQUklPUklUWV9BQk9WRV9OT1JNQUw6IC03LFxuICAgIFBSSU9SSVRZX0hJR0g6IC0xNCxcbiAgICBQUklPUklUWV9ISUdIRVNUOiAtMjBcbiAgfVxufTsgLy8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvbnNcblxuY29uc3QgT1MgPSB7XG4gIEVPTDogJ1xcbicsXG4gIGFyY2g6ICgpID0+IHByb2Nlc3MuYXJjaCxcbiAgY29uc3RhbnRzOiBQb3NpeENvbnN0YW50cyxcbiAgY3B1czogKCkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gVGkuUGxhdGZvcm0ucHJvY2Vzc29yQ291bnQ7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgIG1vZGVsOiAndW5rbm93bicsXG4gICAgICAgIHNwZWVkOiAwLFxuICAgICAgICB0aW1lczoge1xuICAgICAgICAgIHVzZXI6IDAsXG4gICAgICAgICAgbmljZTogMCxcbiAgICAgICAgICBzeXM6IDAsXG4gICAgICAgICAgaWRsZTogMCxcbiAgICAgICAgICBpcnE6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuICBlbmRpYW5uZXNzOiAoKSA9PiB7XG4gICAgLy8gVE9ETzogQ2FjaGUgdGhlIHZhbHVlIVxuICAgIGNvbnN0IHJlc3VsdCA9IFRpLkNvZGVjLmdldE5hdGl2ZUJ5dGVPcmRlcigpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gVGkuQ29kZWMuTElUVExFX0VORElBTikge1xuICAgICAgcmV0dXJuICdMRSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdCRSc7XG4gIH0sXG4gIGZyZWVtZW06ICgpID0+IFRpLlBsYXRmb3JtLmF2YWlsYWJsZU1lbW9yeSxcbiAgZ2V0UHJpb3JpdHk6ICgpID0+IDAsXG4gIC8vIGZha2UgaXRcbiAgaG9tZWRpcjogKCkgPT4gVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnksXG4gIC8vIGZha2UgaXRcbiAgaG9zdG5hbWU6ICgpID0+IFRpLlBsYXRmb3JtLmFkZHJlc3MsXG4gIC8vIGZha2UgaXRcbiAgbG9hZGF2ZzogKCkgPT4gWzAsIDAsIDBdLFxuICAvLyBmYWtlIGl0XG4gIG5ldHdvcmtJbnRlcmZhY2VzOiAoKSA9PiB7fSxcbiAgLy8gRklYTUU6IFdoYXQgZG8gd2UgZG8gaGVyZT8gV2UgbWlnaHQgYmUgYWJsZSB0byBwaWVjZSBzb21lIG9mIHRoaXMgdG9nZXRoZXIgdXNpbmcgVGkuUGxhdGZvcm0ubmV0bWFzaywgVGkuUGxhdGZvcm0uYWRkcmVzc1xuICBwbGF0Zm9ybTogKCkgPT4gcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgcmVsZWFzZTogKCkgPT4gVGkuUGxhdGZvcm0udmVyc2lvbixcbiAgc2V0UHJpb3JpdHk6ICgpID0+IHt9LFxuICAvLyBuby1vcCwgZmFrZSBpdFxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnRtcGRpcigpYCBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBvcGVyYXRpbmcgc3lzdGVtJ3MgZGVmYXVsdCBkaXJlY3RvcnkgZm9yIHRlbXBvcmFyeSBmaWxlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0bXBkaXI6ICgpID0+IFRpLkZpbGVzeXN0ZW0udGVtcERpcmVjdG9yeSxcblxuICAvKipcbiAgICogVGhlIGBvcy50b3RhbG1lbSgpYCBtZXRob2QgcmV0dXJucyB0aGUgdG90YWwgYW1vdW50IG9mIHN5c3RlbSBtZW1vcnkgaW4gYnl0ZXMgYXMgYW4gaW50ZWdlci5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdG90YWxtZW06ICgpID0+IFRpLlBsYXRmb3JtLnRvdGFsTWVtb3J5LFxuICB0eXBlOiAoKSA9PiAnVW5rbm93bicsXG4gIC8vIG92ZXJyaWRkZW4gcGVyLXBsYXRmb3JtIGF0IGJvdHRvbVxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnVwdGltZSgpYCBtZXRob2QgcmV0dXJucyB0aGUgc3lzdGVtIHVwdGltZSBpbiBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdXB0aW1lOiAoKSA9PiBUaS5QbGF0Zm9ybS51cHRpbWUsXG4gIHVzZXJJbmZvOiAoKSA9PiB7XG4gICAgLy8gZmFrZSBpdCFcbiAgICByZXR1cm4ge1xuICAgICAgdWlkOiAtMSxcbiAgICAgIGdpZDogLTEsXG4gICAgICB1c2VybmFtZTogVGkuUGxhdGZvcm0udXNlcm5hbWUsXG4gICAgICBob21lZGlyOiBUaS5GaWxlc3lzdGVtLmFwcGxpY2F0aW9uRGF0YURpcmVjdG9yeSxcbiAgICAgIHNoZWxsOiBudWxsXG4gICAgfTtcbiAgfVxufTsgLy8gT24gc3BlY2lmaWMgcGxhdGZvcm1zLCBvdmVycmlkZSBpbXBsZW1lbnRhdGlvbnMgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoZW1cbi8vIHlldCBhbmQgbmVlZCB0byBmYWtlIGl0LCBvciB0byBoYWNrIHRoZW1cbi8vIEknbSBhbHNvIGRvaW5nIHRoaXMgaW4gYmxvY2tzIHRvIGFzc2lnbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCBkb24ndCBuZWVkIHRvIGNvbnN1bHQgcGxhdGZvcm1cbi8vIHR5cGUgYXQgcnVudGltZSAoaG9wZWZ1bGx5IHNwZWVkaW5nIHVwIGV4ZWN1dGlvbiBhdCBydW50aW1lKVxuXG57XG4gIE9TLmNwdXMgPSAoKSA9PiBUaS5QbGF0Zm9ybS5jcHVzKCk7XG5cbiAgT1MudHlwZSA9ICgpID0+ICdMaW51eCc7XG59XG5cbmNvbnN0IHR0eSA9IHtcbiAgaXNhdHR5OiAoKSA9PiBmYWxzZSxcbiAgUmVhZFN0cmVhbTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcigndHR5LlJlYWRTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH0sXG4gIFdyaXRlU3RyZWFtOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0dHkuV3JpdGVTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IE1PTlRIUyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbmNvbnN0IHV0aWwgPSB7XG4gIGZvcm1hdDogZm9ybWF0JDEsXG4gIGZvcm1hdFdpdGhPcHRpb25zLFxuICBpbnNwZWN0LFxuICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICBpc0Jvb2xlYW46IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICBpc0J1ZmZlcjogQnVmZmVyTW9kdWxlLkJ1ZmZlci5pc0J1ZmZlcixcbiAgaXNGdW5jdGlvbjogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nLFxuICBpc051bGw6IHZhbHVlID0+IHZhbHVlID09PSBudWxsLFxuICBpc051bGxPclVuZGVmaW5lZDogdmFsdWUgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCxcbiAgaXNOdW1iZXI6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGlzT2JqZWN0OiB2YWx1ZSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnLFxuICBpc1ByaW1pdGl2ZTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUgPT09IG51bGwsXG4gIGlzU3RyaW5nOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICBpc1N5bWJvbDogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyxcbiAgaXNVbmRlZmluZWQ6IHZhbHVlID0+IHZhbHVlID09PSB1bmRlZmluZWQsXG4gIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRXJyb3I6IGUgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcixcbiAgbG9nOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHRpbWUgPSBgJHtkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2RhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDsgLy8gUHJvZHVjZXMgb3V0cHV0IGxpa2U6IFwiMjEgRmViIDEwOjA0OjIzIC0gbWVzc2FnZVwiXG5cbiAgICBjb25zb2xlLmxvZyhgJHtkYXRlLmdldERhdGUoKX0gJHtNT05USFNbZGF0ZS5nZXRNb250aCgpXX0gJHt0aW1lfSAtICR7c3RyaW5nfWApO1xuICB9LFxuICBwcmludDogKC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKGFyZ3Muam9pbignJykpLFxuICAvLyBGSVhNRTogU2hvdWxkbid0IGFkZCB0cmFpbGluZyBuZXdsaW5lIGxpa2UgY29uc29sZS5sb2cgZG9lcyFcbiAgcHV0czogKC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKGFyZ3Muam9pbignXFxuJykpLFxuICBlcnJvcjogKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoYXJncy5qb2luKCdcXG4nKSksXG4gIGRlYnVnOiBzdHJpbmcgPT4gY29uc29sZS5lcnJvcihgREVCVUc6ICR7c3RyaW5nfWApLFxuICB0eXBlc1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3Igc3ViY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3IgYmFzZSBjbGFzc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxudXRpbC5pbmhlcml0cyA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3Rvcikge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY29uc3RydWN0b3IsICdjb25zdHJ1Y3RvcicsICdGdW5jdGlvbicpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUoc3VwZXJDb25zdHJ1Y3RvciwgJ3N1cGVyQ29uc3RydWN0b3InLCAnRnVuY3Rpb24nKTtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCAnc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUnLCAnT2JqZWN0Jyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyXycsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3RvclxuICB9KTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gd3JhcCB3aGljaCBpcyBleHBlY3RlZCB0byBoYXZlIGEgZmluYWwgY2FsbGJhY2sgYXJndW1lbnRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZVxuICovXG5cblxudXRpbC5wcm9taXNpZnkgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKG9yaWdpbmFsLCAnb3JpZ2luYWwnLCAnRnVuY3Rpb24nKTtcblxuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCAuLi5hcmdzLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSAvLyBUT0RPOiBDb3B5IHByb3BlcnRpZXMgZnJvbSBvcmlnaW5hbCB0byB3cmFwcGVkXG4gIC8vIFRPRE86IGhvb2sgcHJvdG90eXBlIGNoYWluIHVwIGZyb20gd3JhcHBlZCB0byBvcmlnaW5hbFxuICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSBwcm9taXNpZnkgaG9va3NcblxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gY29udmVydCBmcm9tIGFzeW5jL1Byb21pc2UgcmV0dXJuIHZhbHVlIHRvIGEgY2FsbGJhY2sgc3R5bGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuICovXG5cblxudXRpbC5jYWxsYmFja2lmeSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUob3JpZ2luYWwsICdvcmlnaW5hbCcsICdGdW5jdGlvbicpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoLi4uYXJncykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgcHJvbWlzZS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvYWx3YXlzLXJldHVyblxuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEVycm9yID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGZhbHN5IHZhbHVlJyk7XG4gICAgICAgIHdyYXBwZWRFcnJvci5yZWFzb24gPSBlcnI7XG4gICAgICAgIGVyciA9IHdyYXBwZWRFcnJvcjtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiB0byBkZXByZWNhdGUvd3JhcFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBtZXNzYWdlIHRvIGdpdmUgd2hlbiBkZXByZWNhdGlvbiB3YXJuaW5nIGlzIGVtaXR0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIGRlcHJlY2F0aW9uIGNvZGUgdG8gdXNlIHRvIGdyb3VwIHdhcm5pbmdzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xuXG5cbnV0aWwuZGVwcmVjYXRlID0gZnVuY3Rpb24gKGZ1bmMsIHN0cmluZywgY29kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm4gZnVuYzsgLy8gc2tpcCB0aGUgd3JhcHBpbmchXG4gIH0gLy8gVE9ETzogU3VwcG9ydCBgY29kZWAgYXJndW1lbnQgYnkgdHJhY2tpbmcgYSBtYXAgb2YgY29kZXMgd2UndmUgd2FybmVkIGFib3V0XG5cblxuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhzdHJpbmcsICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlZDtcbn07IC8vIFRPRE86IFN1cHBvcnQgZGVidWdsb2c/IFdoYXQgaXMgb3VyIGVxdWl2YWxlbnQgb2YgcHJvY2Vzcy5lbnYoJ05PREVfREVCVUcnKT9cblxuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbnV0aWwuZGVidWdsb2cgPSAoKSA9PiB7XG4gIHJldHVybiBub29wO1xufTtcblxuY29uc3QgREVGQVVMVF9NRVNTQUdFUyA9IHtcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gIG5vdERlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86J1xufTsgLy8gRmFrZSBlbnVtcyB0byB1c2UgaW50ZXJuYWxseVxuXG5jb25zdCBDT01QQVJFX1RZUEUgPSB7XG4gIE9iamVjdDogMCxcbiAgTWFwOiAxLFxuICBTZXQ6IDJcbn07XG5jb25zdCBTVFJJQ1RORVNTID0ge1xuICBTdHJpY3Q6IDAsXG4gIExvb3NlOiAxXG59O1xuXG5jbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGxldCB7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvclxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBGSVhNRTogR2VuZXJhdGUgdGhlIHJlc3Qgb2YgdGhlIG1lc3NhZ2Ugd2l0aCBkaWZmIG9mIGFjdHVhbC9leHBlY3RlZCFcbiAgICAgIG1lc3NhZ2UgPSBgJHtERUZBVUxUX01FU1NBR0VTW29wZXJhdG9yXX1cXG5cXG5gO1xuICAgIH1cblxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXSc7XG4gICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICB9XG5cbn0gLy8gVE9ETzogQ2FuIHdlIGRlZmluZSBBc3NlcnRTdHJpY3QgYW5kIEFzc2VydExvb3NlIGFzIHN1YmNsYXNzZXMgb2YgYSBiYXNlIEFzc2VydCBjbGFzc1xuLy8gdGhhdCBjbGFzcyBob2xkcyBpbXBscyBmb3Igc2hhcmVkIG1ldGhvZHMsIHN1YmNsYXNzZXMgb3ZlcnJpZGUgc3BlY2lmaWNcbi8vIGNvbXBhcmlzb25zIHVzZWQgKE9iamVjdC5pcyB2cyA9PT0pP1xuXG5cbmNvbnN0IGFzc2VydCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTtcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbmFzc2VydC5vayA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gYXJnc1swXTtcblxuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbWVzc2FnZSA9IGFyZ3NbMV07XG4gIGxldCBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7IC8vIENoZWNrIGlmIHZhbHVlICgxc3QgYXJnKSB3YXMgbm90IHN1cHBsaWVkIVxuICAvLyBIYXZlIHRvIHVzZSB1Z2x5IGhhY2sgb24gYXJncyBkZWZpbml0aW9uIHRvIGRvIHNvXG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIC8vIFRPRE86IGdlbmVyYXRlIHJlc3Qgb2YgdGhlIG1lc3NhZ2UuIE5vZGUgYWN0dWFsbHkgcmVhZHMgdGhlIGlucHV0IGZpbGUhIFRoZSBoYWNrZWQgYnJvd3NlcmlmeSBkb2VzIG5vdCBkbyB0aGlzXG4gICAgLy8gSXQgdHJlYXRlcyBvayBmYWlsaW5nIGxpa2UgYHZhbHVlID09IHRydWVgIGZhaWxpbmdcbiAgICBtZXNzYWdlID0gJ1RoZSBleHByZXNzaW9uIGV2YWx1YXRlZCB0byBhIGZhbHN5IHZhbHVlOlxcblxcbic7XG4gICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgbWVzc2FnZTtcbiAgfVxuXG4gIGNvbnN0IGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgYWN0dWFsOiB2YWx1ZSxcbiAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnPT0nXG4gIH0pO1xuICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gIHRocm93IGVycjtcbn07XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Iob2JqKSB7XG4gIC8vIElmIG1lc3NhZ2UgaXMgYW4gRXJyb3Igb2JqZWN0LCB0aHJvdyB0aGF0IGluc3RlYWQhXG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIH1cblxuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdlcXVhbCdcbiAgfSk7XG59O1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgLy8gcHJvdmlkZXMgU2FtZVZhbHVlIGNvbXBhcmlzb24gZm9yIHVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCdcbiAgfSk7XG59O1xuXG5hc3NlcnQubm90RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ25vdEVxdWFsJ1xuICB9KTtcbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgLy8gcHJvdmlkZXMgU2FtZVZhbHVlIGNvbXBhcmlzb24gZm9yIHVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCdcbiAgfSk7XG59O1xuXG5jb25zdCBpc1ByaW1pdGl2ZSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nIHx8IHZhbHVlID09PSBudWxsO1xufTtcbi8qKlxuICogQHBhcmFtIHtNYXB9IGFjdHVhbCBtYXAgd2UgYXJlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtNYXB9IGV4cGVjdGVkIG1hcCB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtTVFJJQ1RORVNTLkxvb3NlfHN0cmljdG5lc3MuU3RyaWN0fSBzdHJpY3RuZXNzIGhvdyB0byBjb21wYXJlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlcyBtZW1vaXplZCByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhlIGRlZXBFcXVhbCBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gY29tcGFyZU1hcHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykge1xuICBjb25zdCBsb29zZUNoZWNrcyA9IG5ldyBTZXQoKTsgLy8ga2VlcCB0cmFjayBvZiBvYmplY3RzIHdlIG5lZWQgdG8gdGVzdCBtb3JlIGV4dGVuc2l2ZWx5IHRoYW4gdXNpbmcgI2dldCgpLyNoYXMoKVxuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFjdHVhbCkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG5vbi1udWxsIG9iamVjdC4gV2UgbmVlZCB0byBkbyBvdXIgb3duIGNoZWNraW5nLCBub3QgdXNlIGdldCgpL2hhcygpXG4gICAgICBsb29zZUNoZWNrcy5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFuZGxlIFwicHJpbWl0aXZlc1wiXG4gICAgICBpZiAoZXhwZWN0ZWQuaGFzKGtleSkgJiYgZGVlcEVxdWFsKHZhbHVlLCBleHBlY3RlZC5nZXQoa2V5KSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykpIHtcbiAgICAgICAgLy8geWF5ISBhIG5pY2UgZWFzeSBtYXRjaCAtIGJvdGgga2V5IGFuZCB2YWx1ZSBtYXRjaGVkIGV4YWN0bHkgLSBtb3ZlIG9uXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IG1hdGNoIGtleS92YWx1ZSBwZXJmZWN0bHkgaW4gc3RyaWN0IG1vZGUsIGZhaWwgcmlnaHQgYXdheVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIG9rLCBzbyBpdCBkaWRuJ3QgbWF0Y2gga2V5L3ZhbHVlIHBlcmZlY3RseSAtIGJ1dCB3ZSdyZSBpbiBsb29zZSBtb2RlLCBzbyBmYWxsIGJhY2sgdG8gdHJ5IGFnYWluXG5cblxuICAgICAgbG9vc2VDaGVja3MuYWRkKGtleSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3NlQ2hlY2tzLnNpemUgPT09IDApIHtcbiAgICAvLyBubyBsb29zZSBlbmRzIHRvIHRpZSB1cCwgZXZlcnl0aGluZyBtYXRjaGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gb25seSBnbyB0aHJvdWdoIHRoZSBzZWNvbmQgTWFwIG9uY2UhXG5cblxuICBmb3IgKGNvbnN0IFtleHBlY3RlZEtleSwgZXhwZWN0ZWRWYWx1ZV0gb2YgZXhwZWN0ZWQpIHtcbiAgICAvLyBpZiBpdCdzIG5vdCBhIG5vbi1udWxsIG9iamVjdCBpbiBzdHJpY3QgbW9kZSwgZmFpbCFcbiAgICAvLyAoaS5lLiBpZiBpdCdzIGEgcHJpbWl0aXZlIHRoYXQgZmFpbGVkIGEgbWF0Y2gsIGRvbid0IGZhbGwgYmFjayB0byBtb3JlIGxvb3NlbHkgbWF0Y2ggaXQpXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgc2hvdWxkbid0IGV2ZXIgaGFwcGVuIHNpbmNlIHdlIHNob3VsZCBiZSByZXR1cm5pbmcgZmFsc2UgaW1tZWRpYXRlbHkgYWJvdmVcbiAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QgJiYgISh0eXBlb2YgZXhwZWN0ZWRLZXkgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkS2V5ICE9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gb3RoZXJ3aXNlLCB0ZXN0IGl0IC8vIFRPRE86IFdpc2ggd2UgY291bGQgdXNlICNmaW5kKCkgbGlrZSBvbiBhbiBBcnJheSwgYnV0IFNldCBkb2Vzbid0IGhhdmUgaXQhXG5cblxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgbG9vc2VDaGVja3MpIHtcbiAgICAgIC8vIGlmIGJvdGgga2V5IGFuZCB2YWx1ZSBtYXRjaGVzXG4gICAgICBpZiAoZGVlcEVxdWFsKGtleSwgZXhwZWN0ZWRLZXksIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpICYmIGRlZXBFcXVhbChhY3R1YWwuZ2V0KGtleSksIGV4cGVjdGVkVmFsdWUsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbG9vc2VDaGVja3MuZGVsZXRlKGtleSk7IC8vIHJlbW92ZSBmcm9tIG91ciBsb29zZUNoZWNrcyBTZXQgc2luY2Ugd2UgYWxyZWFkeSBtYXRjaGVkIGl0XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBpZiBub3QgZm91bmQsIHdlIGZhaWxlZCB0byBtYXRjaFxuXG5cbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIGRpZCB3ZSBsZWF2ZSB1bi1tYXRjaGVkIGtleXM/IGlmIHNvLCBmYWlsXG5cblxuICByZXR1cm4gbG9vc2VDaGVja3Muc2l6ZSA9PT0gMDtcbn1cbi8qKlxuICogQHBhcmFtIHtTZXR9IGFjdHVhbCBtYXAgd2UgYXJlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtTZXR9IGV4cGVjdGVkIG1hcCB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtzdHJpY3RuZXNzLkxvb3NlfHN0cmljdG5lc3MuU3RyaWN0fSBzdHJpY3RuZXNzIGhvdyB0byBjb21wYXJlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlcyBtZW1vaXplZCByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhlIGRlZXBFcXVhbCBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gY29tcGFyZVNldHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykge1xuICBjb25zdCBsb29zZUNoZWNrcyA9IG5ldyBTZXQoKTsgLy8ga2VlcCB0cmFjayBvZiB2YWx1ZXMgd2UgbmVlZCB0byB0ZXN0IG1vcmUgZXh0ZW5zaXZlbHkgdGhhbiB1c2luZyAjaGFzKClcblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFjdHVhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBub24tbnVsbCBvYmplY3QuIFdlIG5lZWQgdG8gZG8gb3VyIG93biBjaGVja2luZywgbm90IHVzZSBoYXMoKVxuICAgICAgbG9vc2VDaGVja3MuYWRkKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCFleHBlY3RlZC5oYXModmFsdWUpKSB7XG4gICAgICAvLyBGSVhNRTogaGFzIGRvZXMgXCJzYW1lLXZhbHVlLXplcm9cIiBjaGVjaywgd2hpY2ggaXMgbGlrZSBPYmplY3QuaXMgZXhjZXB0IGZvciAtMC8rMCBiZWluZyBjb25zaWRlcmVkIGVxdWFsXG4gICAgICAvLyBzbyBtYXkgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhhdCBoZXJlLCB0aGF0J2QgaGF2ZSB0byBiZSBpbiBhbiBlbHNlIGJlbG93IChzaW5jZSBoYXMgd2lsbCByZXR1cm4gdHJ1ZSBoZXJlKVxuICAgICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgICAgIC8vIGZhaWxlZCBcInNhbWUtdmFsdWVcIiBtYXRjaCBmb3IgcHJpbWl0aXZlIGluIHN0cmljdCBtb2RlLCBzbyBmYWlsIHJpZ2h0IGF3YXlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBXaGVuIGRvaW5nIGxvb3NlIGNoZWNrLCB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byBsb29zZXIgY2hlY2sgdGhhbiAjaGFzKCksIHNvIHdlIGNhbid0IGp1c3QgcmV0dXJuIGZhbHNlIGltbWVkaWF0ZWx5IGhlcmVcbiAgICAgIC8vIGFkZCB0byBzZXQgb2YgdmFsdWVzIHRvIGNoZWNrIG1vcmUgdGhvcm91Z2hseVxuXG5cbiAgICAgIGxvb3NlQ2hlY2tzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3NlQ2hlY2tzLnNpemUgPT09IDApIHtcbiAgICAvLyBubyBsb29zZSBlbmRzIHRvIHRpZSB1cCwgZXZlcnl0aGluZyBtYXRjaGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVHJ5IHRvIHdoaXR0bGUgZG93biB0aGUgbG9vc2UgY2hlY2tzIHNldCB0byBiZSBlbXB0eS4uLlxuICAvLyBvbmx5IGdvIHRocm91Z2ggdGhlIHNlY29uZCBTZXQgb25jZSFcblxuXG4gIGZvciAoY29uc3QgZXhwZWN0ZWRWYWx1ZSBvZiBleHBlY3RlZCkge1xuICAgIC8vIGlmIGl0J3Mgbm90IGEgbm9uLW51bGwgb2JqZWN0IGluIHN0cmljdCBtb2RlLCBmYWlsIVxuICAgIC8vIChpLmUuIGlmIGl0J3MgYSBwcmltaXRpdmUgdGhhdCBmYWlsZWQgYSBtYXRjaCwgZG9uJ3QgZmFsbCBiYWNrIHRvIG1vcmUgbG9vc2VseSBtYXRjaCBpdClcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGRuJ3QgZXZlciBoYXBwZW4gc2luY2Ugd2Ugc2hvdWxkIGJlIHJldHVybmluZyBmYWxzZSBpbW1lZGlhdGVseSBhYm92ZVxuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCAmJiAhKHR5cGVvZiBleHBlY3RlZFZhbHVlID09PSAnb2JqZWN0JyAmJiBleHBlY3RlZFZhbHVlICE9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgbG9vc2VDaGVja3MpIHtcbiAgICAgIGlmIChkZWVwRXF1YWwob2JqZWN0LCBleHBlY3RlZFZhbHVlLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICBmb3VuZCA9IHRydWU7IC8vIGZvdW5kIGEgbWF0Y2ghXG5cbiAgICAgICAgbG9vc2VDaGVja3MuZGVsZXRlKG9iamVjdCk7IC8vIHJlbW92ZSBmcm9tIG91ciBsb29zZUNoZWNrcyBTZXQgc2luY2Ugd2UgbWF0Y2hlZCBpdFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gaWYgbm90IGZvdW5kLCB3ZSBmYWlsZWQgdG8gbWF0Y2hcblxuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBkaWQgd2UgbGVhdmUgdW4tbWF0Y2hlZCB2YWx1ZXM/IGlmIHNvLCBmYWlsXG5cblxuICByZXR1cm4gbG9vc2VDaGVja3Muc2l6ZSA9PT0gMDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSBhY3R1YWwgdmFsdWUgd2UgYXJlIGNvbXBhcmluZ1xuICogQHBhcmFtIHsqfSBleHBlY3RlZCB2YWx1ZXMgd2UncmUgY29tcGFyaW5nIGFnYWluc3RcbiAqIEBwYXJhbSB7U1RSSUNUTkVTUy5TdHJpY3R8U1RSSUNUTkVTUy5Mb29zZX0gc3RyaWN0bmVzcyBob3cgc3RyaWN0IGEgY29tcGFyaXNvbiB0byBkb1xuICogQHBhcmFtIHtvYmplY3R9IFtyZWZlcmVuY2VzXSBvcHRpb25hbCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGluIHRoZSBoaWVyYXJjaHlcbiAqIEBwYXJhbSB7TWFwPG9iamVjdCxudW1iZXI+fSBbcmVmZXJlbmNlcy5hY3R1YWxdIG1hcHBpbmcgZnJvbSBvYmplY3RzIHZpc2l0ZWQgKG9uIGBhY3R1YWxgKSB0byB0aGVpciBkZXB0aFxuICogQHBhcmFtIHtNYXA8b2JqZWN0LG51bWJlcj59IFtyZWZlcmVuY2VzLmV4cGVjdGVkXSBtYXBwaW5nIGZyb20gb2JqZWN0cyB2aXNpdGVkIChvbiBgZXhwZWN0ZWRgKSB0byB0aGVpciBkZXB0aFxuICogQHBhcmFtIHtudW1iZXJ9IFtyZWZlcmVuY2VzLmRlcHRoXSBUaGUgY3VycmVudCBkZXB0aCBvZiB0aGUgaGllcmFyY2h5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIC8vIGlmIHByaW1pdGl2ZXMsIGNvbXBhcmUgdXNpbmcgT2JqZWN0LmlzXG4gIC8vIFRoaXMgaGFuZGxlczogbnVsbCwgdW5kZWZpbmVkLCBudW1iZXIsIHN0cmluZywgYm9vbGVhblxuICBpZiAoaXNQcmltaXRpdmUoYWN0dWFsKSAmJiBpc1ByaW1pdGl2ZShleHBlY3RlZCkpIHtcbiAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgIHJldHVybiBPYmplY3QuaXMoYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgfVxuICB9IC8vIE5vdyB3ZSBoYXZlIHZhcmlvdXMgb2JqZWN0cy9mdW5jdGlvbnM6XG4gIC8vIERhdGUsIEVycm9yLCBSZWdFeHAsIEFycmF5LCBNYXAsIFNldCwgT2JqZWN0LCBGdW5jdGlvbiwgQXJyb3cgZnVuY3Rpb25zLCBXZWFrTWFwLCBEYXRhVmlldywgQXJyYXlCdWZmZXIsIFdlYWtTZXQsIHR5cGVkIGFycmF5c1xuICAvLyBub3RhYmx5LCB0aGlzIGluY2x1ZGVzIFwiYm94ZWRcIiBwcmltaXRpdmVzIGNyZWF0ZWQgYnkgbmV3IEJvb2xlYW4oZmFsc2UpLCBuZXcgU3RyaW5nKCd2YWx1ZScpLCBTeW1ib2woJ3doYXRldmVyJyksIGV0Y1xuICAvLyBUeXBlIHRhZ3Mgb2Ygb2JqZWN0cyBzaG91bGQgYmUgdGhlIHNhbWVcblxuXG4gIGNvbnN0IGFjdHVhbFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhY3R1YWwpO1xuICBjb25zdCBleHBlY3RlZFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCk7XG5cbiAgaWYgKGFjdHVhbFRhZyAhPT0gZXhwZWN0ZWRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gW1tQcm90b3R5cGVdXSBvZiBvYmplY3RzIGFyZSBjb21wYXJlZCB1c2luZyB0aGUgU3RyaWN0IEVxdWFsaXR5IENvbXBhcmlzb24uXG5cblxuICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAvLyBkb24ndCBjaGVjayBwcm90b3R5cGUgd2hlbiBkb2luZyBcImxvb3NlXCJcbiAgICBjb25zdCBhY3R1YWxQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihleHBlY3RlZCk7XG5cbiAgICBpZiAoYWN0dWFsUHJvdG90eXBlICE9PSBleHBlY3RlZFByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjb21wYXJpc29uID0gQ09NUEFSRV9UWVBFLk9iamVjdDtcblxuICBpZiAodXRpbC50eXBlcy5pc1JlZ0V4cChhY3R1YWwpKSB7XG4gICAgLy8gUmVnRXhwIHNvdXJjZSBhbmQgZmxhZ3Mgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzUmVnRXhwKGV4cGVjdGVkKSB8fCBhY3R1YWwuZmxhZ3MgIT09IGV4cGVjdGVkLmZsYWdzIHx8IGFjdHVhbC5zb3VyY2UgIT09IGV4cGVjdGVkLnNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0RhdGUoYWN0dWFsKSkge1xuICAgIC8vIERhdGUncyB1bmRlcmx5aW5nIHRpbWUgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzRGF0ZShleHBlY3RlZCkgfHwgYWN0dWFsLmdldFRpbWUoKSAhPT0gZXhwZWN0ZWQuZ2V0VGltZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIEVycm9yJ3MgbmFtZSBhbmQgbWVzc2FnZSBtdXN0IG1hdGNoXG4gICAgaWYgKCEoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikgfHwgYWN0dWFsLm5hbWUgIT09IGV4cGVjdGVkLm5hbWUgfHwgYWN0dWFsLm1lc3NhZ2UgIT09IGV4cGVjdGVkLm1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWN0dWFsKSkge1xuICAgIC8vIGlmIGFycmF5IGxlbmd0aHMgZGlmZmVyLCBxdWljayBmYWlsXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSB8fCBhY3R1YWwubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShhY3R1YWwpKSB7XG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjaGVjayB0aGF0IHRoZXkncmUgdGhlIHNhbWUgdHlwZSBvZiB3cmFwcGVkIHByaW1pdGl2ZSBhbmQgdGhlbiBjYWxsIHRoZSByZWxldmFudCB2YWx1ZU9mKCkgZm9yIHRoYXQgdHlwZSB0byBjb21wYXJlIHRoZW0hXG5cblxuICAgIGlmICh1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGV4cGVjdGVkKSB8fCAhT2JqZWN0LmlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCksIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGV4cGVjdGVkKSB8fCBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzQm9vbGVhbk9iamVjdChhY3R1YWwpICYmICghdXRpbC50eXBlcy5pc0Jvb2xlYW5PYmplY3QoZXhwZWN0ZWQpIHx8IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGSVhNRTogVW5jb21tZW50IHdoZW4gd2Ugc3VwcG9ydCBCaWdJbnQgY3Jvc3MtcGxhdGZvcm0hXG4gICAgICAvLyB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCaWdJbnRPYmplY3QoYWN0dWFsKVxuICAgICAgLy8gXHQmJiAoIXV0aWwudHlwZXMuaXNCaWdJbnRPYmplY3QoZXhwZWN0ZWQpXG4gICAgICAvLyBcdFx0fHwgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoYWN0dWFsKSAhPT0gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgLy8gXHRyZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGV4cGVjdGVkKSB8fCBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU2V0KGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNTZXQoZXhwZWN0ZWQpIHx8IGFjdHVhbC5zaXplICE9PSBleHBlY3RlZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5TZXQ7IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzTWFwKGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNNYXAoZXhwZWN0ZWQpIHx8IGFjdHVhbC5zaXplICE9PSBleHBlY3RlZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5NYXA7IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSAvLyBOb3cgaXRlcmF0ZSBvdmVyIHByb3BlcnRpZXMgYW5kIGNvbXBhcmUgdGhlbSFcblxuXG4gIGNvbnN0IGFjdHVhbEtleXMgPSBPYmplY3Qua2V5cyhhY3R1YWwpOyAvLyBmb3IgYW4gYXJyYXksIHRoaXMgd2lsbCByZXR1cm4gdGhlIGluZGljZXMgdGhhdCBoYXZlIHZhbHVlc1xuXG4gIGNvbnN0IGV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTsgLy8gYW5kIGl0IGp1c3QgbWFnaWNhbGx5IHdvcmtzXG4gIC8vIE11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzXG5cbiAgaWYgKGFjdHVhbEtleXMubGVuZ3RoICE9PSBleHBlY3RlZEtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEFyZSB0aGV5IHRoZSBzYW1lIGtleXM/IElmIG9uZSBpcyBtaXNzaW5nLCB0aGVuIG5vLCBmYWlsIHJpZ2h0IGF3YXlcblxuXG4gIGlmICghYWN0dWFsS2V5cy5ldmVyeShrZXkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cGVjdGVkLCBrZXkpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBEb24ndCBjaGVjayBvd24gc3ltYm9scyB3aGVuIGRvaW5nIFwibG9vc2VcIlxuXG5cbiAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgY29uc3QgYWN0dWFsU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV4cGVjdGVkKTsgLy8gTXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHN5bWJvbHNcblxuICAgIGlmIChhY3R1YWxTeW1ib2xzLmxlbmd0aCAhPT0gZXhwZWN0ZWRTeW1ib2xzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhY3R1YWxTeW1ib2xzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEhhdmUgdG8gZmlsdGVyIHRoZW0gZG93biB0byBlbnVtZXJhYmxlIHN5bWJvbHMhXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY3R1YWxTeW1ib2xzKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChhY3R1YWwsIGtleSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGV4cGVjdGVkLCBrZXkpO1xuXG4gICAgICAgIGlmIChhY3R1YWxJc0VudW1lcmFibGUgIT09IGV4cGVjdGVkSXNFbnVtZXJhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB0aGV5IGRpZmZlciBvbiB3aGV0ZWhyIHN5bWJvbCBpcyBlbnVtZXJhYmxlLCBmYWlsIVxuICAgICAgICB9IGVsc2UgaWYgKGFjdHVhbElzRW51bWVyYWJsZSkge1xuICAgICAgICAgIC8vIGl0J3MgZW51bWVyYWJsZSwgYWRkIHRvIGtleXMgdG8gY2hlY2tcbiAgICAgICAgICBhY3R1YWxLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBleHBlY3RlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMhXG4gIC8vIFJlY29yZCBtYXAgZnJvbSBvYmplY3RzIHRvIGRlcHRoIGluIHRoZSBoaWVyYXJjaHlcblxuXG4gIGlmIChyZWZlcmVuY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICByZWZlcmVuY2VzID0ge1xuICAgICAgYWN0dWFsOiBuZXcgTWFwKCksXG4gICAgICBleHBlY3RlZDogbmV3IE1hcCgpLFxuICAgICAgZGVwdGg6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IHJlY29yZGVkIHRoZXNlIG9iamVjdHMuXG4gICAgLy8gaWYgc28sIG1ha2Ugc3VyZSB0aGV5IHJlZmVyIHRvIHNhbWUgZGVwdGggaW4gb2JqZWN0IGhpZXJhcmNoeVxuICAgIGNvbnN0IG1lbW9pemVkQWN0dWFsID0gcmVmZXJlbmNlcy5hY3R1YWwuZ2V0KGFjdHVhbCk7XG5cbiAgICBpZiAobWVtb2l6ZWRBY3R1YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWVtb2l6ZWRFeHBlY3RlZCA9IHJlZmVyZW5jZXMuZXhwZWN0ZWQuZ2V0KGV4cGVjdGVkKTtcblxuICAgICAgaWYgKG1lbW9pemVkRXhwZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWRBY3R1YWwgPT09IG1lbW9pemVkRXhwZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVmZXJlbmNlcy5kZXB0aCsrO1xuICB9IC8vIHN0b3JlIHRoZSBvYmplY3QgLT4gZGVwdGggbWFwcGluZ1xuXG5cbiAgcmVmZXJlbmNlcy5hY3R1YWwuc2V0KGFjdHVhbCwgcmVmZXJlbmNlcy5kZXB0aCk7XG4gIHJlZmVyZW5jZXMuZXhwZWN0ZWQuc2V0KGV4cGVjdGVkLCByZWZlcmVuY2VzLmRlcHRoKTsgLy8gV2hlbiBjb21wYXJpbmcgTWFwcy9TZXRzLCBjb21wYXJlIGVsZW1lbnRzIGJlZm9yZSBjdXN0b20gcHJvcGVydGllc1xuXG4gIGxldCByZXN1bHQgPSB0cnVlO1xuXG4gIGlmIChjb21wYXJpc29uID09PSBDT01QQVJFX1RZUEUuU2V0KSB7XG4gICAgcmVzdWx0ID0gY29tcGFyZVNldHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcyk7XG4gIH0gZWxzZSBpZiAoY29tcGFyaXNvbiA9PT0gQ09NUEFSRV9UWVBFLk1hcCkge1xuICAgIHJlc3VsdCA9IGNvbXBhcmVNYXBzKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpO1xuICB9XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIC8vIE5vdyBsb29wIG92ZXIga2V5cyBhbmQgY29tcGFyZSB0aGVtIHRvIGVhY2ggb3RoZXIhXG4gICAgZm9yIChjb25zdCBrZXkgb2YgYWN0dWFsS2V5cykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0sIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gd2lwZSB0aGUgb2JqZWN0IHRvIGRlcHRoIG1hcHBpbmcgZm9yIHRoZXNlIG9iamVjdHMgbm93XG5cblxuICByZWZlcmVuY2VzLmFjdHVhbC5kZWxldGUoYWN0dWFsKTtcbiAgcmVmZXJlbmNlcy5leHBlY3RlZC5kZWxldGUoZXhwZWN0ZWQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuTG9vc2UpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5Mb29zZSkpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJ1xuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQuZmFpbCA9IChtZXNzYWdlID0gJ0ZhaWxlZCcpID0+IHRocm93RXJyb3Ioe1xuICBtZXNzYWdlXG59KTtcblxuY29uc3QgTk9fRVhDRVBUSU9OID0ge307XG5cbmZ1bmN0aW9uIGV4ZWN1dGUoZm4pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZuLCAnZm4nLCAnRnVuY3Rpb24nKTtcblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT047XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UoZm4pIHtcbiAgcmV0dXJuIHV0aWwudHlwZXMuaXNQcm9taXNlKGZuKSB8fCBmbiAmJiB0eXBlb2YgZm4gPT09ICdvYmplY3QnICYmIHR5cGVvZiBmbi50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUHJvbWlzZShmbikge1xuICBsZXQgcHJvbWlzZTtcbiAgY29uc3QgZm5UeXBlID0gdHlwZW9mIGZuO1xuXG4gIGlmIChmblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9taXNlID0gZm4oKTtcblxuICAgIGlmICghaXNQcm9taXNlTGlrZShwcm9taXNlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5zdGFuY2VvZiBQcm9taXNlIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFwiZm5cIiBmdW5jdGlvbiBidXQgZ290ICR7dHlwZW9mIHByb21pc2V9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghaXNQcm9taXNlTGlrZShmbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZuXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uIG9yIFByb21pc2UuIFJlY2VpdmVkIHR5cGUgJHtmblR5cGV9YCk7XG4gICAgfVxuXG4gICAgcHJvbWlzZSA9IGZuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBwcm9taXNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OO1xufVxuXG5hc3NlcnQudGhyb3dzID0gKGZuLCBlcnJvciwgbWVzc2FnZSkgPT4ge1xuICBjb25zdCBhY3R1YWwgPSBleGVjdXRlKGZuKTtcblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICAvLyBGSVhNRTogYXBwZW5kIG1lc3NhZ2UgaWYgbm90IG51bGxcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgbWVzc2FnZTogJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uLicsXG4gICAgICBvcGVyYXRvcjogJ3Rocm93cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3Qgcm9sbCB3aXRoIGl0XG5cblxuICBpZiAoIWVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpKSB7XG4gICAgdGhyb3cgYWN0dWFsOyAvLyB0aHJvdyB0aGUgRXJyb3IgaXQgZGlkIGdlbmVyYXRlXG4gIH1cbn07XG5cbmFzc2VydC5yZWplY3RzID0gYXN5bmMgZnVuY3Rpb24gKGFzeW5jRm4sIGVycm9yLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGFjdHVhbCA9IGF3YWl0IGV4ZWN1dGVQcm9taXNlKGFzeW5jRm4pO1xuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIC8vIEZJWE1FOiBhcHBlbmQgbWVzc2FnZSBpZiBub3QgbnVsbFxuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24uJyxcbiAgICAgIG9wZXJhdG9yOiAncmVqZWN0cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3Qgcm9sbCB3aXRoIGl0XG5cblxuICBpZiAoIWVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpKSB7XG4gICAgdGhyb3cgYWN0dWFsOyAvLyB0aHJvdyB0aGUgRXJyb3IgaXQgZGlkIGdlbmVyYXRlXG4gIH1cbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSAoZm4sIGVycm9yLCBtZXNzYWdlKSA9PiB7XG4gIGNvbnN0IGFjdHVhbCA9IGV4ZWN1dGUoZm4pOyAvLyBubyBFcnJvciwganVzdCByZXR1cm5cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3QgcmUtdGhyb3dcblxuXG4gIGlmICghZXJyb3IpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH0gLy8gSWYgZXJyb3IgbWF0Y2hlcyBleHBlY3RlZCwgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3JcblxuXG4gIGlmIChjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogJ2RvZXNOb3RUaHJvdycsXG4gICAgICBtZXNzYWdlOiBgR290IHVud2FudGVkIGV4Y2VwdGlvbiR7bWVzc2FnZSA/ICc6ICcgKyBtZXNzYWdlIDogJy4nfWBcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gZG9lc24ndCBtYXRjaCwgcmUtdGhyb3dcblxuXG4gIHRocm93IGFjdHVhbDtcbn07XG5cbmFzc2VydC5kb2VzTm90UmVqZWN0ID0gYXN5bmMgZnVuY3Rpb24gKGZuLCBlcnJvciwgbWVzc2FnZSkge1xuICBjb25zdCBhY3R1YWwgPSBhd2FpdCBleGVjdXRlUHJvbWlzZShmbik7IC8vIG5vIEVycm9yLCBqdXN0IHJldHVyblxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIHJldHVybjtcbiAgfSAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByZS10aHJvd1xuXG5cbiAgaWYgKCFlcnJvcikge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfSAvLyBJZiBlcnJvciBtYXRjaGVzIGV4cGVjdGVkLCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuXG5cbiAgaWYgKGNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvcikpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiAnZG9lc05vdFRocm93JyxcbiAgICAgIG1lc3NhZ2U6IGBHb3QgdW53YW50ZWQgZXhjZXB0aW9uJHttZXNzYWdlID8gJzogJyArIG1lc3NhZ2UgOiAnLid9YFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfSAvLyBkb2Vzbid0IG1hdGNoLCByZS10aHJvd1xuXG5cbiAgdGhyb3cgYWN0dWFsO1xufTtcbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gYWN0dWFsIHRoZSBhY3R1YWwgRXJyb3IgZ2VuZXJhdGVkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uL2Jsb2NrXG4gKiBAcGFyYW0ge29iamVjdHxSZWdFeHB8RnVuY3Rpb258RXJyb3J8Q2xhc3N9IGV4cGVjdGVkIFRoZSB2YWx1ZSB0byB0ZXN0IGFnYWluc3QgdGhlIEVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGN1c3RvbSBtZXNzYWdlIHRvIGFwcGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIEVycm9yIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHZhbHVlL29iamVjdFxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tFcnJvcihhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIC8vIFdoYXQgd2UgZG8gaGVyZSBkZXBlbmRzIG9uIHdoYXQgYGV4cGVjdGVkYCBpczpcbiAgLy8gZnVuY3Rpb24gLSBjYWxsIGl0IHRvIHZhbGlkYXRlXG4gIC8vIG9iamVjdCAtIHRlc3QgcHJvcGVydGllcyBhZ2FpbnN0IGFjdHVhbFxuICAvLyBSZWdleHAgLSB0ZXN0IGFnYWluc3QgYWN0dWFsLnRvU3RyaW5nKClcbiAgLy8gRXJyb3IgdHlwZSAtIGNoZWNrIHR5cGUgbWF0Y2hlc1xuICAvLyBFcnJvciBpbnN0YW5jZSAtIGNvbXBhcmUgcHJvcGVydGllc1xuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh1dGlsLnR5cGVzLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gZG9lcyB0aGUgZXJyb3IgbWF0Y2ggdGhlIFJlZ0V4cCBleHByZXNzaW9uPyBpZiBzbywgcGFzc1xuICAgIH0gLy8gVGVzdCBwcm9wZXJ0aWVzIChgZXhwZWN0ZWRgIGlzIGVpdGhlciBhIGdlbmVyaWMgT2JqZWN0IG9yIGFuIEVycm9yIGluc3RhbmNlKVxuXG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBJZiB3ZSdyZSB0ZXN0aW5nIGFnYWluc3QgYW4gaW5zdGFuY2Ugb2YgYW4gRXJyb3IsIHdlIG5lZWQgdG8gaGFjayBpbiBuYW1lL21lc3NhZ2UgcHJvcGVydGllcy5cblxuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBrZXlzLnVuc2hpZnQoJ25hbWUnLCAnbWVzc2FnZScpOyAvLyB3ZSB3YW50IHRvIGNvbXBhcmUgbmFtZSBhbmQgbWVzc2FnZSwgYnV0IHRoZXkncmUgbm90IHNldCBhcyBlbnVtZXJhYmxlIG9uIEVycm9yXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0sIFNUUklDVE5FU1MuU3RyaWN0KSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAvLyBnZW5lcmF0ZSBhIG1lYW5pbmdmdWwgbWVzc2FnZSEgQ2hlYXQgYnkgdHJlYXRpbmcgbGlrZSBlcXVhbGl0eSBjaGVjayBvZiB2YWx1ZXNcbiAgICAgICAgICAvLyB0aGVuIHN0ZWFsIHRoZSBtZXNzYWdlIGl0IGdlbmVyYXRlZFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHtcbiAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWxba2V5XSxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkW2tleV0sXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dFcnJvcih7XG4gICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgb3BlcmF0b3I6ICd0aHJvd3MnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7IC8vIFRoZXkgYWxsIG1hdGNoZWQsIHBhc3MhXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gaWYgYGV4cGVjdGVkYCBpcyBhIFwidHlwZVwiIGFuZCBhY3R1YWwgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB0eXBlLCB0aGVuIHBhc3NcbiAgICBpZiAoZXhwZWN0ZWQucHJvdG90eXBlICE9IG51bGwgJiYgYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gSWYgYGV4cGVjdGVkYCBpcyBhIHN1YmNsYXNzIG9mIEVycm9yIGJ1dCBgYWN0dWFsYCB3YXNuJ3QgYW4gaW5zdGFuY2Ugb2YgaXQgKGFib3ZlKSwgZmFpbFxuXG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoRXJyb3IsIGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gb2ssIGxldCdzIGFzc3VtZSB3aGF0J3MgbGVmdCBpcyB0aGF0IGBleHBlY3RlZGAgd2FzIGEgdmFsaWRhdGlvbiBmdW5jdGlvbixcbiAgICAvLyBzbyBjYWxsIGl0IHdpdGggZW1wdHkgYHRoaXNgIGFuZCBzaW5nbGUgYXJndW1lbnQgb2YgdGhlIGFjdHVhbCBlcnJvciB3ZSByZWNlaXZlZFxuXG5cbiAgICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuYXNzZXJ0LmlmRXJyb3IgPSB2YWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsOiB2YWx1ZSxcbiAgICBleHBlY3RlZDogbnVsbCxcbiAgICBtZXNzYWdlOiBgaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAke3ZhbHVlfWAsXG4gICAgb3BlcmF0b3I6ICdpZkVycm9yJ1xuICB9KTtcbn07IC8vIENyZWF0ZSBcInN0cmljdFwiIGNvcHkgd2hpY2ggb3ZlcnJpZGVzIFwibG9vc2VcIiBtZXRob2RzIHRvIGNhbGwgc3RyaWN0IGVxdWl2YWxlbnRzXG5cblxuYXNzZXJ0LnN0cmljdCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTsgLy8gXCJDb3B5XCIgbWV0aG9kcyBmcm9tIGFzc2VydCB0byBhc3NlcnQuc3RyaWN0IVxuXG5cbk9iamVjdC5hc3NpZ24oYXNzZXJ0LnN0cmljdCwgYXNzZXJ0KTsgLy8gT3ZlcnJpZGUgdGhlIFwibG9vc2VcIiBtZXRob2RzIHRvIHBvaW50IHRvIHRoZSBzdHJpY3Qgb25lc1xuXG5hc3NlcnQuc3RyaWN0LmRlZXBFcXVhbCA9IGFzc2VydC5kZWVwU3RyaWN0RXF1YWw7XG5hc3NlcnQuc3RyaWN0Lm5vdERlZXBFcXVhbCA9IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWw7XG5hc3NlcnQuc3RyaWN0LmVxdWFsID0gYXNzZXJ0LnN0cmljdEVxdWFsO1xuYXNzZXJ0LnN0cmljdC5ub3RFcXVhbCA9IGFzc2VydC5ub3RTdHJpY3RFcXVhbDsgLy8gaGFuZyBzdHJpY3Qgb2ZmIGl0c2VsZlxuXG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcgdGhlIGBTdHJpbmdEZWNvZGVyYCB3aWxsIHVzZS5cbiAqL1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZyA9ICd1dGY4Jykge1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcblxuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICB0aGlzLl9pbXBsID0gbmV3IFV0ZjhTdHJpbmdEZWNvZGVyKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNi1sZSc6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLl9pbXBsID0gbmV3IFV0ZjE2U3RyaW5nRGVjb2RlcigpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy5faW1wbCA9IG5ldyBCYXNlNjRTdHJpbmdEZWNvZGVyKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLl9pbXBsID0gbmV3IFN0cmluZ0RlY29kZXJJbXBsKHRoaXMuZW5jb2RpbmcpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyBhbnkgcmVtYWluaW5nIGlucHV0IHN0b3JlZCBpbiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFzIGEgc3RyaW5nLlxuICogQnl0ZXMgcmVwcmVzZW50aW5nIGluY29tcGxldGUgVVRGLTggYW5kIFVURi0xNiBjaGFyYWN0ZXJzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzdWJzdGl0dXRpb25cbiAqIGNoYXJhY3RlcnMgYXBwcm9wcmlhdGUgZm9yIHRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcuXG4gKlxuICogSWYgdGhlIGJ1ZmZlciBhcmd1bWVudCBpcyBwcm92aWRlZCwgb25lIGZpbmFsIGNhbGwgdG8gc3RyaW5nRGVjb2Rlci53cml0ZSgpIGlzIHBlcmZvcm1lZCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZW1haW5pbmcgaW5wdXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gW2J1ZmZlcl0gY29udGFpbmluZyB0aGUgYnl0ZXMgdG8gZGVjb2RlLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMuX2ltcGwuZW5kKGJ1ZmZlcik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgZGVjb2RlZCBzdHJpbmcsIGVuc3VyaW5nIHRoYXQgYW55IGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlcnMgYXQgdGhlIGVuZCBvZiB0aGUgQnVmZmVyLCBvclxuICogVHlwZWRBcnJheSwgb3IgRGF0YVZpZXcgYXJlIG9taXR0ZWQgZnJvbSB0aGUgcmV0dXJuZWQgc3RyaW5nIGFuZCBzdG9yZWQgaW4gYW4gaW50ZXJuYWwgYnVmZmVyIGZvciB0aGVcbiAqIG5leHQgY2FsbCB0byBzdHJpbmdEZWNvZGVyLndyaXRlKCkgb3Igc3RyaW5nRGVjb2Rlci5lbmQoKS5cbiAqIEBwYXJhbSB7QnVmZmVyfFR5cGVkQXJyYXl8RGF0YVZpZXd9IGJ1ZmZlciBjb250YWluaW5nIHRoZSBieXRlcyB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZShidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSAvLyBlbXB0eSBzdHJpbmcgZm9yIGVtcHR5IGJ1ZmZlclxuXG5cbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5faW1wbC53cml0ZShidWZmZXIpO1xufTtcbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcy4gV2Ugb3ZlcnJpZGUgcGFydHMgb2YgaXQgZm9yIGNlcnRhaW4gZW5jb2RpbmdzLiBGb3IgYXNjaWkvaGV4L2JpbmFyeS9sYXRpbjEgdGhlIGltcGwgaXMgc3VwZXItZWFzeVxuICovXG5cblxuY2xhc3MgU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGY4Jykge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLmJ5dGVDb3VudCA9IDA7XG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gMTtcbiAgfSAvLyB0aGUgYWN0dWFsIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb24hXG5cblxuICBlbmQoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZShidWZmZXIpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHdyaXRlKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTsgLy8gc2luZ2xlIGJ5dGUgY2hhcmFjdGVyIGVuY29kaW5ncyBhcmUgYSBjaW5jaFxuICAgIH1cblxuICAgIHJldHVybiAnJzsgLy8gbm8gYnVmZmVyLCBvciBlbXB0eVxuICB9XG5cbn0gLy8gRm9yIG11bHRpLWJ5dGUgZW5jb2RpbmdzLCBsZXQncyBpbXBsZW1lbnQgc29tZSBiYXNlIGxvZ2ljLi4uXG5cblxuY2xhc3MgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwgZXh0ZW5kcyBTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKGVuY29kaW5nLCBieXRlc1BlckNoYXIpIHtcbiAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgdGhpcy5pbmNvbXBsZXRlID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzUGVyQ2hhcik7IC8vIHRlbXBvcmFyeSBpbmNvbXBsZXRlIGNoYXJhY3RlciBidWZmZXJcbiAgfVxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gSW5jb21wbGV0ZUNoYXJPYmplY3RcbiAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBieXRlc05lZWRlZCBieXRlcyBtaXNzaW5nIHRvIGNvbXBsZXRlIHRoZSBjaGFyYWN0ZXJcbiAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBjaGFyTGVuZ3RoIGJ5dGVzIGV4cGVjdGVkIHRvIGNvbXBsZXRlIHRoZSBjaGFyYWN0ZXJcbiAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBpbmRleCBsb2NhdGlvbiBpbiB0aGUgYnVmZmVyIHdoZXJlIHRoZSBjaGFyYWN0ZXIgc3RhcnRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIEJ1ZmZlciwgc2VlcyBpZiB3ZSBoYXZlIGFuIGluY29tcGxldGUgXCJjaGFyYWN0ZXJcIiBhdCB0aGUgZW5kIG9mIGl0LlxuICAgKiBSZXR1cm5zIGluZm8gb24gdGhhdDpcbiAgICogLSBieXRlc05lZWRlZDogMC0zLCBudW1iZXIgb2YgYnl0ZXMgc3RpbGwgcmVtYWluaW5nXG4gICAqIC0gY2hhckxlbmd0aDogZXhwZWN0ZWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICogLSBpbmRleDogaW5kZXggaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYmVnaW5zXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBfYnVmZmVyIEJ1ZmZlciB3ZSBhcmUgY2hlY2tpbmcgdG8gc2VlIGlmIGl0IGhhcyBhbiBpbmNvbXBlbHRlIFwiY2hhcmFjdGVyXCIgYXQgdGhlIGVuZFxuICAgKi9cblxuXG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhfYnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUhJyk7XG4gIH1cblxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSEnKTtcbiAgfVxuXG4gIF9pbmNvbXBsZXRlQnVmZmVyRW1wdGllZCgpIHtcbiAgICAvLyB0eXBpY2FsbHkgd2UgcmVzZXQgYnl0ZSBjb3VudCBiYWNrIHRvIDAgYW5kIGNoYXJhY3RlciBsZW5ndGggdG8gMVxuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAxO1xuICB9XG5cbiAgZW5kKGJ1ZmZlcikge1xuICAgIGxldCByZXN1bHQgPSBzdXBlci5lbmQoYnVmZmVyKTtcblxuICAgIGlmICh0aGlzLmJ5dGVDb3VudCAhPT0gMCkge1xuICAgICAgLy8gd2UgaGF2ZSBpbmNvbXBsZXRlIGNoYXJhY3RlcnMhXG4gICAgICByZXN1bHQgKz0gdGhpcy5faW5jb21wbGV0ZUVuZCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCk7IC8vIHJlc2V0IG91ciBpbnRlcm5hbHMgdG8gXCJ3aXBlXCIgdGhlIGluY29tcGxldGUgYnVmZmVyXG5cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB3cml0ZShidWZmZXIpIHtcbiAgICAvLyBmaXJzdCBsZXQncyBzZWUgaWYgd2UgaGFkIHNvbWUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgd2UgZGlkbid0IGZpbmlzaC4uLlxuICAgIGxldCBjaGFyID0gJyc7XG5cbiAgICBpZiAodGhpcy5ieXRlQ291bnQgIT09IDApIHtcbiAgICAgIC8vIHdlIHN0aWxsIG5lZWRlZCBzb21lIGJ5dGVzIHRvIGZpbmlzaCB0aGUgY2hhcmFjdGVyXG4gICAgICAvLyBIb3cgbWFueSBieXRlcyBkbyB3ZSBzdGlsbCBuZWVkPyBjaGFyTGVuZ3RoIC0gYnl0ZXMgd2UgcmVjZWl2ZWRcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmJ5dGVDb3VudDsgLy8gbmVlZCA0LCBoYXZlIDE/IHRoZW4gd2UgaGF2ZSAzIFwibGVmdFwiXG5cbiAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gTWF0aC5taW4obGVmdCwgYnVmZmVyLmxlbmd0aCk7IC8vIGNvcHkgdXAgdG8gdGhhdCBtYW55IGJ5dGVzXG4gICAgICAvLyBjb3B5IGJ5dGVzIGZyb20gYGJ1ZmZlcmAgdG8gb3VyIGluY29tcGxldGUgYnVmZmVyXG5cbiAgICAgIGJ1ZmZlci5jb3B5KHRoaXMuaW5jb21wbGV0ZSwgdGhpcy5ieXRlQ291bnQsIDAsIGJ5dGVzQ29waWVkKTtcbiAgICAgIHRoaXMuYnl0ZUNvdW50ICs9IGJ5dGVzQ29waWVkOyAvLyByZWNvcmQgaG93IG1hbnkgbW9yZSBieXRlcyB3ZSBjb3BpZWQuLi5cblxuICAgICAgaWYgKGJ5dGVzQ29waWVkIDwgbGVmdCkge1xuICAgICAgICAvLyBzdGlsbCBuZWVkIG1vcmUgYnl0ZXMgdG8gY29tcGxldGUhXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gLy8gd2Ugd2VyZSBhYmxlIHRvIGNvbXBsZXRlLCB5YXkhXG4gICAgICAvLyBncmFiIHRoZSBjaGFyYWN0ZXIgd2UgY29tcGxldGVkXG5cblxuICAgICAgY2hhciA9IHRoaXMuaW5jb21wbGV0ZS5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyByZXNldCBvdXIgY291bnRlcnNcblxuICAgICAgdGhpcy5faW5jb21wbGV0ZUJ1ZmZlckVtcHRpZWQoKTsgLy8gZG8gd2UgaGF2ZSBhbnkgYnl0ZXMgbGVmdCBpbiB0aGlzIGJ1ZmZlcj9cblxuXG4gICAgICBpZiAoYnl0ZXNDb3BpZWQgPT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNoYXI7IC8vIGlmIG5vdCwgcmV0dXJuIHRoZSBjaGFyYWN0ZXIgd2UgZmluaXNoZWQhXG4gICAgICB9IC8vIHdlIHN0aWxsIGhhdmUgbW9yZSBieXRlcywgc28gc2xpY2UgdGhlIGJ1ZmZlciB1cFxuXG5cbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShieXRlc0NvcGllZCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgfSAvLyBjaGVjayB0aGlzIGJ1ZmZlciB0byBzZWUgaWYgaXQgaW5kaWNhdGVzIHdlIG5lZWQgbW9yZSBieXRlcz9cblxuXG4gICAgY29uc3QgaW5jb21wbGV0ZUNoYXJEYXRhID0gdGhpcy5fY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKTtcblxuICAgIGlmIChpbmNvbXBsZXRlQ2hhckRhdGEuYnl0ZXNOZWVkZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyICsgYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyBubyBpbmNvbXBsZXRlIGJ5dGVzLCByZXR1cm4gYW55IGNoYXJhY3RlciB3ZSBjb21wbGV0ZWQgcGx1cyB0aGUgYnVmZmVyXG4gICAgfSAvLyBvayBzbyB0aGUgYnVmZmVyIGhvbGRzIGFuIGluY29tcGxldGUgY2hhcmFjdGVyIGF0IGl0J3MgZW5kXG5cblxuICAgIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGVDaGFyRGF0YS5jaGFyTGVuZ3RoOyAvLyByZWNvcmQgaG93IG1hbnkgYnl0ZXMgd2UgbmVlZCBmb3IgdGhlICdjaGFyYWN0ZXInXG5cbiAgICBjb25zdCBpbmNvbXBsZXRlQ2hhckluZGV4ID0gaW5jb21wbGV0ZUNoYXJEYXRhLmluZGV4OyAvLyB0aGlzIGlzIHRoZSBpbmRleCBvZiB0aGUgbXVsdGlieXRlIGNoYXJhY3RlciB0aGF0IGlzIGluY29tcGxldGVcbiAgICAvLyBjb3B5IGZyb20gaW5kZXggb2YgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgdG8gZW5kIG9mIGJ1ZmZlclxuXG4gICAgY29uc3QgYnl0ZXNUb0NvcHkgPSBidWZmZXIubGVuZ3RoIC0gaW5jb21wbGV0ZUNoYXJJbmRleDtcbiAgICBidWZmZXIuY29weSh0aGlzLmluY29tcGxldGUsIDAsIGluY29tcGxldGVDaGFySW5kZXgsIGJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gYnl0ZXNUb0NvcHk7IC8vIHJlY29yZCBob3cgbWFueSBieXRlcyB3ZSBhY3R1YWxseSBjb3BpZWRcblxuICAgIGlmIChieXRlc1RvQ29weSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIC8vIGJ1ZmZlciBoYWQgYnl0ZXMgYmVmb3JlIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgICAgLy8gc28gc211c2ggYW55IGNoYXJhY3RlciB3ZSBtYXkgaGF2ZSBjb21wbGV0ZWQgd2l0aCBhbnkgY29tcGxldGUgY2hhcmFjdGVycyBpbiB0aGUgYnVmZmVyXG4gICAgICByZXR1cm4gY2hhciArIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBpbmNvbXBsZXRlQ2hhckluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcjsgLy8gYW55IG5vdy1jb21wbGV0ZWQgY2hhcmFjdGVyIHRoYXQgd2FzIHByZXZpb3VzbHkgaW5jb21wbGV0ZSwgcG9zc2libHkgZW1wdHlcbiAgfVxuXG59XG5cbmNsYXNzIFV0ZjhTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigndXRmOCcsIDQpO1xuICB9XG5cbiAgX2NoZWNrSW5jb21wbGV0ZUJ5dGVzKGJ1ZmZlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7IC8vIEZJWE1FOiBJbiBOb2RlLCB0aGV5IGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBmaXJzdCFcbiAgICAvLyBBbmQgdGhleSByZWx5IG9uIEJ1ZmZlciN0b1N0cmluZygpIHRvIGhhbmRsZSBpbmplY3RpbmcgdGhlICdcXHVmZmZkJyBjaGFyYWN0ZXIgZm9yIGJ1c3RlZCBtdWx0aS1ieXRlIHNlcXVlbmNlcyFcbiAgICAvLyBpT1MgYXBwYXJlbnRseSBqdXN0IHJldHVybnMgdW5kZWZpbmVkIGluIHRoYXQgc3BlY2lhbCBjYXNlIGFuZFxuICAgIC8vIEFuZHJvaWQgZGlmZmVycyBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd29yayBiYWNrd2FyZHMgZnJvbSB0aGUgbGFzdCBjaGFyXG4gICAgLy8gQ2FuIHdlIGNoZWF0IGhlcmUgYW5kLi4uXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvc3RyaW5nX2RlY29kZXIvYmxvYi9tYXN0ZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzI0wxNzMtTDE5OFxuICAgIC8vIC0gaWYgd2Ugc2VlIGEgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgc3RhcnQsIHZhbGlkYXRlIHRoZSBuZXh0IGNoYXJhY3RlcnMgYXJlIGNvbnRpbnVhdGlvbiBjaGFyc1xuICAgIC8vIC0gaWYgdGhleSdyZSBub3QgcmVwbGFjZSB0aGUgc2VxdWVuY2Ugd2l0aCAnXFx1ZmZmZCcsIHRyZWF0IGxpa2UgdGhhdCBtdWx0aS1ieXRlIGNoYXJhY3RlciB3YXMgXCJjb21wbGV0ZWRcIlxuICAgIC8vIE5vdGUgdGhhdCBldmVuIGlmIHdlIGRvIGhhY2sgdGhpcywgaWYgdGhlcmUncyBzb21lIGludmFsaWQgbXVsdGktYnl0ZSBVVEYtOCBpbiB0aGUgYnVmZmVyIHRoYXQgaXNuJ3QgYXQgdGhlIGxhc3QgMyBieXRlc1xuICAgIC8vIHRoZW4gd2UncmUgYXQgdGhlIG1lcmN5IG9mIHRoZSBKUyBlbmdpbmUvcGxhdGZvcm0gY29kZSBmb3IgaGFuZGxpbmcgdGhhdFxuICAgIC8vIEhlcmUncyBzb21lb25lJ3MgaGFjayB0aGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vb2xlZ2FuemEvOTk3MTU1XG4gICAgLy8gaWYgYnVmZmVyLmxlbmd0aCA+PSAzLCBjaGVjayAzcmQgdG8gbGFzdCBieXRlXG5cbiAgICBpZiAobGVuZ3RoID49IDMpIHtcbiAgICAgIGxldCBjaGFyTGVuZ3RoID0gY2hlY2tDaGFyTGVuZ3RoRm9yVVRGOChidWZmZXJbbGVuZ3RoIC0gM10pO1xuXG4gICAgICBpZiAoY2hhckxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiAxLFxuICAgICAgICAgIC8vIHdlIGhhdmUgMyBsYXN0IGJ5dGVzLCBuZWVkIDR0aFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAzLFxuICAgICAgICAgIGNoYXJMZW5ndGg6IDRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMiwgY2hlY2sgMm5kIHRvIGxhc3QgYnl0ZVxuXG5cbiAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgIGxldCBjaGFyTGVuZ3RoID0gY2hlY2tDaGFyTGVuZ3RoRm9yVVRGOChidWZmZXJbbGVuZ3RoIC0gMl0pO1xuXG4gICAgICBpZiAoY2hhckxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYnl0ZXNOZWVkZWQ6IGNoYXJMZW5ndGggLSAyLFxuICAgICAgICAgIC8vIHdlIGhhdmUgMiBieXRlcyBvZiB3aGF0ZXZlciB3ZSBuZWVkXG4gICAgICAgICAgaW5kZXg6IGxlbmd0aCAtIDIsXG4gICAgICAgICAgY2hhckxlbmd0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gaWYgYnVmZmVyLmxlbmd0aCA+PSAxLCBjaGVjayBsYXN0IGJ5dGVcblxuXG4gICAgaWYgKGxlbmd0aCA+PSAxKSB7XG4gICAgICBsZXQgY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDFdKTtcblxuICAgICAgaWYgKGNoYXJMZW5ndGggPj0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiBjaGFyTGVuZ3RoIC0gMSxcbiAgICAgICAgICAvLyB3ZSBoYXZlIDEgYnl0ZSBvZiB3aGF0ZXZlciB3ZSBuZWVkXG4gICAgICAgICAgaW5kZXg6IGxlbmd0aCAtIDEsXG4gICAgICAgICAgY2hhckxlbmd0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gYmFzZSBjYXNlLCBubyBieXRlcyBuZWVkZWQgLSBlbmRzIG9uIGNvbXBsZXRlIGNoYXJhY3RlclxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICBpbmRleDogbGVuZ3RoIC0gMSxcbiAgICAgIGNoYXJMZW5ndGg6IDFcbiAgICB9O1xuICB9XG5cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgcmV0dXJuICdcXHVmZmZkJzsgLy8gd2UgcmVwbGFjZSB0aGUgbWlzc2luZyBjaGFyYWN0ZXIgd2l0aCBhIHNwZWNpYWwgdXRmOCBjaGFyXG4gIH1cblxufVxuXG5jbGFzcyBVdGYxNlN0cmluZ0RlY29kZXIgZXh0ZW5kcyBNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCd1dGYxNmxlJywgNCk7XG4gIH1cblxuICBfY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCBtb2R1bG8gPSBsZW5ndGggJSAyOyAvLyBvaywgd2UgaGF2ZSBhIG11bHRpcGxlIG9mIDIgYnl0ZXNcblxuICAgIGlmIChtb2R1bG8gPT09IDApIHtcbiAgICAgIC8vIGlzIHRoZSBsYXN0IGJ5dGUgYSBsZWFkaW5nL2hpZ2ggc3Vycm9nYXRlP1xuICAgICAgY29uc3QgYnl0ZSA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChieXRlID49IDB4RDggJiYgYnl0ZSA8PSAweERCKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYnl0ZXNOZWVkZWQ6IDIsXG4gICAgICAgICAgY2hhckxlbmd0aDogNCxcbiAgICAgICAgICBpbmRleDogbGVuZ3RoIC0gMlxuICAgICAgICB9O1xuICAgICAgfSAvLyB3ZSdyZSBnb29kLCBub3QgYSBzdXJyb2dhdGUsIHNvIHdlIGhhdmUgb3VyIG5lZWRlZCAyIGJ5dGVzXG5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICAgIGNoYXJMZW5ndGg6IDJcbiAgICAgIH07XG4gICAgfSAvLyBvayB3ZSBoYXZlIDEgYnl0ZSBsZWZ0IG92ZXIsIGFzc3VtZSB3ZSBuZWVkIDIgdG8gZm9ybSB0aGUgY2hhcmFjdGVyXG5cblxuICAgIHJldHVybiB7XG4gICAgICBieXRlc05lZWRlZDogMSxcbiAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgY2hhckxlbmd0aDogMlxuICAgIH07XG4gIH1cblxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICAvLyBKdXN0IHdyaXRlIG91dCB0aGUgbGFzdCBOIGJ5dGVzLCBob3BlZnVsbHkgdGhlIGVuZ2luZSBjYW4gaGFuZGxlIGl0IGZvciB1cz9cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgdGhpcy5ieXRlQ291bnQpO1xuICB9XG5cbn1cblxuY2xhc3MgQmFzZTY0U3RyaW5nRGVjb2RlciBleHRlbmRzIE11bHRpQnl0ZVN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ2Jhc2U2NCcsIDMpO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7IC8vIGFsd2F5cyAzIVxuICB9XG5cbiAgX2NoZWNrSW5jb21wbGV0ZUJ5dGVzKGJ1ZmZlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY29uc3QgbW9kdWxvID0gbGVuZ3RoICUgMzsgLy8gYmFzZTY0IG5lZWRzIDMgYnl0ZXMgYWx3YXlzLCBzbyBpZiB3ZSBoYXZlIHRoYXQgbWFueSAob3IgYSBtdWx0aXBsZSksIHdlIGhhdmUgYSBjb21wbGV0ZSBidWZmZXJcblxuICAgIGlmIChtb2R1bG8gPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5dGVzTmVlZGVkOiAwLFxuICAgICAgICBjaGFyTGVuZ3RoOiAzXG4gICAgICB9O1xuICAgIH0gLy8gb2sgd2UgaGF2ZSAxIG9yIDIgYnl0ZXMgbGVmdCBvdmVyXG5cblxuICAgIHJldHVybiB7XG4gICAgICBieXRlc05lZWRlZDogMyAtIG1vZHVsbyxcbiAgICAgIC8vIGFsd2F5cyBuZWVkIDMsIHNvIGlmIHdlIGhhdmUgMSBsZWZ0IG92ZXIgLT4gbmVlZCAyXG4gICAgICBpbmRleDogbGVuZ3RoIC0gbW9kdWxvLFxuICAgICAgY2hhckxlbmd0aDogMyAvLyBhbHdheXMgbmVlZCAzXG5cbiAgICB9O1xuICB9XG5cbiAgX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCkge1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAzOyAvLyBhbHdheXMgMyFcbiAgfVxuXG4gIF9pbmNvbXBsZXRlRW5kKCkge1xuICAgIC8vIEp1c3Qgd3JpdGUgb3V0IHRoZSBsYXN0IE4gYnl0ZXMsIGl0IHNob3VsZCBpbnNlcnQgdGhlICc9JyBwbGFjZWhvbGRlcnNcbiAgICAvLyBpdCdzIG5vdCByZWFsbHkgJ21pc3NpbmcnLydpbmNvbXBsZXRlJywganVzdCBuZWVkcyBwbGFjZWhvbGRlciBpbnNlcnRpb25cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCB0aGlzLmJ5dGVDb3VudCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjaGVja0NoYXJMZW5ndGhGb3JVVEY4KGJ5dGUpIHtcbiAgLy8gMTExMTBYWFggPT4gMTExMCA9PiAweDFFXG4gIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHtcbiAgICByZXR1cm4gNDtcbiAgfSAvLyAxMTEwWFhYWCA9PiAxMTEwID0+IDB4MUVcblxuXG4gIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHtcbiAgICByZXR1cm4gMztcbiAgfSAvLyAxMTBYWFhYWCA9PiAxMTAgPT4gMHgwNlxuXG5cbiAgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikge1xuICAgIHJldHVybiAyO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbnZhciBTdHJpbmdEZWNvZGVyJDEgPSB7XG4gIFN0cmluZ0RlY29kZXJcbn07XG5cbmNvbnN0IHByaW50ZWRXYXJuaW5ncyA9IHt9O1xuXG5mdW5jdGlvbiBvbmVUaW1lV2FybmluZyhrZXksIG1zZykge1xuICBpZiAoIXByaW50ZWRXYXJuaW5nc1trZXldKSB7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgcHJpbnRlZFdhcm5pbmdzW2tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFByaW50cyBhIG9uZS10aW1lIHdhcm5pbmcgbWVzc2FnZSB0aGF0IHdlIGRvIG5vdCBzdXBwb3J0IHRoZSBnaXZlbiBBUEkgYW5kIHBlcmZvcm1zIGFuIGVmZmVjdGl2ZSBuby1vcFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgbmFtZSBvZiB0aGUgbW9kdWxlL29iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgZnVuY3Rpb24ucHJvcGVydHkgd2UgZG9uJ3Qgc3VwcG9ydFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBuby1vcCBmdW5jdGlvblxuICovXG5cblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWROb29wKG1vZHVsZU5hbWUsIG5hbWUpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBmcW4gPSBgJHttb2R1bGVOYW1lfS4ke25hbWV9YDtcbiAgICBvbmVUaW1lV2FybmluZyhmcW4sIGBcIiR7ZnFufVwiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0IG9uIFRpdGFuaXVtIGFuZCB1c2VzIGEgbm8tb3AgZmFsbGJhY2suYCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgbmFtZSBvZiB0aGUgbW9kdWxlL29iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgZnVuY3Rpb24ucHJvcGVydHkgd2UgZG9uJ3Qgc3VwcG9ydFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2sgd2UgY2FsbCBpbiBhIHF1aWNrIHNldFRpbWVvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzeW5jVW5zdXBwb3J0ZWROb29wKG1vZHVsZU5hbWUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7IC8vIGVuZm9yY2Ugd2UgaGF2ZSBhIHZhbGlkIGNhbGxiYWNrXG5cbiAgdW5zdXBwb3J0ZWROb29wKG1vZHVsZU5hbWUsIG5hbWUpKCk7XG4gIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEpO1xufSAvLyBVc2VkIHRvIGNob29zZSB0aGUgYnVmZmVyL2NodW5rIHNpemUgd2hlbiBwdW1waW5nIGJ5dGVzIGR1cmluZyBjb3BpZXNcblxuXG5jb25zdCBDT1BZX0ZJTEVfQ0hVTktfU0laRSA9IDgwOTI7IC8vIHdoYXQgc2hvdWxkIHdlIHVzZSBoZXJlP1xuLy8gS2VlcCB0cmFjayBvZiBpbnRlZ2VyIC0+IEZpbGVTdHJlYW0gbWFwcGluZ3NcblxuY29uc3QgZmlsZURlc2NyaXB0b3JzID0gbmV3IE1hcCgpO1xubGV0IGZpbGVEZXNjcmlwdG9yQ291bnQgPSA0OyAvLyBnbG9iYWwgY291bnRlciB1c2VkIHRvIHJlcG9ydCBmaWxlIGRlc2NyaXB0b3IgaW50ZWdlcnNcbi8vIE1hcCBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3MgdG8gVGkuRmlsZXN5c3RlbS5NT0RFXyogY29uc3RhbnRzXG5cbmNvbnN0IEZMQUdTX1RPX1RJX01PREUgPSBuZXcgTWFwKCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYScsIFRpLkZpbGVzeXN0ZW0uTU9ERV9BUFBFTkQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2F4JywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYSsnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdheCsnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdhcysnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdyJywgVGkuRmlsZXN5c3RlbS5NT0RFX1JFQUQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3IrJywgVGkuRmlsZXN5c3RlbS5NT0RFX1JFQUQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3JzKycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3JywgVGkuRmlsZXN5c3RlbS5NT0RFX1dSSVRFKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3eCcsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG5GTEFHU19UT19USV9NT0RFLnNldCgndysnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3d4KycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7IC8vIENvbW1vbiBlcnJvcnNcblxuY29uc3QgcGVybWlzc2lvbkRlbmllZCA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VBQ0NFUycsICdwZXJtaXNzaW9uIGRlbmllZCcsIC0xMywgc3lzY2FsbCwgcGF0aCk7XG5cbmNvbnN0IG5vU3VjaEZpbGUgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFTk9FTlQnLCAnbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsIC0yLCBzeXNjYWxsLCBwYXRoKTtcblxuY29uc3QgZmlsZUFscmVhZHlFeGlzdHMgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFRVhJU1QnLCAnZmlsZSBhbHJlYWR5IGV4aXN0cycsIC0xNywgc3lzY2FsbCwgcGF0aCk7XG5cbmNvbnN0IG5vdEFEaXJlY3RvcnkgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFTk9URElSJywgJ25vdCBhIGRpcmVjdG9yeScsIC0yMCwgc3lzY2FsbCwgcGF0aCk7XG5cbmNvbnN0IGRpcmVjdG9yeU5vdEVtcHR5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRU5PVEVNUFRZJywgJ2RpcmVjdG9yeSBub3QgZW1wdHknLCAtNjYsIHN5c2NhbGwsIHBhdGgpO1xuXG5jb25zdCBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRUlTRElSJywgJ2lsbGVnYWwgb3BlcmF0aW9uIG9uIGEgZGlyZWN0b3J5JywgLTIxLCBzeXNjYWxsLCBwYXRoKTtcblxuY29uc3QgZnMgPSB7XG4gIGNvbnN0YW50czoge1xuICAgIE9fUkRPTkxZOiAwLFxuICAgIE9fV1JPTkxZOiAxLFxuICAgIE9fUkRXUjogMixcbiAgICBTX0lGTVQ6IDYxNDQwLFxuICAgIFNfSUZSRUc6IDMyNzY4LFxuICAgIFNfSUZESVI6IDE2Mzg0LFxuICAgIFNfSUZDSFI6IDgxOTIsXG4gICAgU19JRkJMSzogMjQ1NzYsXG4gICAgU19JRklGTzogNDA5NixcbiAgICBTX0lGTE5LOiA0MDk2MCxcbiAgICBTX0lGU09DSzogNDkxNTIsXG4gICAgT19DUkVBVDogNTEyLFxuICAgIE9fRVhDTDogMjA0OCxcbiAgICBPX05PQ1RUWTogMTMxMDcyLFxuICAgIE9fVFJVTkM6IDEwMjQsXG4gICAgT19BUFBFTkQ6IDgsXG4gICAgT19ESVJFQ1RPUlk6IDEwNDg1NzYsXG4gICAgT19OT0ZPTExPVzogMjU2LFxuICAgIE9fU1lOQzogMTI4LFxuICAgIE9fRFNZTkM6IDQxOTQzMDQsXG4gICAgT19TWU1MSU5LOiAyMDk3MTUyLFxuICAgIE9fTk9OQkxPQ0s6IDQsXG4gICAgU19JUldYVTogNDQ4LFxuICAgIFNfSVJVU1I6IDI1NixcbiAgICBTX0lXVVNSOiAxMjgsXG4gICAgU19JWFVTUjogNjQsXG4gICAgU19JUldYRzogNTYsXG4gICAgU19JUkdSUDogMzIsXG4gICAgU19JV0dSUDogMTYsXG4gICAgU19JWEdSUDogOCxcbiAgICBTX0lSV1hPOiA3LFxuICAgIFNfSVJPVEg6IDQsXG4gICAgU19JV09USDogMixcbiAgICBTX0lYT1RIOiAxLFxuICAgIEZfT0s6IDAsXG4gICAgUl9PSzogNCxcbiAgICBXX09LOiAyLFxuICAgIFhfT0s6IDEsXG4gICAgVVZfRlNfQ09QWUZJTEVfRVhDTDogMSxcbiAgICBDT1BZRklMRV9FWENMOiAxXG4gIH1cbn07XG5cbmNsYXNzIFN0YXRzIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xuICAgIHRoaXMuZGV2ID0gMDtcbiAgICB0aGlzLmlubyA9IDA7XG4gICAgdGhpcy5tb2RlID0gMDtcbiAgICB0aGlzLm5saW5rID0gMDtcbiAgICB0aGlzLnVpZCA9IDA7XG4gICAgdGhpcy5naWQgPSAwO1xuICAgIHRoaXMucmRldiA9IDA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLmJsa3NpemUgPSA0MDk2OyAvLyBGSVhNRTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMxNTMxMS93aGF0LWlzLXRoZS1ibG9jay1zaXplLW9mLXRoZS1pcGhvbmUtZmlsZXN5c3RlbVxuXG4gICAgdGhpcy5ibG9ja3MgPSAwO1xuICAgIHRoaXMuYXRpbWVNcyA9IHRoaXMubXRpbWVNcyA9IHRoaXMuY3RpbWVNcyA9IHRoaXMuYmlydGh0aW1lTXMgPSAwO1xuICAgIHRoaXMuYXRpbWUgPSB0aGlzLm10aW1lID0gdGhpcy5jdGltZSA9IHRoaXMuYmlydGh0aW1lID0gbmV3IERhdGUoMCk7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdGhpcy5fZmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpOyAvLyBUT0RPOiB1c2UgbGF6eSBnZXR0ZXJzIGhlcmU/XG5cbiAgICAgIHRoaXMuY3RpbWUgPSB0aGlzLmJpcnRodGltZSA9IHRoaXMuX2ZpbGUuY3JlYXRlZEF0KCk7XG4gICAgICB0aGlzLmF0aW1lID0gdGhpcy5tdGltZSA9IHRoaXMuX2ZpbGUubW9kaWZpZWRBdCgpO1xuICAgICAgdGhpcy5hdGltZU1zID0gdGhpcy5hdGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmJpcnRodGltZU1zID0gdGhpcy5iaXJ0aHRpbWUuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5jdGltZU1zID0gdGhpcy5jdGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLm10aW1lTXMgPSB0aGlzLm10aW1lLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2ZpbGUuc2l6ZTtcbiAgICAgIHRoaXMuYmxvY2tzID0gTWF0aC5jZWlsKHRoaXMuc2l6ZSAvIHRoaXMuYmxrc2l6ZSk7IC8vIFRPRE86IENhbiB3ZSBmYWtlIG91dCB0aGUgbW9kZSBiYXNlZCBvbiB0aGUgcmVhZG9ubHkvd3JpdGFibGUvZXhlY3V0YWJsZSBwcm9wZXJ0aWVzP1xuICAgIH1cbiAgfVxuXG4gIGlzRmlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5pc0ZpbGUoKTtcbiAgfVxuXG4gIGlzRGlyZWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlLmlzRGlyZWN0b3J5KCk7XG4gIH1cblxuICBpc0Jsb2NrRGV2aWNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzQ2hhcmFjdGVyRGV2aWNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzU3ltYm9saWNMaW5rKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlLnN5bWJvbGljTGluaztcbiAgfVxuXG4gIGlzRklGTygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc1NvY2tldCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuXG5mcy5TdGF0cyA9IFN0YXRzO1xuXG5jbGFzcyBSZWFkU3RyZWFtIHt9XG5cbmZzLlJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtO1xuXG5jbGFzcyBXcml0ZVN0cmVhbSB7fVxuXG5mcy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtO1xuLyoqXG4gKiBAY2FsbGJhY2sgc3RhdHNDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ZzLlN0YXRzfSBzdGF0cyAtIGZpbGUgc3RhdHNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTHxCdWZmZXJ9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFttb2RlPWZzLmNvbnN0YW50cy5GX09LXSBhY2Nlc3NpYmlsaXR5IG1vZGUvY2hlY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuZnMuYWNjZXNzID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbW9kZTtcbiAgICBtb2RlID0gZnMuY29uc3RhbnRzLkZfT0s7XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMuYWNjZXNzU3luYyhwYXRoLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTHxCdWZmZXJ9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFttb2RlPWZzLmNvbnN0YW50cy5GX09LXSBhY2Nlc3NpYmlsaXR5IG1vZGUvY2hlY2tcbiAqL1xuXG5cbmZzLmFjY2Vzc1N5bmMgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSA9IGZzLmNvbnN0YW50cy5GX09LKSB7XG4gIC8vIEZfT0sgaXMganVzdCB3aGV0aGVyIGZpbGUgZXhpc3RzIG9yIG5vdCwgbm8gcGVybWlzc2lvbnMgY2hlY2tcbiAgLy8gUl9PSyBpcyByZWFkIGNoZWNrXG4gIC8vIFdfT0sgaXMgd3JpdGUgY2hlY2tcbiAgLy8gWF9PSyBpcyBleGVjdXRlIGNoZWNrIChhY3RzIGxpa2UgRl9PSyBvbiBXaW5kb3dzKVxuICBjb25zdCBmaWxlSGFuZGxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgaWYgKCFmaWxlSGFuZGxlLmV4aXN0cygpKSB7XG4gICAgdGhyb3cgbm9TdWNoRmlsZSgnYWNjZXNzJywgcGF0aCk7XG4gIH0gLy8gVE9ETzogV2UgaGF2ZSBubyBtZWFucyBvZiB0ZXN0aW5nIGlmIGEgZmlsZSBpcyByZWFkYWJsZS4gSXQncyBhc3N1bWVkIGFsbCBmaWxlcyB0aGF0IGV4aXN0IHVuZGVyIHRoZSBhcHAgYXJlP1xuXG5cbiAgaWYgKG1vZGUgJiBmcy5jb25zdGFudHMuV19PSyAmJiAhZmlsZUhhbmRsZS53cml0YWJsZSkge1xuICAgIHRocm93IHBlcm1pc3Npb25EZW5pZWQoJ2FjY2VzcycsIHBhdGgpO1xuICB9XG5cbiAgaWYgKG1vZGUgJiBmcy5jb25zdGFudHMuWF9PSyAmJiAhZmlsZUhhbmRsZS5leGVjdXRhYmxlICYmIGZpbGVIYW5kbGUuaXNGaWxlKCkpIHtcbiAgICB0aHJvdyBwZXJtaXNzaW9uRGVuaWVkKCdhY2Nlc3MnLCBwYXRoKTtcbiAgfVxufTtcbi8qKlxuICogQXN5bmNocm9ub3VzbHkgYXBwZW5kIGRhdGEgdG8gYSBmaWxlLCBjcmVhdGluZyB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuIGRhdGEgY2FuIGJlIGEgc3RyaW5nIG9yIGEgQnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxGaWxlU3RyZWFtfSBmaWxlIGZpbGVwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSBkYXRhIHRvIGFwcGVuZCB0byBmaWxlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzY2Nl0gbW9kZSB0byBjcmVhdGUgZmlsZSwgaWYgbm90IGNyZWF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdhJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBiYWNrIHdpdGggZXJyb3IgaWYgZmFpbGVkXG4gKi9cblxuXG5mcy5hcHBlbmRGaWxlID0gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogMG82NjYsXG4gICAgZmxhZzogJ2EnXG4gIH0pO1xuICBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogU3luY2hyb25vdXNseSBhcHBlbmQgZGF0YSB0byBhIGZpbGUsIGNyZWF0aW5nIHRoZSBmaWxlIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC4gZGF0YSBjYW4gYmUgYSBzdHJpbmcgb3IgYSBCdWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfEZpbGVTdHJlYW19IGZpbGUgZmlsZXBhdGggdG8gZmlsZVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIGRhdGEgdG8gYXBwZW5kIHRvIGZpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBtb2RlIHRvIGNyZWF0ZSBmaWxlLCBpZiBub3QgY3JlYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J2EnXSBmaWxlIHN5c3RlbSBmbGFnXG4gKi9cblxuXG5mcy5hcHBlbmRGaWxlU3luYyA9IChmaWxlLCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICdhJ1xuICB9KTtcbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCBkYXRhLCBvcHRpb25zKTsgLy8gVE9ETzogVXNlIFRpLkZpbGVzeXN0ZW0uRmlsZS5hcHBlbmQoKSBpbnN0ZWFkP1xufTtcblxuZnMuY2htb2QgPSAocGF0aCwgbW9kZSwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG1vZCcsIGNhbGxiYWNrKTtcblxuZnMuY2htb2RTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG1vZFN5bmMnKTtcblxuZnMuY2hvd24gPSAocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnY2hvd24nLCBjYWxsYmFjayk7XG5cbmZzLmNob3duU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnY2hvd25TeW5jJyk7XG4vKipcbiAqIENhbGxiYWNrIGZvciBmdW5jdGlvbnMgdGhhdCBjYW4gb25seSB0aHJvdyBlcnJvcnNcbiAqXG4gKiBAY2FsbGJhY2sgZXJyb3JDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gW2Vycl0gLSBFcnJvciB0aHJvd25cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuZnMuY2xvc2UgPSAoZmQsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuXG5cbmZzLmNsb3NlU3luYyA9IGZkID0+IHtcbiAgY29uc3Qgc3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIHN0cmVhbS5jbG9zZSgpO1xufTsgLy8gUmF0aGVyIHRoYW4gdXNlIGEgaGFjayB0byB3cmFwIHN5bmMgdmVyc2lvbiBpbiBzZXRUaW1lb3V0LCB1c2UgYWN0dWFsIGFzeW5jIEFQSXMhXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gc3JjIHNvdXJjZSBmaWxlbmFtZSB0byBjb3B5XG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBkZXN0IGRlc3RpbmF0aW9uIGZpbGVuYW1lIG9mIHRoZSBjb3B5IG9wZXJhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtmbGFncz0wXSBtb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxlZCBhdCBlbmQgb2Ygb3BlcmF0aW9uXG4gKi9cblxuXG5mcy5jb3B5RmlsZSA9IGZ1bmN0aW9uIChzcmMsIGRlc3QsIGZsYWdzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGZsYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBmbGFncztcbiAgICBmbGFncyA9IDA7XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spOyAvLyBGSVhNRTogSSBkb24ndCBrbm93IHdoeSwgYnV0IGNoYW5naW5nIHRoaXMgdG8gdXNlIFRpLkZpbGVzeXN0ZW0ub3BlblN0cmVhbShtb2RlLCBwYXRoKSBmYWlscyAoYXQgbGVhc3Qgb24gaU9TKVxuXG4gIGNvbnN0IHNyY0ZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoc3JjKTtcbiAgY29uc3Qgc3JjU3RyZWFtID0gc3JjRmlsZS5vcGVuKFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbiAgY29uc3QgZGVzdEZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoZGVzdCk7XG4gIGNvbnN0IGRlc3RTdHJlYW0gPSBkZXN0RmlsZS5vcGVuKFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG4gIHBpcGUoc3JjU3RyZWFtLCBkZXN0U3RyZWFtLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBzcmMgc291cmNlIGZpbGVuYW1lIHRvIGNvcHlcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IGRlc3QgZGVzdGluYXRpb24gZmlsZW5hbWUgb2YgdGhlIGNvcHkgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZsYWdzPTBdIG1vZGlmaWVycyBmb3IgY29weSBvcGVyYXRpb25cbiAqL1xuXG5cbmZzLmNvcHlGaWxlU3luYyA9IGZ1bmN0aW9uIChzcmMsIGRlc3QsIGZsYWdzID0gMCkge1xuICBjb25zdCBzcmNGaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKHNyYyk7XG5cbiAgaWYgKGZsYWdzID09PSBmcy5jb25zdGFudHMuQ09QWUZJTEVfRVhDTCAmJiBmcy5leGlzdHNTeW5jKGRlc3QpKSB7XG4gICAgdGhyb3cgZmlsZUFscmVhZHlFeGlzdHMoJ2NvcHlGaWxlJywgZGVzdCk7XG4gIH1cblxuICBpZiAoIXNyY0ZpbGUuY29weShkZXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvcHkgJHtzcmN9IHRvICR7ZGVzdH1gKTsgLy8gRklYTUU6IFdoYXQgZXJyb3Igc2hvdWxkIHdlIGdpdmU/XG4gIH1cbn07IC8vIFRPRE86IGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucylcbi8vIC8qKlxuLy8gICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIGxpa2Vcbi8vICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMsIGlmIGEgc3RyaW5nLCBpdCdzIHRoZSBlbmNvZGluZ1xuLy8gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWdzPSdyJ10gU2VlIHN1cHBvcnQgb2YgZmlsZSBzeXN0ZW0gZmxhZ3MuXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9bnVsbF0gZW5jb2Rpbmdcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuZmQ9bnVsbF0gZmlsZSBkZXNjcmlwdG9yLCBpZiBzcGVjaWZpZWQsIGBwYXRoYCBpcyBpZ25vcmVkXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLm1vZGU9MG82NjZdIHBlcm1pc3Npb25zIHRvIHNldCBpZiBmaWxlIGlzIGNyZWF0ZWRcbi8vICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0Nsb3NlPXRydWVdIGlmIGZhbHNlLCBmaWxlIGRlc2NyaXB0b3Igd2lsbCBub3QgYmUgY2xvc2VkOyBpZiB0cnVlIGV2ZW4gb24gZXJyb3IgaXQgd2lsbCBiZSBjbG9zZWRcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuc3RhcnRdIHN0YXJ0IGluZGV4IG9mIHJhbmdlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBmaWxlXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmVuZD1JbmZpbml0eV0gZW5kIGluZGV4IG9mIHJhbmdlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBmaWxlXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmhpZ2hXYXRlck1hcms9NjQgKiAxMDI0XVxuLy8gICogQHJldHVybnMge2ZzLlJlYWRTdHJlYW19XG4vLyAgKi9cbi8vIGZzLmNyZWF0ZVJlYWRTdHJlYW0gPSAocGF0aCwgb3B0aW9ucykgPT4ge1xuLy8gXHRvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7IGZsYWdzOiAncicsIGVuY29kaW5nOiBudWxsLCBmZDogbnVsbCwgbW9kZTogMG82NjYsIGF1dG9DbG9zZTogdHJ1ZSwgZW5kOiBJbmZpbml0eSwgaGlnaFdhdGVyTWFyazogNjQgKiAxMDI0IH0pO1xuLy8gXHQvLyBGSVhNRTogSWYgb3B0aW9ucy5mZCwgdXNlIHRoYXQgaW4gcGxhY2Ugb2YgcGF0aCFcbi8vIFx0Y29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG4vLyB9O1xuLy8gVE9ETzogZnMuY3JlYXRlV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucylcblxuLyoqXG4gKiBAY2FsbGJhY2sgZXhpc3RzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhpc3RzIC0gd2hldGhlciBwYXRoIGV4aXN0c1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCB0byBjaGVja1xuICogQHBhcmFtIHtleGlzdHNDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cblxuZnMuZXhpc3RzID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNhbGxiYWNrKGZzLmV4aXN0c1N5bmMocGF0aCkpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGEgZmlsZSBvciBkaXJlY3RvcnkgZXhpc3RzIGF0IHRoYXQgcGF0aFxuICovXG5cblxuZnMuZXhpc3RzU3luYyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIHRyeSB7XG4gICAgZnMuYWNjZXNzU3luYyhwYXRoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnMuZmNobW9kID0gKGZkLCBtb2RlLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG1vZCcsIGNhbGxiYWNrKTtcblxuZnMuZmNobW9kU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmNobW9kU3luYycpO1xuXG5mcy5mY2hvd24gPSAoZmQsIHVpZCwgZ2lkLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG93bicsIGNhbGxiYWNrKTtcblxuZnMuZmNob3duU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmNob3duU3luYycpO1xuXG5mcy5mZGF0YXN5bmMgPSAoZmQsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmRhdGFzeW5jJywgY2FsbGJhY2spO1xuXG5mcy5mZGF0YXN5bmNTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdmZGF0YXN5bmNTeW5jJyk7XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmlnaW50XSB3aGV0aGVyIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBiaWdpbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuZnMuZnN0YXQgPSAoZmQsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsZXQgc3RhdHM7XG5cbiAgICB0cnkge1xuICAgICAgc3RhdHMgPSBmcy5mc3RhdFN5bmMoZmQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHN0YXRzKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R9IFtfb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbX29wdGlvbnMuYmlnaW50XSB3aGV0aGVyIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBiaWdpbnRcbiAqIEByZXR1cm5zIHtmcy5TdGF0c30gc3RhdHMgZm9yIGZpbGUgZGVzY3JpcHRvclxuICovXG5cblxuZnMuZnN0YXRTeW5jID0gKGZkLCBfb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXRoID0gcGF0aEZvckZpbGVEZXNjcmlwdG9yKGZkKTtcbiAgcmV0dXJuIGZzLnN0YXRTeW5jKHBhdGgpO1xufTsgLy8gVE9ETzogQWRkIHZlcnNpb25zIG9mIHRoZXNlIEFQSXM6XG4vLyBmcy5mc3luYyhmZCwgY2FsbGJhY2spXG4vLyBmcy5mc3luY1N5bmMoZmQpXG4vLyBmcy5mdHJ1bmNhdGUoZmRbLCBsZW5dLCBjYWxsYmFjaylcbi8vIGZzLmZ0cnVuY2F0ZVN5bmMoZmRbLCBsZW5dKVxuLy8gZnMuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaylcbi8vIGZzLmZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpXG4vLyBmcy5sY2htb2QocGF0aCwgbW9kZSwgY2FsbGJhY2spXG4vLyBmcy5sY2htb2RTeW5jKHBhdGgsIG1vZGUpXG4vLyBmcy5sY2hvd24ocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKVxuLy8gZnMubGNob3duU3luYyhwYXRoLCB1aWQsIGdpZClcbi8vIGZzLmxpbmsoZXhpc3RpbmdQYXRoLCBuZXdQYXRoLCBjYWxsYmFjaylcbi8vIGZzLmxpbmtTeW5jKGV4aXN0aW5nUGF0aCwgbmV3UGF0aClcbi8vIEZJWE1FOiBJZiBzeW1ib2xpYyBsaW5rIHdlIG5lZWQgdG8gZm9sbG93IGxpbmsgdG8gdGFyZ2V0IHRvIGdldCBzdGF0cyEgT3VyIEFQSSBkb2Vzbid0IHN1cHBvcnQgdGhhdCFcblxuXG5mcy5sc3RhdCA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4gZnMuc3RhdChwYXRoLCBvcHRpb25zLCBjYWxsYmFjayk7XG5cbmZzLmxzdGF0U3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiBmcy5zdGF0U3luYyhwYXRoLCBvcHRpb25zKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVjdXJzaXZlPWZhbHNlXSByZWN1cnNpdmxleSBjcmVhdGUgZGlycz9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzc3N10gcGVybWlzc2lvbnNcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLm1rZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge1xuICAgICAgcmVjdXJzaXZlOiBmYWxzZSxcbiAgICAgIG1vZGU6IDBvNzc3XG4gICAgfTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGF0aCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVjdXJzaXZlPWZhbHNlXSByZWN1cnNpdmxleSBjcmVhdGUgZGlycz9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzc3N10gcGVybWlzc2lvbnNcbiAqL1xuXG5cbmZzLm1rZGlyU3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcmVjdXJzaXZlOiBmYWxzZSxcbiAgICAgIG1vZGU6IG9wdGlvbnNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG4gICAgICBtb2RlOiAwbzc3N1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCF0aUZpbGUuY3JlYXRlRGlyZWN0b3J5KG9wdGlvbnMucmVjdXJzaXZlKSAmJiAhb3B0aW9ucy5yZWN1cnNpdmUpIHtcbiAgICBpZiAodGlGaWxlLmV4aXN0cygpKSB7XG4gICAgICAvLyBhbHJlYWR5IGV4aXN0ZWQhXG4gICAgICB0aHJvdyBmaWxlQWxyZWFkeUV4aXN0cygnbWtkaXInLCBwYXRoKTtcbiAgICB9IC8vIFdlIGZhaWxlZCwgcHJvYmFibHkgYmVjYXVzZSB3ZSBkaWRuJ3QgYXNrIGZvciByZWN1cnNpdmUgYW5kIHBhcmVudCBkb2Vzbid0IGV4aXN0LCBzbyByZXByb2R1Y2Ugbm9kZSdzIGVycm9yXG5cblxuICAgIHRocm93IG5vU3VjaEZpbGUoJ21rZGlyJywgcGF0aCk7XG4gIH1cbn07XG4vKipcbiAqIEBjYWxsYmFjayB0ZW1wRGlyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIGdlbmVyYXRlZCBmb2xkZXIgbmFtZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBkaXJlY3RvcnkgbmFtZSBwcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBwcmVmaXggZW5jb2RpbmdcbiAqIEBwYXJhbSB7dGVtcERpckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMubWtkdGVtcCA9IChwcmVmaXgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShwcmVmaXgsICdwcmVmaXgnLCAnc3RyaW5nJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0Zi04J1xuICB9KTsgLy8gdHJ5IHRvIGJlIGFsbCBhc3luY1xuXG4gIGNvbnN0IHRyeU1rZHRlbXAgPSAoKSA9PiB7XG4gICAgY29uc3QgZ2VuZXJhdGVkID0gcmFuZG9tQ2hhcmFjdGVycyg2LCBvcHRpb25zLmVuY29kaW5nKTsgLy8gZ2VuZXJhdGUgc2l4IHJhbmRvbSBjaGFyYWN0ZXJzXG5cbiAgICBjb25zdCBwYXRoID0gYCR7cHJlZml4fSR7Z2VuZXJhdGVkfWA7XG4gICAgZnMubWtkaXIocGF0aCwgMG83MDAsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VFWElTVCcpIHtcbiAgICAgICAgICAvLyByZXRyeSFcbiAgICAgICAgICBzZXRUaW1lb3V0KHRyeU1rZHRlbXAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBidWJibGUgdXAgZXJyb3JcblxuXG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gc3VjY2VlZGVkISBIdXJyYXkhXG5cblxuICAgICAgY2FsbGJhY2sobnVsbCwgcGF0aCk7XG4gICAgfSk7XG4gIH07XG5cbiAgc2V0VGltZW91dCh0cnlNa2R0ZW1wLCAxKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSB1bmlxdWUgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggZGlyZWN0b3J5IG5hbWUgcHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0Zi04J10gcHJlZml4IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwYXRoIHRvIGNyZWF0ZWQgZGlyZWN0b3J5XG4gKi9cblxuXG5mcy5ta2R0ZW1wU3luYyA9IChwcmVmaXgsIG9wdGlvbnMpID0+IHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHByZWZpeCwgJ3ByZWZpeCcsICdzdHJpbmcnKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmLTgnXG4gIH0pO1xuICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gIGNvbnN0IE1BWF9SRVRSSUVTID0gMTAwO1xuXG4gIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICBjb25zdCBnZW5lcmF0ZWQgPSByYW5kb21DaGFyYWN0ZXJzKDYsIG9wdGlvbnMuZW5jb2RpbmcpOyAvLyBnZW5lcmF0ZSBzaXggcmFuZG9tIGNoYXJhY3RlcnNcblxuICAgIGNvbnN0IHBhdGggPSBgJHtwcmVmaXh9JHtnZW5lcmF0ZWR9YDtcblxuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGF0aCwgMG83MDApOyAvLyBkb24ndCB0cnkgcmVjdXJzaXZlXG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdFRVhJU1QnKSB7XG4gICAgICAgIHRocm93IGU7IC8vIGJ1YmJsZSB1cCBlcnJvclxuICAgICAgfSAvLyBuYW1lIHdhcyBub3QgdW5pcXVlLCBzbyByZXRyeVxuXG5cbiAgICAgIHJldHJ5Q291bnQrKztcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgYSB1bmlxdWUgZGlyZWN0b3J5IG5hbWUgd2l0aCBwcmVmaXggJHtwcmVmaXh9YCk7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZURlc2NyaXB0b3JDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZpbGVEZXNjcmlwdG9yIC0gZ2VuZXJhdGVkIGZpbGUgZGVzY3JpcHRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3M9J3InXSBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3NcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW21vZGU9MG82NjZdIGZpbGUgbW9kZSB0byB1c2Ugd2hlbiBjcmVhdGluZyBmaWxlXG4gKiBAcGFyYW0ge2ZpbGVEZXNjcmlwdG9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5vcGVuID0gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYWxsYmFjaykgPT4ge1xuICAvLyBmbGFncyBhbmQgbW9kZSBhcmUgb3B0aW9uYWwsIHdlIG5lZWQgdG8gaGFuZGxlIGlmIG5vdCBzdXBwbGllZCFcbiAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZmxhZ3M7XG4gICAgZmxhZ3MgPSAncic7XG4gICAgbW9kZSA9IDBvNjY2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtb2RlO1xuICAgIG1vZGUgPSAwbzY2NjtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxldCBmaWxlRGVzY3JpcHRvcjtcblxuICAgIHRyeSB7XG4gICAgICBmaWxlRGVzY3JpcHRvciA9IGZzLm9wZW5TeW5jKHBhdGgsIGZsYWdzLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBmaWxlRGVzY3JpcHRvcik7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3M9J3InXSBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3NcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW19tb2RlPTBvNjY2XSBmaWxlIG1vZGUgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZmlsZVxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5mcy5vcGVuU3luYyA9IChwYXRoLCBmbGFncyA9ICdyJywgX21vZGUgPSAwbzY2NikgPT4ge1xuICBjb25zdCB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcblxuICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgIC8vIFRPRE86IFN1cHBvcnQgY3JlYXRpbmcgZmlsZSB3aXRoIHNwZWNpZmljIG1vZGVcbiAgICBvbmVUaW1lV2FybmluZygnZnMub3BlblN5bmMubW9kZScsICdmcy5vcGVuU3luY1xcJ3MgbW9kZSBwYXJhbWV0ZXIgaXMgdW5zdXBwb3J0ZWQgaW4gVGl0YW5pdW0gYW5kIHdpbGwgYmUgaWdub3JlZCcpO1xuXG4gICAgaWYgKCF0aUZpbGUuY3JlYXRlRmlsZSgpKSB7XG4gICAgICAvLyBPaCBjcmFwLCB3ZSBmYWlsZWQgdG8gY3JlYXRlIHRoZSBmaWxlLiB3aHk/XG4gICAgICBpZiAoIXRpRmlsZS5wYXJlbnQuZXhpc3RzKCkpIHtcbiAgICAgICAgLy8gcGFyZW50IGRvZXMgbm90IGV4aXN0IVxuICAgICAgICB0aHJvdyBub1N1Y2hGaWxlKCdvcGVuJywgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNyZWF0ZSBmaWxlIGF0IHBhdGggJHtwYXRofWApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmbGFncykge1xuICAgIC8vIGZpbGUvZGlyIGV4aXN0cy4uLlxuICAgIGlmICgoZmxhZ3MuY2hhckF0KDApID09PSAndycgfHwgZmxhZ3MuY2hhckF0KDApID09PSAnYScpICYmIHRpRmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAvLyBJZiB1c2VyIGlzIHRyeWluZyB0byB3cml0ZSBvciBhcHBlbmQgYW5kIGl0J3MgYSBkaXJlY3RvcnksIGZhaWxcbiAgICAgIHRocm93IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ29wZW4nLCBwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MubGVuZ3RoID4gMSAmJiBmbGFncy5jaGFyQXQoMSkgPT09ICd4Jykge1xuICAgICAgLy8gSWYgdXNlciBoYXMgXCJleGNsdXNpdmVcIiBmbGFnIG9uLCBmYWlsIGlmIGZpbGUgYWxyZWFkeSBleGlzdHNcbiAgICAgIHRocm93IGZpbGVBbHJlYWR5RXhpc3RzKCdvcGVuJywgcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdGlNb2RlID0gRkxBR1NfVE9fVElfTU9ERS5nZXQoZmxhZ3MpO1xuXG4gIGlmICh0aU1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IE1ha2UgdXNlIG9mIGNvbW1vbiBlcnJvciB0eXBlL2NvZGUgZm9yIHRoaXMgb25jZSB3ZSBoYXZlIGludGVybmFsL2Vycm9ycy5qc1xuICAgIGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoYFRoZSB2YWx1ZSBcIiR7U3RyaW5nKGZsYWdzKX1cIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJmbGFnc1wiYCk7XG4gICAgZXJyLmNvZGUgPSAnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJztcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRmlsZURlc2NyaXB0b3IocGF0aCwgdGlGaWxlLm9wZW4odGlNb2RlKSk7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgcmVhZENhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZXNSZWFkIC0gbnVtYmVyIG9mIGJ5dGVzIHJlYWRcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgYnVmZmVyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ8VGkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHRvIHJlYWQgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgYXQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBwb3NpdGlvbiB3aGVyZSB0byBiZWdpbiByZWFkaW5nIGZyb20gaW4gdGhlIGZpbGVcbiAqIEBwYXJhbSB7cmVhZENhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMucmVhZCA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICB9IC8vIEZJWE1FOiBBbGxvdyB1c2luZyBwb3NpdGlvbiBhcmd1bWVudCFcblxuXG4gIGlmIChwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgIG9uZVRpbWVXYXJuaW5nKCdmcy5yZWFkU3luYy5wb3NpdGlvbicsICdmcy5yZWFkU3luY1xcJ3MgcG9zaXRpb24gYXJndW1lbnQgaXMgdW5zdXBwb3J0ZWQgYnkgVGl0YW5pdW0gYW5kIHdpbGwgYmUgdHJlYXRlZCBhcyBudWxsJyk7XG4gIH1cblxuICB0aUZpbGVTdHJlYW0ucmVhZChidWZmZXIudG9UaUJ1ZmZlcigpLCBvZmZzZXQsIGxlbmd0aCwgcmVhZE9iaiA9PiB7XG4gICAgaWYgKCFyZWFkT2JqLnN1Y2Nlc3MpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihyZWFkT2JqLmVycm9yKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgcmVhZE9iai5ieXRlc1Byb2Nlc3NlZCwgYnVmZmVyKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ8VGkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHRvIHJlYWQgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgYXQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBfcG9zaXRpb24gd2hlcmUgdG8gYmVnaW4gcmVhZGluZyBmcm9tIGluIHRoZSBmaWxlXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gYnl0ZXMgcmVhZFxuICovXG5cblxuZnMucmVhZFN5bmMgPSAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIF9wb3NpdGlvbikgPT4ge1xuICBjb25zdCBmaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG4gIH0gLy8gRklYTUU6IEFsbG93IHVzaW5nIHBvc2l0aW9uIGFyZ3VtZW50IVxuXG5cbiAgaWYgKF9wb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgIG9uZVRpbWVXYXJuaW5nKCdmcy5yZWFkU3luYy5wb3NpdGlvbicsICdmcy5yZWFkU3luY1xcJ3MgcG9zaXRpb24gYXJndW1lbnQgaXMgdW5zdXBwb3J0ZWQgYnkgVGl0YW5pdW0gYW5kIHdpbGwgYmUgdHJlYXRlZCBhcyBudWxsJyk7XG4gIH1cblxuICByZXR1cm4gZmlsZVN0cmVhbS5yZWFkKGJ1ZmZlci50b1RpQnVmZmVyKCksIG9mZnNldCwgbGVuZ3RoKTtcbn07XG4vKipcbiAqIEBjYWxsYmFjayBmaWxlc0NhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7c3RyaW5nW118QnVmZmVyW118ZnMuRGlyZW50W119IGZpbGVzIC0gZmlsZSBsaXN0aW5nXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBkaXJlY3RvcnkgdG8gbGlzdFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGY4J10gZW5jb2RpbmcgdG8gdXNlIGZvciBmaWxlbmFtZXMsIGlmIGAnYnVmZmVyJ2AsIHJldHVybnMgYEJ1ZmZlcmAgb2JqZWN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53aXRoRmlsZVR5cGVzPWZhbHNlXSBpZiB0cnVlLCByZXR1cm5zIGBmcy5EaXJlbnRgIG9iamVjdHNcbiAqIEBwYXJhbSB7ZmlsZXNDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJlYWRkaXIgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZnMucmVhZGRpclN5bmMocGF0aCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggZGlyZWN0b3J5IHRvIGxpc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZSBmb3IgZmlsZW5hbWVzLCBpZiBgJ2J1ZmZlcidgLCByZXR1cm5zIGBCdWZmZXJgIG9iamVjdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2l0aEZpbGVUeXBlcz1mYWxzZV0gaWYgdHJ1ZSwgcmV0dXJucyBgZnMuRGlyZW50YCBvYmplY3RzXG4gKiBAcmV0dXJucyB7c3RyaW5nW118QnVmZmVyW118ZnMuRGlyZW50W119XG4gKi9cblxuXG5mcy5yZWFkZGlyU3luYyA9IChmaWxlcGF0aCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBmaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUoZmlsZXBhdGgpO1xuXG4gIGlmICghZmlsZS5leGlzdHMoKSkge1xuICAgIHRocm93IG5vU3VjaEZpbGUoJ3NjYW5kaXInLCBmaWxlcGF0aCk7XG4gIH1cblxuICBpZiAoIWZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgIHRocm93IG5vdEFEaXJlY3RvcnkoJ3NjYW5kaXInLCBmaWxlcGF0aCk7XG4gIH1cblxuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgd2l0aEZpbGVUeXBlczogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGxpc3RpbmcgPSBmaWxlLmdldERpcmVjdG9yeUxpc3RpbmcoKTtcblxuICBpZiAob3B0aW9ucy53aXRoRmlsZVR5cGVzID09PSB0cnVlKSB7XG4gICAgLy8gVE9ETzogaWYgb3B0aW9ucy53aXRoRmlsZVR5cGVzID09PSB0cnVlLCByZXR1cm4gZnMuRGlyZW50IG9iamVjdHNcbiAgICBvbmVUaW1lV2FybmluZygnZnMucmVhZGRpclxcJ3Mgb3B0aW9ucy53aXRoRmlsZVR5cGVzIGlzIHVuc3VwcG9ydGVkIGJ5IFRpdGFuaXVtIGFuZCBzdHJpbmdzIHdpbGwgYmUgcmV0dXJuZWQnKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgIHJldHVybiBsaXN0aW5nLm1hcChuYW1lID0+IEJ1ZmZlci5mcm9tKG5hbWUpKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0aW5nO1xufTtcbi8qKlxuICogQGNhbGxiYWNrIHJlYWRGaWxlUG9zdE9wZW5DYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gYnVmZmVyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZpbGVEZXNjcmlwdG9yIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtyZWFkRmlsZVBvc3RPcGVuQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mdW5jdGlvbiByZWFkRmlsZVBvc3RPcGVuKGZpbGVEZXNjcmlwdG9yLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBmcy5mc3RhdChmaWxlRGVzY3JpcHRvciwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGVTaXplID0gc3RhdHMuc2l6ZTsgLy8gQ3JlYXRlIGEgVGkuQnVmZmVyIHRvIHJlYWQgaW50b1xuXG4gICAgY29uc3QgYnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICAgIGxlbmd0aDogZmlsZVNpemVcbiAgICB9KTsgLy8gVXNlIFRpLlN0cmVhbS5yZWFkQWxsKHNvdXJjZVN0cmVhbSwgYnVmZmVyLCBjYWxsYmFjaykgd2hpY2ggc3BpbnMgb2ZmIGEgc2VwYXJhdGUgdGhyZWFkIHRvIHJlYWQgaW4gd2hpbGUgbG9vcCFcblxuICAgIGNvbnN0IHNvdXJjZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3IpO1xuICAgIFRpLlN0cmVhbS5yZWFkQWxsKHNvdXJjZVN0cmVhbSwgYnVmZmVyLCByZWFkQWxsT2JqID0+IHtcbiAgICAgIGlmICghcmVhZEFsbE9iai5zdWNjZXNzKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihyZWFkQWxsT2JqLmVycm9yKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgYnVmZmVyKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIEBjYWxsYmFjayByZWFkRmlsZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICovXG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVhZCBlbnRpcmUgY29udGVudHMgb2YgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxpbnRlZ2VyfSBwYXRoIGZpbGVuYW1lIG9yIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPW51bGxdIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J3InXSBmaWxlIHN5c3RlbSBmbGFnXG4gKiBAcGFyYW0ge3JlYWRGaWxlQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5yZWFkRmlsZSA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgICAgZmxhZzogJ3InXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGZsYWc6ICdyJ1xuICAgIH0pO1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgY29uc3Qgd2FzRmlsZURlc2NyaXB0b3IgPSB0eXBlb2YgcGF0aCA9PT0gJ251bWJlcic7XG4gIGxldCBmaWxlRGVzY3JpcHRvciA9IHBhdGg7IC8vIG1heSBiZSBvdmVycmlkZW4gbGF0ZXJcblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIHBvc3NpYmxlIEVycm9yXG4gICAqIEBwYXJhbSB7VGkuQnVmZmVyfSBidWZmZXIgVGkuQnVmZmVyIGluc3RhbmNlXG4gICAqL1xuXG4gIGNvbnN0IGhhbmRsZUJ1ZmZlciA9IChlcnIsIGJ1ZmZlcikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBmcy5jbG9zZVN5bmMgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG5cblxuICAgIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICAgIGZzLmNsb3NlU3luYyhmaWxlRGVzY3JpcHRvcik7XG4gICAgfSAvLyBUT0RPOiB0cmltIGJ1ZmZlciBpZiB3ZSBkaWRuJ3QgcmVhZCBmdWxsIHNpemU/XG5cblxuICAgIGNhbGxiYWNrKG51bGwsIGVuY29kZUJ1ZmZlcihvcHRpb25zLmVuY29kaW5nLCBidWZmZXIpKTtcbiAgfTtcblxuICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgZnMub3BlbihwYXRoLCBvcHRpb25zLmZsYWcsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmZDtcbiAgICAgIHJlYWRGaWxlUG9zdE9wZW4oZmQsIGhhbmRsZUJ1ZmZlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVhZEZpbGVQb3N0T3BlbihwYXRoLCBoYW5kbGVCdWZmZXIpO1xuICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1udWxsXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdyJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHJldHVybnMge3N0cmluZ3xCdWZmZXJ9IHN0cmluZyBpZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQsIG90aGVyd2lzZSBCdWZmZXJcbiAqL1xuXG5cbmZzLnJlYWRGaWxlU3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogbnVsbCxcbiAgICBmbGFnOiAncidcbiAgfSk7XG4gIGNvbnN0IHdhc0ZpbGVEZXNjcmlwdG9yID0gdHlwZW9mIHBhdGggPT09ICdudW1iZXInO1xuICBjb25zdCBmaWxlRGVzY3JpcHRvciA9IHdhc0ZpbGVEZXNjcmlwdG9yID8gcGF0aCA6IGZzLm9wZW5TeW5jKHBhdGgsIG9wdGlvbnMuZmxhZyk7IC8vIHVzZSBkZWZhdWx0IG1vZGVcblxuICBjb25zdCB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKTsgLy8gSnVzdCB1c2Ugb3VyIG93biBBUEkgdGhhdCByZWFkcyBmdWxsIHN0cmVhbSBpblxuXG4gIGNvbnN0IGJ1ZmZlciA9IFRpLlN0cmVhbS5yZWFkQWxsKHRpRmlsZVN0cmVhbSk7IC8vIGZzLmNsb3NlU3luYyBpZiBpdCB3YXMgbm90IG9yaWdpbmFsbHkgYSBmaWxlIGRlc2NyaXB0b3JcblxuICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgZnMuY2xvc2VTeW5jKGZpbGVEZXNjcmlwdG9yKTtcbiAgfSAvLyBUT0RPOiB0cmltIGJ1ZmZlciBpZiB3ZSBkaWRuJ3QgcmVhZCBmdWxsIHNpemU/XG5cblxuICByZXR1cm4gZW5jb2RlQnVmZmVyKG9wdGlvbnMuZW5jb2RpbmcsIGJ1ZmZlcik7XG59OyAvLyBUT0RPOiBmcy5yZWFkbGluayhwYXRoWywgb3B0aW9uc10sIGNhbGxiYWNrKVxuLy8gVE9ETzogZnMucmVhZGxpbmtTeW5jKHBhdGhbLCBvcHRpb25zXSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgcmVhbHBhdGhDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IHJlc29sdmVkUGF0aCB0aGUgcmVzb2x2ZWQgcGF0aFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gZmlsZXBhdGggb3JpZ2luYWwgZmlsZXBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9zbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHVzZWQgZm9yIHJldHVybmVkIG9iamVjdC4gSWYgJ2J1ZmZlclwiLCB3ZSdsbCByZXR1cm4gYSBCdWZmZXIgaW4gcGFsY2Ugb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7cmVhbHBhdGhDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJlYWxwYXRoID0gKGZpbGVwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgb3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnXG4gIH0pO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIG5vIHN5bWxpbmtzLCB3aGljaCB3ZSByZWFsbHkgZG9uJ3QgaGF2ZSBmdWxsIHN1cHBvcnQgZm9yIGluIG91ciBTREsgYW55d2F5cy5cbiAgICBjb25zdCByZXN1bHQgPSBwYXRoLm5vcm1hbGl6ZShmaWxlcGF0aCk7XG4gICAgZnMuZXhpc3RzKHJlc3VsdCwgcmVzdWx0RXhpc3RzID0+IHtcbiAgICAgIGlmIChyZXN1bHRFeGlzdHMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5mcm9tKHJlc3VsdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICB9IC8vIHRoaXMgcGF0aCBkb2Vzbid0IGV4aXN0LCB0cnkgZWFjaCBzZWdtZW50IHVudGlsIHdlIGZpbmQgZmlyc3QgdGhhdCBkb2Vzbid0XG5cblxuICAgICAgY29uc3Qgc2VnbWVudHMgPSByZXN1bHQuc3BsaXQocGF0aC5zZXApOyAvLyBGSVhNRTogRHJvcCBsYXN0IHNlZ21lbnQgYXMgd2UgYWxyZWFkeSBrbm93IHRoZSBmdWxsIHBhdGggZG9lc24ndCBleGlzdD9cblxuICAgICAgbGV0IHBhcnRpYWxGaWxlUGF0aCA9ICcnO1xuICAgICAgbGV0IGluZGV4ID0gMDsgLy8gaGFuZGxlIHR5cGljYWwgY2FzZSBvZiBlbXB0eSBmaXJzdCBzZWdtZW50IHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW4gYXN5bmMgc2V0VGltZW91dCB0byBnZXQgdG8gZmlyc3QgcmVhbCBjYXNlXG5cbiAgICAgIGlmIChzZWdtZW50c1tpbmRleF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVvdXQodHJ5UGF0aCwgMSk7XG5cbiAgICAgIGZ1bmN0aW9uIHRyeVBhdGgoKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBkb24ndCBydW4gcGFzdCBlbmQgb2Ygc2VnbWVudHMsIHRocm93IGVycm9yIGZvciByZXNvbHZlZCBwYXRoXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5vU3VjaEZpbGUocmVzdWx0KSk7XG4gICAgICAgIH0gLy8gZ3JhYiBuZXh0IHNlZ21lbnRcblxuXG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleCsrXTtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBpZiBpdCdzIGFuIGVtcHR5IHNlZ21lbnQuLi5cbiAgICAgICAgICAvLyB0cnkgYWdhaW4gYXQgbmV4dCBpbmRleFxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHRyeVBhdGgsIDEpO1xuICAgICAgICB9IC8vIG5vcm1hbCBjYXNlXG5cblxuICAgICAgICBwYXJ0aWFsRmlsZVBhdGggKz0gcGF0aC5zZXAgKyBzZWdtZW50OyAvLyBjaGVjayBpZiBwYXRoIHVwIHRvIHRoaXMgcG9pbnQgZXhpc3RzLi4uXG5cbiAgICAgICAgZnMuZXhpc3RzKHBhcnRpYWxGaWxlUGF0aCwgcGFydGlhbEV4aXN0cyA9PiB7XG4gICAgICAgICAgaWYgKCFwYXJ0aWFsRXhpc3RzKSB7XG4gICAgICAgICAgICAvLyBub3BlLCB0aHJvdyB0aGUgRXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhub1N1Y2hGaWxlKCdsc3RhdCcsIHBhcnRpYWxGaWxlUGF0aCkpO1xuICAgICAgICAgIH0gLy8gdHJ5IGFnYWluIGF0IG5leHQgZGVwdGggb2YgZGlyIHRyZWVcblxuXG4gICAgICAgICAgc2V0VGltZW91dCh0cnlQYXRoLCAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIDEpO1xufTtcblxuZnMucmVhbHBhdGgubmF0aXZlID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGZzLnJlYWxwYXRoKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IGZpbGVwYXRoIG9yaWdpbmFsIGZpbGVwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB1c2VkIGZvciByZXR1cm5lZCBvYmplY3QuIElmICdidWZmZXJcIiwgd2UnbGwgcmV0dXJuIGEgQnVmZmVyIGluIHBhbGNlIG9mIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfEJ1ZmZlcn1cbiAqL1xuXG5cbmZzLnJlYWxwYXRoU3luYyA9IChmaWxlcGF0aCwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4J1xuICB9KTsgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBubyBzeW1saW5rcywgd2hpY2ggd2UgcmVhbGx5IGRvbid0IGhhdmUgZnVsbCBzdXBwb3J0IGZvciBpbiBvdXIgU0RLIGFueXdheXMuXG5cbiAgY29uc3QgcmVzdWx0ID0gcGF0aC5ub3JtYWxpemUoZmlsZXBhdGgpO1xuXG4gIGlmICghZnMuZXhpc3RzU3luYyhyZXN1bHQpKSB7XG4gICAgLy8gdGhpcyBwYXRoIGRvZXNuJ3QgZXhpc3QsIHRyeSBlYWNoIHNlZ21lbnQgdW50aWwgd2UgZmluZCBmaXJzdCB0aGF0IGRvZXNuJ3RcbiAgICBjb25zdCBzZWdtZW50cyA9IHJlc3VsdC5zcGxpdChwYXRoLnNlcCk7XG4gICAgbGV0IHBhcnRpYWxGaWxlUGF0aCA9ICcnO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBhcnRpYWxGaWxlUGF0aCArPSBwYXRoLnNlcCArIHNlZ21lbnQ7XG5cbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhwYXJ0aWFsRmlsZVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5vU3VjaEZpbGUoJ2xzdGF0JywgcGFydGlhbEZpbGVQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mcy5yZWFscGF0aFN5bmMubmF0aXZlID0gKHBhdGgsIG9wdGlvbnMpID0+IHtcbiAgZnMucmVhbHBhdGhTeW5jKHBhdGgsIG9wdGlvbnMpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gb2xkUGF0aCBzb3VyY2UgZmlsZXBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IG5ld1BhdGggZGVzdGluYXRpb24gZmlsZXBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJlbmFtZSA9IChvbGRQYXRoLCBuZXdQYXRoLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMucmVuYW1lU3luYyhvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IG9sZFBhdGggc291cmNlIGZpbGVwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBuZXdQYXRoIGRlc3RpbmF0aW9uIGZpbGVwYXRoXG4gKi9cblxuXG5mcy5yZW5hbWVTeW5jID0gKG9sZFBhdGgsIG5ld1BhdGgpID0+IHtcbiAgY29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUob2xkUGF0aCk7IC8vIHNyYyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0P1xuXG4gIGlmICghdGlGaWxlLmV4aXN0cygpKSB7XG4gICAgY29uc3QgZXJyID0gbm9TdWNoRmlsZSgncmVuYW1lJywgb2xkUGF0aCk7XG4gICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gLT4gJyR7bmV3UGF0aH0nYDtcbiAgICBlcnIuZGVzdCA9IG5ld1BhdGg7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgY29uc3QgZGVzdEZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShuZXdQYXRoKTtcblxuICBpZiAoZGVzdEZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgIC8vIGRlc3QgaXMgYSBkaXJlY3RvcnkgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICAgIGNvbnN0IGVyciA9IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ3JlbmFtZScsIG9sZFBhdGgpO1xuICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9IC0+ICcke25ld1BhdGh9J2A7XG4gICAgZXJyLmRlc3QgPSBuZXdQYXRoO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGxldCB0ZW1wUGF0aDtcblxuICBpZiAoZGVzdEZpbGUuaXNGaWxlKCkpIHtcbiAgICAvLyBkZXN0aW5hdGlvbiBmaWxlIGV4aXN0cywgd2Ugc2hvdWxkIG92ZXJ3cml0ZVxuICAgIC8vIE91ciBBUElzIHdpbGwgZmFpbCBpZiB3ZSB0cnksIHNvIGZpcnN0IGxldCdzIG1ha2UgYSBiYWNrdXAgY29weSBhbmQgZGVsZXRlIHRoZSB0aGUgb3JpZ2luYWxcbiAgICB0ZW1wUGF0aCA9IHBhdGguam9pbihmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4oVGkuRmlsZXN5c3RlbS50ZW1wRGlyZWN0b3J5LCAncmVuYW1lLScpKSwgcGF0aC5iYXNlbmFtZShuZXdQYXRoKSk7XG4gICAgZGVzdEZpbGUubW92ZSh0ZW1wUGF0aCk7XG4gIH1cblxuICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgc3VjY2VzcyA9IHRpRmlsZS5tb3ZlKG5ld1BhdGgpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmICh0ZW1wUGF0aCkge1xuICAgICAgLy8gd2UgdGVtcG9yYXJpbHkgY29waWVkIHRoZSBleGlzdGluZyBkZXN0aW5hdGlvbiB0byBiYWNrIGl0IHVwLi4uXG4gICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAvLyBtb3ZlIHdvcmtlZCwgc28gd2UgY2FuIHdpcGUgaXQgYXdheSB3aGVuZXZlci4uLlxuICAgICAgICBmcy51bmxpbmsodGVtcFBhdGgsIF9lcnIgPT4ge30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW92ZSBpdCBiYWNrLCBiZWNhdXNlIHdlIGZhaWxlZCFcbiAgICAgICAgY29uc3QgdG1wRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHRlbXBQYXRoKTtcbiAgICAgICAgdG1wRmlsZS5tb3ZlKG5ld1BhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJtZGlyID0gKHBhdGgsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5ybWRpclN5bmMocGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICovXG5cblxuZnMucm1kaXJTeW5jID0gcGF0aCA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuXG4gIGlmICghdGlGaWxlLmRlbGV0ZURpcmVjdG9yeShmYWxzZSkpIHtcbiAgICAvLyBkbyBub3QgZGVsZXRlIGNvbnRlbnRzIVxuICAgIC8vIHdlIGZhaWxlZCB0byBkZWxldGUsIGJ1dCB3aHk/XG4gICAgLy8gZG9lcyBpdCBleGlzdD9cbiAgICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbm9TdWNoRmlsZSgncm1kaXInLCBwYXRoKTtcbiAgICB9IC8vIGlzIGl0IGEgZmlsZT9cblxuXG4gICAgaWYgKHRpRmlsZS5pc0ZpbGUoKSkge1xuICAgICAgdGhyb3cgbm90QURpcmVjdG9yeSgncm1kaXInLCBwYXRoKTtcbiAgICB9IC8vIGlzIGl0IG5vdCBlbXB0eT9cblxuXG4gICAgY29uc3Qgc3ViRmlsZXMgPSB0aUZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuXG4gICAgaWYgKHN1YkZpbGVzICYmIHN1YkZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IGRpcmVjdG9yeU5vdEVtcHR5KCdybWRpcicsIHBhdGgpO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHBhcmFtIHtzdGF0c0NhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMuc3RhdCA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY2FsbGJhY2sobnVsbCwgbmV3IGZzLlN0YXRzKHBhdGgpKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IHBhdGggZmlsZXBhdGggb3IgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW19vcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHJldHVybnMge2ZzLlN0YXRzfVxuICovXG5cblxuZnMuc3RhdFN5bmMgPSAocGF0aCwgX29wdGlvbnMpID0+IG5ldyBmcy5TdGF0cyhwYXRoKTtcblxuZnMuc3ltbGluayA9ICh0YXJnZXQsIHBhdGgsIHR5cGUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnc3ltbGluaycsIGNhbGxiYWNrKTtcblxuZnMuc3ltbGlua1N5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3N5bWxpbmtTeW5jJyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuPTBdIGJ5dGVzIHRvIHRyaW0gdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5mcy50cnVuY2F0ZSA9IChwYXRoLCBsZW4sIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBsZW4pO1xuXG4gIGlmICh0eXBlb2YgbGVuICE9PSAnbnVtYmVyJykge1xuICAgIGxlbiA9IDA7XG4gIH1cblxuICBpZiAobGVuIDw9IDApIHtcbiAgICBmcy53cml0ZUZpbGUocGF0aCwgJycsIGNhbGxiYWNrKTsgLy8gZW1wdHkgdGhlIGZpbGVcblxuICAgIHJldHVybjtcbiAgfSAvLyB3ZSBoYXZlIHRvIHJldGFpbiBzb21lIG9mIHRoZSBmaWxlIVxuICAvLyB5dWNrLCBzbyBsZXQncyByZWFkIHdoYXQgd2UgbmVlZCB0byByZXRhaW4sIHRoZW4gb3ZlcndyaXRlIGZpbGUgd2l0aCBpdFxuXG5cbiAgZnMub3BlbihwYXRoLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuICAgIGZzLnJlYWQoZmQsIGJ1ZmZlciwgMCwgbGVuLCBudWxsLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgZnMuY2xvc2UoZmQsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZzLndyaXRlRmlsZShwYXRoLCBidWZmZXIsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuPTBdIGJ5dGVzIHRvIHRyaW0gdG9cbiAqL1xuXG5cbmZzLnRydW5jYXRlU3luYyA9IChwYXRoLCBsZW4gPSAwKSA9PiB7XG4gIGlmIChsZW4gPD0gMCkge1xuICAgIC8vIGVtcHR5IHRoZSBmaWxlXG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCAnJyk7XG4gICAgcmV0dXJuO1xuICB9IC8vIHdlIGhhdmUgdG8gcmV0YWluIHNvbWUgb2YgdGhlIGZpbGUhXG4gIC8vIHl1Y2ssIHNvIGxldCdzIHJlYWQgd2hhdCB3ZSBuZWVkIHRvIHJldGFpbiwgdGhlbiBvdmVyd3JpdGUgZmlsZSB3aXRoIGl0XG5cblxuICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKHBhdGgpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MobGVuKTtcbiAgZnMucmVhZFN5bmMoZmQsIGJ1ZmZlciwgMCwgbGVuLCBudWxsKTtcbiAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCBidWZmZXIpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnVubGluayA9IChwYXRoLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMudW5saW5rU3luYyhwYXRoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbmZzLnVubGlua1N5bmMgPSBwYXRoID0+IHtcbiAgY29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgaWYgKCF0aUZpbGUuZGVsZXRlRmlsZSgpKSB7XG4gICAgLy8gd2UgZmFpbGVkLCBidXQgd2h5P1xuICAgIGlmICghdGlGaWxlLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBub1N1Y2hGaWxlKCd1bmxpbmsnLCBwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAodGlGaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ3VubGluaycsIHBhdGgpO1xuICAgIH1cbiAgfVxufTtcblxuZnMudW53YXRjaEZpbGUgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3Vud2F0Y2hGaWxlJyk7XG5cbmZzLnV0aW1lcyA9IChwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAndXRpbWVzJywgY2FsbGJhY2spO1xuXG5mcy51dGltZXNTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICd1dGltZXNTeW5jJyk7XG5mcy53YXRjaCA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnd2F0Y2gnKTtcbmZzLndhdGNoRmlsZSA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnd2F0Y2hGaWxlJyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gZmlsZSBmaWxlIHBhdGggb3IgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFR5cGVkQXJyYXl8RGF0YVZpZXd9IGRhdGEgZGF0YSB0byB3cml0ZVxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gb3B0aW9ucywgZW5jb2RpbmcgaWYgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubW9kZT0wbzY2Nl0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmZsYWc9J3cnXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuZnMud3JpdGVGaWxlID0gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogMG82NjYsXG4gICAgZmxhZzogJ3cnXG4gIH0pOyAvLyBUdXJuIGludG8gZmlsZSBkZXNjcmlwdG9yXG5cbiAgY29uc3Qgd2FzRmlsZURlc2NyaXB0b3IgPSB0eXBlb2YgZmlsZSA9PT0gJ251bWJlcic7XG4gIGxldCBmaWxlRGVzY3JpcHRvciA9IGZpbGU7IC8vIG1heSBiZSBvdmVycmlkZW4gbGF0ZXJcblxuICBjb25zdCBmaW5pc2ggPSBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZnMuY2xvc2UgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG5cblxuICAgIGZzLmNsb3NlKGZpbGVEZXNjcmlwdG9yLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLm9wZW4oZmlsZSwgb3B0aW9ucy5mbGFnLCBvcHRpb25zLm1vZGUsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmZDtcbiAgICAgIGZzLndyaXRlKGZpbGVEZXNjcmlwdG9yLCBkYXRhLCBmaW5pc2gpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZzLndyaXRlKGZpbGVEZXNjcmlwdG9yLCBkYXRhLCBmaW5pc2gpO1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IGZpbGUgZmlsZSBwYXRoIG9yIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fSBkYXRhIGRhdGEgdG8gd3JpdGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnMsIGVuY29kaW5nIGlmIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGYtOCddIG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZmxhZz0ndyddIG9wdGlvbnNcbiAqL1xuXG5cbmZzLndyaXRlRmlsZVN5bmMgPSAoZmlsZSwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBtb2RlOiAwbzY2NixcbiAgICBmbGFnOiAndydcbiAgfSk7IC8vIFR1cm4gaW50byBmaWxlIGRlc2NyaXB0b3JcblxuICBjb25zdCB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBmaWxlID09PSAnbnVtYmVyJztcbiAgY29uc3QgZmlsZURlc2NyaXB0b3IgPSB3YXNGaWxlRGVzY3JpcHRvciA/IGZpbGUgOiBmcy5vcGVuU3luYyhmaWxlLCBvcHRpb25zLmZsYWcsIG9wdGlvbnMubW9kZSk7IC8vIGlmIGRhdGEgaXMgYSBzdHJpbmcsIG1ha2UgaXQgYSBidWZmZXIgZmlyc3RcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbSgnJyArIGRhdGEsIG9wdGlvbnMuZW5jb2RpbmcpOyAvLyBmb3JjZSBkYXRhIHRvIGJlIGEgc3RyaW5nLCBoYW5kbGVzIGNhc2Ugd2hlcmUgaXQncyB1bmRlZmluZWQgYW5kIHdyaXRlcyAndW5kZWZpbmVkJyB0byBmaWxlIVxuICB9XG5cbiAgZnMud3JpdGVTeW5jKGZpbGVEZXNjcmlwdG9yLCBkYXRhKTsgLy8gY2xvc2UgaWYgdXNlciBkaWRuJ3QgZ2l2ZSB1cyBmaWxlIGRlc2NyaXB0b3JcblxuICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgZnMuY2xvc2VTeW5jKGZpbGVEZXNjcmlwdG9yKTtcbiAgfVxufTtcbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlVGlGaWxlU3RyZWFtQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICovXG5cbi8qKlxuICogQHBhcmFtIHtUaS5GaWxlc3lzdGVtLkZpbGVTdHJlYW19IHRpRmlsZVN0cmVhbSBmaWxlIHN0cmVhbVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBidWZmZXIgd2UncmUgd3JpdGluZ1xuICogQHBhcmFtIHt3cml0ZVRpRmlsZVN0cmVhbUNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gd3JpdGVUaUZpbGVTdHJlYW0odGlGaWxlU3RyZWFtLCBidWZmZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIFRpLlN0cmVhbS53cml0ZSh0aUZpbGVTdHJlYW0sIGJ1ZmZlci50b1RpQnVmZmVyKCksIHdyaXRlT2JqID0+IHtcbiAgICBpZiAoIXdyaXRlT2JqLnN1Y2Nlc3MpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih3cml0ZU9iai5lcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHdyaXRlT2JqLmJ5dGVzUHJvY2Vzc2VkKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZTogQnVmZmVyIG9yIHN0cmluZ1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZTsgT1Igb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4gKGlmIHN0cmluZylcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiBieXRlcyB0byB3cml0ZSBpZiBCdWZmZXI7IE9SIGV4cGVjdGVkIHN0cmluZyBlbmNvZGluZ1xuICogQHBhcmFtIHt3cml0ZUNhbGxiYWNrfGludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4gKGlmIEJ1ZmZlcik7IE9SIGFzeW5jIGNhbGxiYWNrIGlmIHN0cmluZ1xuICogQHBhcmFtIHt3cml0ZUNhbGxiYWNrfSBbY2FsbGJhY2tdIGFzeW5jIGNhbGxiYWNrIChpZiBCdWZmZXIpXG4gKi9cblxuXG5mcy53cml0ZSA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcik7XG5cbiAgaWYgKGlzQnVmZmVyKSB7XG4gICAgd3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVTdHJpbmcoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gYnVmZmVyIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXRdIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbbGVuZ3RoXSAgZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gcG9zaXRpb25cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5cblxuZnMud3JpdGVTeW5jID0gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICBjb25zdCBpc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpO1xuXG4gIGlmIChpc0J1ZmZlcikge1xuICAgIHJldHVybiB3cml0ZUJ1ZmZlclN5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlU3RyaW5nU3luYyhmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG59OyAvLyBUT0RPOiBBZGQgRmlsZUhhbmRsZSBjbGFzcyB0byBtYXRjaCBOb2RlJ3Mgd3JhcHBlciBmb3IgZmlsZSBkZXNjcmlwdG9ycy4gUmUtcHVycG9zZSBvdXIgb3duIHdyYXBwZXI/XG4vLyBUT0RPOiBBZGQgdGhlIGZzLnByb21pc2VzIEFQSSFcbi8vIFRPRE86IERlZmluZSBmcy5EaXJlbnQgY2xhc3MsIHdoaWNoIGNhbiBzaW1wbHkgd3JhcCBhIFRpLkZpbGVzeXN0ZW0uRmlsZSAoYW5kIGlzIHZlcnkgc2ltaWxhciB0byBmcy5TdGF0cyEpXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRyYWNrcyB0aGUgcGFpcmluZyBvZiB0aGUgbnVtYmVyIHdlIHVzZSB0byByZXByZXNlbnQgdGhlIGZpbGUgZXh0ZXJuYWxseSwgdGhlIGZpbGVwYXRoIGl0J3MgcG9pbnRpbmcgYXQsIGFuZCB0aGUgc3RyZWFtIHBvaW50aW5nIGF0IGl0LlxuICovXG5cblxuY2xhc3MgRmlsZURlc2NyaXB0b3Ige1xuICBjb25zdHJ1Y3RvcihudW1iZXIsIHBhdGgsIHN0cmVhbSkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gIH1cblxufVxuLyoqXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBzcmNTdHJlYW0gaW5wdXQgc3RyZWFtIHdlJ3JlIHJlYWRpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gZGVzdFN0cmVhbSBvdXRwdXQgc3RyZWFtIHdlJ3JlIHdyaXRpbmcgdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHBpcGUoc3JjU3RyZWFtLCBkZXN0U3RyZWFtLCBjYWxsYmFjaykge1xuICB7XG4gICAgLy8gQW5kcm9pZCBpcyBwcm9iYWJseSBiZXR0ZXIgb2ZmIHdpdGggVGkuU3RyZWFtLndyaXRlU3RyZWFtLCBsZXNzIG92ZXJoZWFkIGJhY2sgYW5kIGZvcnRoIHRoZSBicmlkZ2VcbiAgICAvLyBUaG91Z2ggQW5kcm9pZCBkb2VzIHN1cHBvcnQgdGhlIFRpLlN0cmVhbS5wdW1wL1RpLlN0cmVhbS53cml0ZSBwYXR0ZXJuIHVzaW5nIGJvdGggQVBJcyBhc3luY1xuICAgIHBpcGVWaWFXcml0ZVN0cmVhbShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH0gLy8gaU9TIGhhcyBzb21lLi4uIGlzc3VlcyB3aXRoIHdyaXRlU3RyZWFtIGNhbGxpbmcgdGhlIGNhbGxiYWNrIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcCAqYW5kKiBhdCB0aGUgZW5kXG59XG4vKipcbiAqIEBwYXJhbSB7VGkuSU9TdHJlYW19IHNyY1N0cmVhbSBpbnB1dCBzdHJlYW0gd2UncmUgcmVhZGluZyBmcm9tXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBkZXN0U3RyZWFtIG91dHB1dCBzdHJlYW0gd2UncmUgd3JpdGluZyB0b1xuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gcGlwZVZpYVdyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgVGkuU3RyZWFtLndyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgQ09QWV9GSUxFX0NIVU5LX1NJWkUsIHJlc3VsdCA9PiB7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihyZXN1bHQuZXJyb3IpKTtcbiAgICB9IC8vIEFuZHJvaWQgd2lsbCBvbmx5IGNhbGwgdGhpcyBhdCB0aGUgZW5kIG9yIGVycm9yLCBzbyB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB3ZSdyZSBkb25lIGhlcmUuXG4gICAgLy8gaU9TIHdpbGwgY2FsbCBwZXIgbG9vcCBpdGVyYXRpb24sIHNlZSBodHRwczovL2ppcmEuYXBwY2VsZXJhdG9yLm9yZy9icm93c2UvVElNT0ItMjczMjBcblxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge1RpLkZpbGVzeXN0ZW0uRmlsZVN0cmVhbX0gZmlsZVN0cmVhbSBmaWxlIHN0cmVhbVxuICogQHJldHVybnMge2ludGVnZXJ9IGZpbGUgZGVzY3JpcHRvclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRmlsZURlc2NyaXB0b3IocGF0aCwgZmlsZVN0cmVhbSkge1xuICBjb25zdCBwb2ludGVyID0gZmlsZURlc2NyaXB0b3JDb3VudCsrOyAvLyBpbmNyZW1lbnQgZ2xvYmFsIGNvdW50ZXJcblxuICBjb25zdCBmZCA9IG5ldyBGaWxlRGVzY3JpcHRvcihwb2ludGVyLCBwYXRoLCBmaWxlU3RyZWFtKTtcbiAgZmlsZURlc2NyaXB0b3JzLnNldChwb2ludGVyLCBmZCk7IC8vIHVzZSBpdCB0byByZWZlciB0byB0aGlzIGZpbGUgc3RyZWFtIGFzIHRoZSBcImRlc2NyaXB0b3JcIlxuXG4gIHJldHVybiBwb2ludGVyO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge1RpLkZpbGVzeXN0ZW0uRmlsZVN0cmVhbX0gbWF0Y2hpbmcgc3RyZWFtXG4gKi9cblxuXG5mdW5jdGlvbiBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKSB7XG4gIGNvbnN0IHdyYXBwZXIgPSBmaWxlRGVzY3JpcHRvcnMuZ2V0KGZkKTtcbiAgcmV0dXJuIHdyYXBwZXIuc3RyZWFtO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge3N0cmluZ30gbWF0Y2hpbmcgc3RyZWFtXG4gKi9cblxuXG5mdW5jdGlvbiBwYXRoRm9yRmlsZURlc2NyaXB0b3IoZmQpIHtcbiAgY29uc3Qgd3JhcHBlciA9IGZpbGVEZXNjcmlwdG9ycy5nZXQoZmQpO1xuICByZXR1cm4gd3JhcHBlci5wYXRoO1xufVxuLyoqXG4gKiBVc2VkIHRvIG1lcmdlIHRoZSB1c2VyLXN1cHBsaWVkIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdHMgZm9yIGEgZnVuY3Rpb24uIFNwZWNpYWwgY2FzZXMgYSBzdHJpbmcgdG8gYmUgZW5jb2RpbmcuXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgdXNlci1zdXBwbGllZCBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdHMgZGVmYXVsdHMgdG8gdXNlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uc1R5cGUgPSB0eXBlb2Ygb3B0aW9ucztcblxuICBzd2l0Y2ggKG9wdGlvbnNUeXBlKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gVXNlIGNvcHkgb2YgZGVmYXVsdHMgYnV0IHdpdGggZW5jb2Rpbmcgc2V0IHRvIHRoZSAnb3B0aW9ucycgdmFsdWUhXG4gICAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gICAgICBtZXJnZWQuZW5jb2RpbmcgPSBvcHRpb25zO1xuICAgICAgcmV0dXJuIG1lcmdlZDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gb3B0aW9ucztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBhc3NlcnRBcmd1bWVudFR5cGUob3B0aW9ucywgJ29wdGlvbnMnLCAnb2JqZWN0Jyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBzaG91bGQgbmV2ZXIgZ2V0IHJlYWNoZWRcbiAgfVxufVxuLyoqXG4gKiBFbmZvcmNlcyB0aGF0IHdlIGhhdmUgYSB2YWxpZCBjYWxsYmFjayBmdW5jdGlvbi4gVGhyb3dzIFR5cGVFcnJvciBpZiBub3QuXG4gKiBAcGFyYW0geyp9IGNiIHBvc3NpYmxlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKi9cblxuXG5mdW5jdGlvbiBtYXliZUNhbGxiYWNrKGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2I7XG4gIH1cblxuICBjb25zdCBlcnIgPSBuZXcgVHlwZUVycm9yKGBDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uIFJlY2VpdmVkICR7Y2J9YCk7XG4gIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX0NBTExCQUNLJztcbiAgdGhyb3cgZXJyO1xufVxuLyoqXG4gKiByZXR1cm5zIHJhbmRvbWx5IGdlbmVyYXRlZCBjaGFyYWN0ZXJzIG9mIGdpdmVuIGxlbmd0aCAxLTE2XG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAxIC0gMTZcbiAqIEBwYXJhbSB7c3RyaW5nfSBbX2VuY29kaW5nPSd1dGY4J10gZW5jb2Rpbmcgb2YgdGhlIHN0cmluZyBnZW5lcmF0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb21DaGFyYWN0ZXJzKGxlbmd0aCwgX2VuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIC8vIEZJWE1FOiB1c2UgdGhlIGVuY29kaW5nIHNwZWNpZmllZCFcbiAgcmV0dXJuIChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSArICcwMDAwMDAwMDAwMDAwMDAwMCcpLnNsaWNlKDIsIGxlbmd0aCArIDIpO1xufVxuXG5mdW5jdGlvbiBtYWtlRXJyb3IoY29kZSwgbWVzc2FnZSwgZXJybm8sIHN5c2NhbGwsIHBhdGgpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7Y29kZX06ICR7bWVzc2FnZX0sICR7c3lzY2FsbH0gJyR7cGF0aH0nYCk7XG4gIGVycm9yLmVycm5vID0gZXJybm87XG4gIGVycm9yLnN5c2NhbGwgPSBzeXNjYWxsO1xuICBlcnJvci5jb2RlID0gY29kZTtcbiAgZXJyb3IucGF0aCA9IHBhdGg7XG4gIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIHdoYXQgd2UncmUgZW5jb2RpbmcgdG9cbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSB0aUJ1ZmZlciBUaS5CdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IG5vZGUtY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlcihlbmNvZGluZywgdGlCdWZmZXIpIHtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgY2FzZSBudWxsOlxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlJ3JlIGFsd2F5cyByZWFkaW5nIGEgZmlsZSBpbnRvIGEgVGkuQnVmZmVyXG4gICAgICAvLyBXcmFwcGluZyBUaS5CdWZmZXIgaXMgc3VwZXItc2xvdyBhbmQgc2hvdWxkIHJlYWxseSBvbmx5IGJlIGlmIHdlJ3JlIGdvaW5nIHRvIHdyaXRlIHRvIGl0XG4gICAgICAvLyBHbyB0aGUgZmFzdGVyIHBhdGggYnkgY29udmVydGluZyB0byBBcnJheUJ1ZmZlciBhbmQgd3JhcHBpbmcgdGhhdFxuICAgICAgLy8gVE9ETzogRXhwbGljaXRseSByZWxlYXNlIHRoZSBibG9iIGFmdGVyIGNvbnZlcnNpb24/XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odGlCdWZmZXIudG9CbG9iKCkudG9BcnJheUJ1ZmZlcigpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBoZXJlJyB3ZXJlIGNvbnZlcnRpbmcgdG8gYSBzdHJpbmcgYmFzZWQgb24gZW5jb2RpbmcuIEludGVybmFsbHkgb3VyIGZhc3RlciBCdWZmZXIgaW1wbCBzdGlsbCBkZWxlZ2F0ZXMgdG8gVGkuQnVmZmVyIGluIG1vc3QgY2FzZXNcbiAgICAgIC8vIHNvIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBtdWNoIGJlbmVmaXQgZnJvbSBjb252ZXJ0aW5nIHRvIEFycmF5QnVmZmVyIGZpcnN0XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odGlCdWZmZXIpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHJldHVybiB7VGkuRmlsZXN5c3RlbS5GaWxlfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCkge1xuICAvLyBUaGlzIGlzIGEgaGFjayB0aGF0IGlzIGxpa2VseSB0byB3b3JrIGluIG1vc3QgY2FzZXM/XG4gIC8vIEJhc2ljYWxseSBhc3N1bWVzIEJ1ZmZlciBpcyBob2xkaW5nIGEgdXRmLTggc3RyaW5nIGZpbGVuYW1lL3BhdGhcbiAgLy8gTm9kZSBqdXN0IGNvcGllcyB0aGUgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyIGFzLWlzIG9uIHRoZSBuYXRpdmUgc2lkZSBhbmQgYWRkcyBhIG51bGwgdGVybWluYXRvclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhdGgpKSB7XG4gICAgcGF0aCA9IHBhdGgudG9TdHJpbmcoKTsgLy8gYXNzdW1lcyB1dGYtOCBzdHJpbmdcbiAgfSAvLyBGSVhNRTogSGFuZGxlIFVSTHMhIFdlIGRvbid0IGhhdmUgYW4gVVJMIHNoaW0geWV0LCBzbyBubyB3YXkgdG8gaGFuZGxlIHRob3NlIHlldFxuXG5cbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICByZXR1cm4gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKHBhdGgpO1xufVxuLyoqXG4gKiBAY2FsbGJhY2sgd3JpdGVCdWZmZXJDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdyaXR0ZW4gLSBieXRlcyB3cml0dGVuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIC0gb3JpZ2luYWwgQnVmZmVyIGJlaW5nIHdyaXR0ZW5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXRdIG9mZnNldCB3aXRoaW4gQnVmZmVyIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiBieXRlcyB0byB3cml0ZSBpZiBCdWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3Bvc2l0aW9uXSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXMgZGF0YSBzaG91bGQgYmUgd3JpdHRlblxuICogQHBhcmFtIHt3cml0ZUJ1ZmZlckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gd3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgcG9zaXRpb24gfHwgbGVuZ3RoIHx8IG9mZnNldCk7XG5cbiAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInKSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJykge1xuICAgIHBvc2l0aW9uID0gbnVsbDtcbiAgfSAvLyBvayBub3cgd2hhdD9cblxuXG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpOyAvLyBNYWtlIHVzZSBvZiB0aGUgYnVmZmVyIHNsaWNlIHRoYXQncyBzcGVjaWZpZWQgYnkgb2Zmc2V0L2xlbmd0aFxuXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfSAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cblxuICB3cml0ZVRpRmlsZVN0cmVhbSh0aUZpbGVTdHJlYW0sIGJ1ZmZlciwgKGVyciwgYnl0ZXNQcm9jZXNzZWQpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzUHJvY2Vzc2VkLCBidWZmZXIpO1xuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgY29udGVudHMgdG8gd3JpdGVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldF0gb2Zmc2V0IHdpdGhpbiBCdWZmZXIgdG8gd3JpdGVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aF0gbGVuZ3RoIG9mIGJ5dGVzIHRvIHdyaXRlIGlmIEJ1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbcG9zaXRpb25dIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyU3luYyhmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInKSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cblxuXG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpOyAvLyBNYWtlIHVzZSBvZiB0aGUgYnVmZmVyIHNsaWNlIHRoYXQncyBzcGVjaWZpZWQgYnkgb2Zmc2V0L2xlbmd0aFxuXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfSAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cblxuICByZXR1cm4gdGlGaWxlU3RyZWFtLndyaXRlKGJ1ZmZlci50b1RpQnVmZmVyKCkpO1xufVxuLyoqXG4gKiBAY2FsbGJhY2sgd3JpdGVTdHJpbmdDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdyaXR0ZW4gLSBieXRlcyB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gb3JpZ2luYWwgc3RyaW5nIGJlaW5nIHdyaXR0ZW5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEBwYXJhbSB7d3JpdGVTdHJpbmdDYWxsYmFja30gW2NhbGxiYWNrXSBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHJpbmcoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgZW5jb2RpbmcgfHwgcG9zaXRpb24pOyAvLyBwb3NpdGlvbiBjb3VsZCBiZTogbnVtYmVyLCBmdW5jdGlvbiAoY2FsbGJhY2spXG5cbiAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpIHtcbiAgICBwb3NpdGlvbiA9IG51bGw7XG4gIH0gLy8gZW5jb2RpbmcgY291bGQgYmU6IGZ1bmN0aW9uIChjYWxsYmFjaykgb3Igc3RyaW5nXG5cblxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG5cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIHN0cmluZyArPSAnJzsgLy8gY29lcmNlIHRvIHN0cmluZ1xuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0cmluZywgZW5jb2RpbmcpOyAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cbiAgd3JpdGVUaUZpbGVTdHJlYW0odGlGaWxlU3RyZWFtLCBidWZmZXIsIChlcnIsIGJ5dGVzUHJvY2Vzc2VkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBieXRlc1Byb2Nlc3NlZCwgc3RyaW5nKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdTeW5jKGZkLCBzdHJpbmcsIHBvc2l0aW9uLCBlbmNvZGluZykge1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBjb25zdCB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTtcbiAgc3RyaW5nICs9ICcnOyAvLyBjb2VyY2UgdG8gc3RyaW5nXG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZyk7IC8vIFRPRE86IFN1cHBvcnQgdXNlIG9mIHBvc2l0aW9uIGFyZ3VtZW50LiBJIGFzc3VtZSB3ZSdkIG5lZWQgYSB3YXkgdG8gYWRkIGEgbWV0aG9kIHRvIG1vdmUgdG8gc3RyZWFtIHBvc2l0aW9uIHNvbWVob3dcblxuICByZXR1cm4gdGlGaWxlU3RyZWFtLndyaXRlKGJ1ZmZlci50b1RpQnVmZmVyKCkpO1xufVxuXG5mdW5jdGlvbiBTdHJlYW0oX29wdHMpIHtcbiAgLy8gRklYTUU6IENhbid0IGNhbGwgRXZlbnRFbWl0dGVyIGFzIGEgZnVuY3Rpb24hXG4gIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDsgLy8gRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0cyk7XG4gIC8vIFRPRE86IFByb3ZpZGUgbW9yZSB0aGFuIGFuIGVtcHR5IGNsYXNzP1xufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLCBFdmVudEVtaXR0ZXIpOyAvLyBVc2UgdXRpbC5pbmhlcml0cz9cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcbiAgfSAvLyBUT0RPOiByZWFkYWJsZVN0YXRlP1xuXG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICB9XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChfbikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBub3QgaW1wbGVtZW50ZWQ6IF9yZWFkKCknKTtcbn07XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgY29uc3QgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIGlmICghaXNEdXBsZXggJiYgISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gICAgfVxuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIH1cblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpOyAvLyBUT0RPOiBQcm92aWRlIG1vcmUgdGhhbiBhbiBlbXB0eSBjbGFzcyFcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlOyAvLyB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTsgLy8gQ29weSBXcml0YWJsZSBtZXRob2RzIHRvIER1cGxleCAoYmFzaWNhbGx5IHRoZSBvZGQgZG91YmxlLWluaGVyaXRhbmNlKVxuXG5jb25zdCB3cml0YWJsZU1ldGhvZHMgPSBPYmplY3Qua2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IHdyaXRhYmxlTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBtZXRob2QgPSB3cml0YWJsZU1ldGhvZHM7XG5cbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIHtcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICB9XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIFRPRE86IFByb3ZpZGUgbW9yZSB0aGFuIGFuIGVtcHR5IGNsYXNzIVxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gICAgfVxuICB9IC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgLy8gdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcblxufVxuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07IC8vIGxlZ2FjeSBjb21wYXRcblxuU3RyZWFtLlRyYW5zZm9ybSA9IFRyYW5zZm9ybTtcblN0cmVhbS5SZWFkYWJsZSA9IFJlYWRhYmxlO1xuU3RyZWFtLldyaXRhYmxlID0gV3JpdGFibGU7XG5TdHJlYW0uRHVwbGV4ID0gRHVwbGV4OyAvLyBTdHJlYW0uUGFzc1Rocm91Z2ggPSBQYXNzVGhyb3VnaDtcblxuLy8gTG9hZCBhbGwgdGhlIG5vZGUgY29tcGF0aWJsZSBjb3JlIG1vZHVsZXNcbnJlZ2lzdGVyKCdwYXRoJywgcGF0aCk7XG5yZWdpc3Rlcignb3MnLCBPUyk7XG5yZWdpc3RlcigndHR5JywgdHR5KTtcbnJlZ2lzdGVyKCd1dGlsJywgdXRpbCk7XG5yZWdpc3RlcignYXNzZXJ0JywgYXNzZXJ0KTtcbnJlZ2lzdGVyKCdldmVudHMnLCBFdmVudEVtaXR0ZXIpO1xucmVnaXN0ZXIoJ2J1ZmZlcicsIEJ1ZmZlck1vZHVsZSk7XG5yZWdpc3Rlcignc3RyaW5nX2RlY29kZXInLCBTdHJpbmdEZWNvZGVyJDEpO1xucmVnaXN0ZXIoJ2ZzJywgZnMpO1xucmVnaXN0ZXIoJ3N0cmVhbScsIFN0cmVhbSk7IC8vIFJlZ2lzdGVyIHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlciBhcyBnbG9iYWxcblxuZ2xvYmFsLkJ1ZmZlciA9IEJ1ZmZlck1vZHVsZS5CdWZmZXI7XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIERlc2NyaXB0aW9uOlxuICogVGhpcyBzY3JpcHQgbG9hZHMgYWxsIEphdmFTY3JpcHQgZmlsZXMgZW5kaW5nIHdpdGggdGhlIG5hbWUgXCIqLmJvb3RzdHJhcC5qc1wiIGFuZCB0aGVuIGV4ZWN1dGVzIHRoZW0uXG4gKiBUaGUgbWFpbiBpbnRlbnRpb24gb2YgdGhpcyBmZWF0dXJlIGlzIHRvIGFsbG93IEphdmFTY3JpcHQgZmlsZXMgdG8ga2ljay1vZmYgZnVuY3Rpb25hbGl0eSBvclxuICogZGlzcGxheSBVSSB0byB0aGUgZW5kLXVzZXIgYmVmb3JlIHRoZSBcImFwcC5qc1wiIGdldHMgbG9hZGVkLiBUaGlzIGZlYXR1cmUgaXMgdGhlIENvbW1vbkpTXG4gKiBlcXVpdmFsZW50IHRvIFRpdGFuaXVtJ3MgQW5kcm9pZCBtb2R1bGUgb25BcHBDcmVhdGUoKSBvciBpT1MgbW9kdWxlIGxvYWQoKSBmZWF0dXJlcy5cbiAqXG4gKiBVc2UtQ2FzZXM6XG4gKiAtIEF1dG9tYXRpY2FsbHkga2ljay1vZmYgYW5hbHl0aWNzIGZ1bmN0aW9uYWxpdHkgb24gYXBwIHN0YXJ0dXAuXG4gKiAtIEVuc3VyZSBcIkdvb2dsZSBQbGF5IFNlcnZpY2VzXCIgaXMgaW5zdGFsbGVkL3VwZGF0ZWQgb24gYXBwIHN0YXJ0dXAgb24gQW5kcm9pZC5cbiAqL1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGxvYWQgYWxsIGJvb3RzdHJhcHMgZnJvbSBhIFwiYm9vdHN0cmFwLmpzb25cIiBmaWxlIGNyZWF0ZWQgYnkgdGhlIGFwcCBidWlsZCBzeXN0ZW0uXG4gKiBUaGlzIGlzIGFuIG9wdGlvbmFsIGZlYXR1cmUgYW5kIGlzIHRoZSBmYXN0ZXN0IG1ldGhvZCBvZiBhY3F1aXJpbmcgYm9vc3RyYXBzIGNvbmZpZ3VyZWQgZm9yIHRoZSBhcHAuXG4gKiBUaGlzIEpTT04gZmlsZSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoaXMgc2NyaXB0LlxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICogUmV0dXJucyBhbiBhcnJheSBvZiByZXF1aXJlKCkgY29tcGF0aWJsZSBzdHJpbmdzIGlmIGJvb3RzdHJhcHMgd2VyZSBzdWNjZXNzZnVsbHkgbG9hZGVkIGZyb20gSlNPTi5cbiAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgSlNPTiBmaWxlIHdhcyBmb3VuZCwgYnV0IG5vIGJvb3RzdHJhcHMgd2VyZSBjb25maWd1cmVkIGZvciB0aGUgYXBwLlxuICogUmV0dXJucyBudWxsIGlmIEpTT04gZmlsZSB3YXMgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBmZXRjaFNjcmlwdHNGcm9tSnNvbigpIHtcbiAgY29uc3QgSlNPTl9GSUxFX05BTUUgPSAnYm9vdHN0cmFwLmpzb24nO1xuXG4gIHRyeSB7XG4gICAgY29uc3QganNvbkZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnksIGB0aS5pbnRlcm5hbC8ke0pTT05fRklMRV9OQU1FfWApO1xuXG4gICAgaWYgKGpzb25GaWxlLmV4aXN0cygpKSB7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IEpTT04ucGFyc2UoanNvbkZpbGUucmVhZCgpLnRleHQpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXR0aW5ncy5zY3JpcHRzKSkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3Muc2NyaXB0cztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBUaS5BUEkuZXJyb3IoYEZhaWxlZCB0byByZWFkIFwiJHtKU09OX0ZJTEVfTkFNRX1cIi4gUmVhc29uOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgc2VhcmNoZXMgdGhlIFwiUmVzb3VyY2VzXCIgZGlyZWN0b3J5IGZvciBhbGwgXCIqLmJvb3RzdHJhcC5qc1wiIGZpbGVzLlxuICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxuICogUmV0dXJucyBhbiBhcnJheSBvZiByZXF1aXJlKCkgY29tcGF0aWJsZSBzdHJpbmdzIGZvciBlYWNoIGJvb3RzdHJhcCBmb3VuZCBpbiB0aGUgc2VhcmNoLlxuICogUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiBubyBib290c3RyYXAgZmlsZXMgd2VyZSBmb3VuZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkoKSB7XG4gIGNvbnN0IHJlc291cmNlRGlyZWN0b3J5ID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5KTtcbiAgY29uc3QgcmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoID0gcmVzb3VyY2VEaXJlY3RvcnkubmF0aXZlUGF0aC5sZW5ndGg7XG4gIGNvbnN0IGJvb3RzdHJhcFNjcmlwdHMgPSBbXTtcblxuICBmdW5jdGlvbiBsb2FkRnJvbShmaWxlKSB7XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIGlmIChmaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRpcmVjdG9yeS4gUmVjdXJzaXZlbHkgbG9vayBmb3IgYm9vdHN0cmFwIGZpbGVzIHVuZGVyIGl0LlxuICAgICAgICBjb25zdCBmaWxlTmFtZUFycmF5ID0gZmlsZS5nZXREaXJlY3RvcnlMaXN0aW5nKCk7XG5cbiAgICAgICAgaWYgKGZpbGVOYW1lQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZmlsZU5hbWVBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGxvYWRGcm9tKFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShmaWxlLm5hdGl2ZVBhdGgsIGZpbGVOYW1lQXJyYXlbaW5kZXhdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbGUubmFtZS5zZWFyY2goLy5ib290c3RyYXAuanMkLykgPj0gMCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgYm9vdHN0cmFwIGZpbGUuXG4gICAgICAgIC8vIENvbnZlcnQgaXRzIHBhdGggdG8gc29tZXRoaW5nIGxvYWRhYmxlIHZpYSByZXF1aXJlKCkgYW5kIGFkZCBpdCB0byB0aGUgYXJyYXkuXG4gICAgICAgIGxldCBib290c3RyYXBQYXRoID0gZmlsZS5uYXRpdmVQYXRoO1xuICAgICAgICBib290c3RyYXBQYXRoID0gYm9vdHN0cmFwUGF0aC5zdWJzdHIocmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoLCBib290c3RyYXBQYXRoLmxlbmd0aCAtIHJlc291cmNlRGlyZWN0b3J5UGF0aExlbmd0aCAtICcuanMnLmxlbmd0aCk7XG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHMucHVzaChib290c3RyYXBQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsb2FkRnJvbShyZXNvdXJjZURpcmVjdG9yeSk7XG4gIHJldHVybiBib290c3RyYXBTY3JpcHRzO1xufVxuLyoqXG4gKiBOb24tYmxvY2tpbmcgZnVuY3Rpb24gd2hpY2ggbG9hZHMgYW5kIGV4ZWN1dGVzIGFsbCBib290c3RyYXAgc2NyaXB0cyBjb25maWd1cmVkIGZvciB0aGUgYXBwLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmluaXNoZWQgQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbmNlIGFsbCBib290c3RyYXBzIGhhdmUgZmluaXNoZWQgZXhlY3V0aW5nLiBDYW5ub3QgYmUgbnVsbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRBc3luYyhmaW5pc2hlZCkge1xuICAvLyBBY3F1aXJlIGFuIGFycmF5IG9mIGFsbCBib290c3RyYXAgc2NyaXB0cyBpbmNsdWRlZCB3aXRoIHRoZSBhcHAuXG4gIC8vIC0gRm9yIGJlc3QgcGVyZm9ybWFuY2UsIGF0dGVtcHQgdG8gZmV0Y2ggc2NyaXB0cyB2aWEgYW4gb3B0aW9uYWwgSlNPTiBmaWxlIGNyZWF0ZWQgYnkgdGhlIGJ1aWxkIHN5c3RlbS5cbiAgLy8gLSBJZiBKU09OIGZpbGUgbm90IGZvdW5kICh3aWxsIHJldHVybiBudWxsKSwgdGhlbiBzZWFyY2ggXCJSZXNvdXJjZXNcIiBkaXJlY3RvcnkgZm9yIGJvb3RzdHJhcCBmaWxlcy5cbiAgbGV0IGJvb3RzdHJhcFNjcmlwdHMgPSBmZXRjaFNjcmlwdHNGcm9tSnNvbigpO1xuXG4gIGlmICghYm9vdHN0cmFwU2NyaXB0cykge1xuICAgIGJvb3RzdHJhcFNjcmlwdHMgPSBmZXRjaFNjcmlwdHNGcm9tUmVzb3VyY2VzRGlyZWN0b3J5KCk7XG4gIH0gLy8gRG8gbm90IGNvbnRpbnVlIGlmIG5vIGJvb3RzdHJhcHMgd2VyZSBmb3VuZC5cblxuXG4gIGlmICghYm9vdHN0cmFwU2NyaXB0cyB8fCBib290c3RyYXBTY3JpcHRzLmxlbmd0aCA8PSAwKSB7XG4gICAgZmluaXNoZWQoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gU29ydCB0aGUgYm9vdHN0cmFwcyBzbyB0aGF0IHRoZXknbGwgYmUgbG9hZGVkIGluIGEgY29uc2lzdGVudCBvcmRlciBiZXR3ZWVuIHBsYXRmb3Jtcy5cblxuXG4gIGJvb3RzdHJhcFNjcmlwdHMuc29ydCgpOyAvLyBMb2FkcyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgZm91bmQuXG5cbiAgZnVuY3Rpb24gbG9hZEJvb3RzdHJhcFNjcmlwdHMoZmluaXNoZWQpIHtcbiAgICBsZXQgYm9vdHN0cmFwSW5kZXggPSAwO1xuXG4gICAgZnVuY3Rpb24gZG9Mb2FkKCkge1xuICAgICAgLy8gQXR0ZW1wdCB0byBsb2FkIGFsbCBib290c3RyYXAgc2NyaXB0cy5cbiAgICAgIHdoaWxlIChib290c3RyYXBJbmRleCA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIExvYWQgdGhlIG5leHQgYm9vdHN0cmFwLlxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGJvb3RzdHJhcFNjcmlwdHNbYm9vdHN0cmFwSW5kZXhdO1xuXG4gICAgICAgIGNvbnN0IGJvb3RzdHJhcCA9IHJlcXVpcmUoZmlsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZXF1aXJlXG4gICAgICAgIC8vIEludm9rZSB0aGUgYm9vdHN0cmFwJ3MgZXhlY3V0ZSgpIG1ldGhvZCBpZiBpdCBoYXMgb25lLiAoVGhpcyBpcyBvcHRpb25hbC4pXG4gICAgICAgIC8vIFdlIG11c3Qgd2FpdCBmb3IgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYmVmb3JlIGxvYWRpbmcgdGhlIG5leHQgc2NyaXB0LlxuICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGV4cGVjdGVkIHRvIGJlIHVzZWQgdG8gZGlzcGxheSBVSSB0byB0aGUgZW5kLXVzZXIuXG5cblxuICAgICAgICBpZiAoYm9vdHN0cmFwLmV4ZWN1dGUpIHtcbiAgICAgICAgICBib290c3RyYXAuZXhlY3V0ZShvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gV2UncmUgZG9uZSB3aXRoIHRoZSBjdXJyZW50IGJvb3RzdHJhcC4gVGltZSB0byBsb2FkIHRoZSBuZXh0IG9uZS5cblxuXG4gICAgICAgIGJvb3RzdHJhcEluZGV4Kys7XG4gICAgICB9IC8vIEludm9rZSBnaXZlbiBjYWxsYmFjayB0byBpbmZvcm0gY2FsbGVyIHRoYXQgYWxsIGxvYWRpbmcgaXMgZG9uZS5cblxuXG4gICAgICBmaW5pc2hlZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQm9vdHN0cmFwRXhlY3V0aW9uRmluaXNoZWQoKSB7XG4gICAgICAvLyBMYXN0IGJvb3RzdHJhcCBoYXMgZmluaXNoZWQgZXhlY3V0aW9uLiBUaW1lIHRvIGxvYWQgdGhlIG5leHQgb25lLlxuICAgICAgLy8gTm90ZTogQWRkIGEgdGlueSBkZWxheSBzbyB3aGF0ZXZlciBVSSB0aGUgbGFzdCBib290c3RyYXAgbG9hZGVkIGhhcyB0aW1lIHRvIGNsb3NlLlxuICAgICAgYm9vdHN0cmFwSW5kZXgrKztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZG9Mb2FkKCksIDEpO1xuICAgIH1cblxuICAgIGRvTG9hZCgpO1xuICB9IC8vIFdlJ3ZlIGZpbmlzaGVkIGxvYWRpbmcvZXhlY3V0aW5nIGFsbCBib290c3RyYXAgc2NyaXB0cy5cbiAgLy8gSW5mb3JtIGNhbGxlciBieSBpbnZva2luZyB0aGUgY2FsbGJhY2sgZ2l2ZW4gdG8gbG9hZEFzeW5jKCkuXG5cblxuICBsb2FkQm9vdHN0cmFwU2NyaXB0cyhmaW5pc2hlZCk7XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIFRoaXMgc2NyaXB0IGlzIGxvYWRlZCBvbiBhcHAgc3RhcnR1cCBvbiBhbGwgcGxhdGZvcm1zLiBJdCBpcyB1c2VkIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFByb3ZpZGUgY29uc2lzdGVudCBzdGFydHVwIGJlaGF2aW9yIGJldHdlZW4gcGxhdGZvcm1zLCBzdWNoIGFzIGxvZ2dpbmcgVGl0YW5pdW0gdmVyc2lvbi5cbiAqIC0gTG9hZCBUaXRhbml1bSdzIGNvcmUgSmF2YVNjcmlwdCBleHRlbnNpb25zIHNoYXJlZCBieSBhbGwgcGxhdGZvcm1zLlxuICogLSBQcm92aWRlIFwiKi5ib290c3RyYXAuanNcIiBzY3JpcHQgc3VwcG9ydC4gKFNpbWlsYXIgdG8gbmF0aXZlIG1vZHVsZSBvbkFwcENyZWF0ZSgpL2xvYWQoKSBzdXBwb3J0LilcbiAqIC0gTG9hZCB0aGUgYXBwIGRldmVsb3BlcidzIG1haW4gXCJhcHAuanNcIiBzY3JpcHQgYWZ0ZXIgZG9pbmcgYWxsIG9mIHRoZSBhYm92ZS5cbiAqL1xuXG5UaS5BUEkuaW5mbyhgJHtUaS5BcHAubmFtZX0gJHtUaS5BcHAudmVyc2lvbn0gKFBvd2VyZWQgYnkgVGl0YW5pdW0gJHtcIjEwLjAuMFwifS4ke1wiNDE2YWY4OWI4ZlwifSlgKTsgLy8gTG9hZCBKUyBsYW5ndWFnZSBwb2x5ZmlsbHNcbmxvYWRBc3luYyhmdW5jdGlvbiAoKSB7XG4gIC8vIFdlJ3ZlIGZpbmlzaGVkIGxvYWRpbmcvZXhlY3V0aW5nIGFsbCBib290c3RyYXAgc2NyaXB0cy5cbiAgLy8gV2UgY2FuIG5vdyBwcm9jZWVkIHRvIHJ1biB0aGUgbWFpbiBcImFwcC5qc1wiIHNjcmlwdC5cbiAgcmVxdWlyZSgnLi9hcHAnKTsgLy8gVGhpcyBldmVudCBpcyB0byBiZSBmaXJlZCBhZnRlciBcImFwcC5qc1wiIGV4ZWN1dGlvbi4gUmVhc29uczpcbiAgLy8gLSBBbGxvdyBzeXN0ZW0gdG8gcXVldWUgc3RhcnR1cCByZWxhdGVkIGV2ZW50cyB1bnRpbCBcImFwcC5qc1wiIGhhcyBoYWQgYSBjaGFuY2UgdG8gYWRkIGxpc3RlbmVycy5cbiAgLy8gLSBGb3IgQWxsb3kgYXBwcywgd2Ugbm93IGtub3cgdGhhdCBBbGxveSBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgaXRzIGdsb2JhbHMgd2VyZSBhZGRlZC5cblxuXG4gIFRpLkFwcC5maXJlRXZlbnQoJ3N0YXJ0ZWQnKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvbWFjQ2VzYXIvTGlicmFyeS9BcHBsaWNhdGlvbiBTdXBwb3J0L1RpdGFuaXVtL21vYmlsZXNkay9vc3gvMTAuMC4wLkdBL2NvbW1vbi9SZXNvdXJjZXMvYW5kcm9pZCJ9
